# This grammar defines the file format for a grammar.
# It can be used to parse .grm files.
#
# Export targets ("replacements"/output types - really need to standardise this term!):
#
#   java - output the grammar as a Java RuleSet builder class for Parser.java
#
#   hugs - output the grammar in Haskell, for import by hwi.ath.cx's parser.hs
#
#   pojo (experimental and fugly) - create a set of bean-like classes to hold grammar atoms in Java
#

# SIGNIFICANT CHANGES:
#
#    2012-03-16 Exclude Vars now *fail* if 0 chars are matched.  Rules which
#    previously found 0-length matches acceptable should be updated to accept
#    them explicitly.
#
#    2012-03-15 Introduced Include Vars (VarAccept).
#

# TESTING:
#
#   Allow easier definition of repeat and optional elements with + * and [ ... ]
#   We could also create more advanced rules with e.g. ( ... ) | ...
#
# TODO:
#
#   The Var type is not very powerful.  An anonymous regexp match might be
#   preferable.  e.g. /[$@_a-zA-Z][$@_a-zA-Z0-9]*/
#
# TODO: Provide special marker _ or . in replacements which signify whatever
# was matched.  Would allow:
#   A = B | C
#   out: _
# instead of:
#   A = B | C
#   out: B C
# which is sucky.
#
# We could also provide $1, $2, $3 like Coffescript's, in which case $0 or $_
# might be a preferable marker for "all".
#
# Hmm perhaps we could be cunning and do:
# dj:: context.add(new FunctionCall($1, $2));
# where $1 and $2 will be replaced with the actual objects returned by the
# sub-matches?  Hmm this is not possible atm since Java is not interpreted.
# If $2 is a repeat type, it should always return a list (except for
# OptionalElements which would simply be null or not.)
#
# CONSIDER:
#
#   Done? Allow Comments without blank lines (inbetween other Atoms / almost anywhere)
#   TODO? Allow Comments everywhere!  (Inbetween macros, at the end of rule lines, ...)
#
# CONSIDER: A special grammar rule type which can be given custom decision code
# *inside* the grammar, e.g. $(...) where ... contains some text-matching code
# (an implementation of the Java parser's Type.match() interface).
#
# TODO: Allow importing of other grammars.  So that, e.g. the Expression
# grammar could be imported by many other grammars.  (It might also be nice if
# we could extend the Expression grammar to e.g. CExpression and
# JavaScriptExpression, so that we can handle minor differences, presumably by
# overwriting existing atoms.)
# Importing and extending would differ in that importing will place the grammar
# rules into a namespace (so we might refer to JavaExpression.Expression),
# whereas extending would bring the rules into the local namespace, so they may
# be overridden.

Main = GrammarDefn

# java: "package grammars;\n\n" GrammarDefn

GrammarDefn = Grm
java: "package tools.parser;\n\nimport java.lang.String;\nimport java.util.Vector;\n\nimport tools.parser.*;\n\npublic class grmGrm {\n  public static void setupgrammar() {\n    Vector rulesets=Grammar.rulesets;\n    RuleSet ruleset;\n    Vector<Type> rule;\n\n" Grm "  }\n}\n"
hugs: "module Grammar where\n\ndata Type = Atom String | Var String | Str String\n          | VarExcl String String\n  deriving (Eq)\n\ndata Match = No | Yes Type String [Match] String\n  deriving (Eq)\n\ntype RuleSet = [[Type]]\n\ntype Rule = ( Type , RuleSet , [Replacement] )\n\ntype Replacement = ( String , [Type])\n\n\nrules = [ " Grm " ]\n"

Grm = GrmBit Grm
    | GrmBit

# Grm = GrmBit+

# TODO: We can try adding ! after Whitespace.  If we have matched some Whitespace then it can't be a comment or an AtomDef, so recursion back through here can quit easily.
# No dude it won't ever test Comment or AtomDef if Whitespace matched, it returns on a whole match.  Therefore ! is only useful if it comes before the end of the line.

GrmBit = Whitespace
       | Comment
       | AtomDef

Comment = "#" <comment/"\n"> "\n"
        | "#\n"
java: "    //" <comment> "\n"
pojo: "    //" <comment> "\n"

OptComment = Comment | ""

# hugs: "-- " <comment> "\n"

NL = "\n"

OptSpc = SpcBit OptSpc
       | ""

SpcBit = " " | "\t"

# Note that two AtomDefs without an empty line between them will not parse!

# AtomName = <atomname/"^.<>\n!qt! =">
AtomName = <atomtype/"^.<>\n\t\r !qt!+*()![]{}">
# AtomName = <atomtype~"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_">

AtomDef = AtomName " = " Defn OptReplacements NL
java: "    ruleset=new RuleSet(!qt!" AtomName "!qt!);\n      rulesets.add(ruleset);\n      rule=new Vector<Type>();\n" Defn "      ruleset.add(rule);\n" OptReplacements "\n"
hugs: "  ( Atom !qt!" AtomName "!qt!,[\n    [ " Defn " ]\n    ] , [\n" OptReplacements "\n  ] ) ,\n"
pojo: "interface " AtomName " {\n\n}\n  class AnImplmentation {\n" Defn "  }\n\n"

# Replacements are the lines defining export targets: java, hugs, pojo

OptReplacements = "\n" Replacements
                | ""
java: "    // Replacements\n" Replacements

Replacements = ManyReplacements
             | Replacement

ManyReplacements = Replacement "\n" Replacements
hugs: Replacement ",\n" Replacements

# Note that use of + and * make it harder to place things *inbetween* the
# elements during output (list join), so the above hugs output cannot currently
# be easily reproduced with + or * as in the new rule below!

# Replacements = ( Replacement "\n" )+
# Replacements = Replacement ( "\n" Replacement )+ | ""

Replacement = <target/"<>\n!qt! :"> ": " Defn
java: "    rule=new Vector<Type>();\n" Defn "    ruleset.replacements.put(!qt!" <target> "!qt!,rule);\n"
hugs: "      ( !qt!" <target> "!qt! , [ " Defn " ] ) "

Defn = DefnOr
     | DefnAnd
     | DefnBit

# RelativeElement is only used for output, not matching.
# Perhaps we should create DefnBit and OutDefnBit, the latter containing those
# few extra rules which can only be used for outputs.

DefnBit = RelativeElement
        | BasicElement OptRepeatMarker

BasicElement = Variable
             | ActiveReplacement
             | Text
             | GroupElement
             | AtomRef
             | Regexp
             | OptionalElement
             | MagicTokenOfDoom

#              | RepeatElement

# CONSIDER: Could be put = BasicElement RepeatMarker | ... at the top?
# No, again that's inf recursive.  But we could try:
# BasicElement = BasicElement2 RepeatMarker | BasicElement2

# This might be called "exclusion" in Prolog.  *yawn*
# If the magic token is reached, none of later options in a DefnBit will be attempted.
# In other words, ! commits us to the current line, or failure.

MagicTokenOfDoom = "!"

# This can make things more efficient, by allowing us to exclude searches that
# we know are invalid.
# But should it be a full commit?  I.e.:
#   1) If rest of arguments fail, fall back out and try next in parent.
#   2) If rest of arguments fail, report error and stop parsing!

# I can envisage another token which might be useful.  Let's call it % for now.
# It can be used to mark a force-fail match, e.g. in the following
#   cat = % Dog
#       | BlackCat | WhiteCat | GreyCat | OtherCat
# % Dog means drop out immediately with failure if we match a Dog.  It can be
# used a an heuristic in some situations, where we expect a Dog is much more
# likely, so generally more efficient to check that than to check all the cats
# first.

# Perhaps ! should be renamed . so % can be renamed ! (since it basically means "not").

GroupElement = "(" OWS Defn OWS ")"
java: "        rule.add( new GroupedDefn((RuleSet) new Runner(){ Object run(){\n          RuleSet ruleset = new RuleSet(!qt!Anonymous!qt!);\n        Vector<Type> rule = new Vector<Type>();\n" Defn "        ruleset.add(rule);\n          return ruleset;\n        } }.run() ) );\n"

# Too recursive I suspect:
#RepeatElement = DefnBit "*"
# Since RepeatElement was hard to define for "*" and "+", we parse repeat
# through OptRepeatMarker, a single char after an atom match.

OptionalElement = "[" OWS Defn OWS "]"
java: Defn "        rule.set(rule.size()-1, new RepeatedRule((Type)rule.lastElement(),0,1));\n"

OptRepeatMarker = RepeatMarker | ""

RepeatMarker = RepeatMarker2
java: "        rule.set(rule.size()-1, new RepeatedRule((Type)rule.lastElement(),!qt!" RepeatMarker2 "!qt!));\n"

RepeatMarker2 = ZeroOrMore | OneOrMore

ZeroOrMore = "*"
java: "*"
javaB: 0,-1

OneOrMore = "+"
java: "+"
javaB: 1,-1

ZeroOrOne = OptionalElement
javaB: 0,1

# javaB: pass min and max rather than symbols

DefnOr = DefnBit Whitespace "|" Whitespace Defn
java: DefnBit "      ruleset.add(rule);\n      rule=new Vector<Type>();\n" Defn
hugs: DefnBit "] ,\n      [ " Defn
pojo: DefnBit "  }\n  class AnotherImplementation {\n" Defn

DefnAnd = DefnBit " " Defn
java: DefnBit Defn
hugs: DefnBit ", " Defn

Variable = Var
         | VarDeny
         | VarAccept

# I think Var is a VarReference - cannot be used for parsing (no terminal
# condition!) but is used in replacements.

# TODO: Perhaps make it explicit that Var and Re

Var = "<" <varname/"<>\n!qt!/ "> ">"
java: "        rule.add(new Var(!qt!" <varname> "!qt!));\n"
hugs: "Var !qt!" <varname> "!qt!"
pojo: "    String " <varname> ";\n"

VarDeny = "<" <varname/"<>\n!qt!/ ~"> "/!qt!" <denied/"!qt!"> "!qt!>"
java: "        rule.add(new Var(!qt!" <varname> "!qt!,!qt!" <denied> "!qt!));\n"
hugs: "VarExcl !qt!" <varname> "!qt! !qt!" <denied> "!qt!"
pojo: "    String " <varname> ";\n"

VarAccept = "<" <varname/"<>\n!qt!/ ~"> "~!qt!" <accepted/"!qt!"> "!qt!>"
java: "        rule.add(new Var(!qt!" <varname> "!qt!,null,!qt!" <accepted> "!qt!));\n"
hugs: "VarIncl !qt!" <varname> "!qt! !qt!" <denied> "!qt!"
pojo: "    String " <varname> ";\n"

AtomRef = AtomName
java: "        rule.add(new Atom(!qt!" AtomName "!qt!));\n"
hugs: "Atom !qt!" AtomName "!qt!"
pojo: "    " AtomName " arg1;\n"

# pojo: "  /* Possible " <atomtype> " */\n"

# CONSIDER: To avoid this stupid !qt! marker, we could ensure \" is interpreted
# by the Text reader.
#
# We could also offer TextApos, which would be a '...' string instead of "..."
#
# Note that TextApos would need a different reader setup (if we adopt the same
# as JS and sh, that "s can exist inside a '...' but we then must escape \')
#
# Introduction of '...' seems unneccessary, and could be saved for something
# special!  But replacement of !qt! with \" seems desirable.

Text = "!qt!" <text/"!qt!"> "!qt!"
     | "!qt!!qt!"
java: "        rule.add(new Text(!qt!" <text> "!qt!));\n"
hugs: "Str !qt!" <text> "!qt!"
pojo: "    /* Matched: !qt!" <text> "!qt! */\n"

WhitespaceBit = "\n" | " " | "\t" | "\r"

# Whitespace = WhitespaceBit Whitespace
#            | WhitespaceBit

Whitespace = WhitespaceBit+
# Whitespace = <whitespace~"\n \t\r">

# Optional whitespace:

# OWS = Whitespace
#     | ""

OWS = WhitespaceBit*



# == Experimental Stuff ==

# This is used in c.grm.  It allows for more complex output, but calling the
# code inside `...`s with the match Object available as a local field.

ActiveReplacement = "`" <java/"`"> "`"
java: "      rule.add( new ActiveReplacement() { public String replace() { " <java> " } } );\n"

# I think RelativeElement might be a dodgy way to access variables in parent/child types.
# ^SearchUp->SearchDown.DirectDown

RelativeElement = RelUp
                | RelDown

RelUp = Ref "^" BasicElement
java: "        { Vector realrule=rule; rule=new Vector<Type>(); " BasicElement " realrule.add(new RelElement('^'," Ref ",(Type)rule.get(0))); rule=realrule; }\n"

RelDown = Ref "." BasicElement
java: "        { Vector realrule=rule; rule=new Vector<Type>(); " BasicElement " realrule.add(new RelElement('.'," Ref ",(Type)rule.get(0))); rule=realrule; }\n"

Ref = <ref/" !qt!\n.^">
java: "!qt!" <ref> "!qt!"



# Untested...

# TODO: Gah presumably we need to escape any "s in the output of RegexpBody
Regexp = "/" RegexpBody "/"
java: "new Regexp(!qt!" RegexpBody "!qt!)"

RegexpBody = RegexpBit RegexpBody
           | ""

RegexpBit = "\\" AnyOneChar RegexpBit
          | "[" RegexpCharBlock "]" RegexpBit
          | <regexpbit/"\\/[\n"> RegexpBit
          | ""

RegexpCharBlock = "\\" AnyOneChar RegexpCharBlock
                | <regexpcharblock/"]\n"> RegexpCharBlock
                | ""


DummyTestRule = ( DummyTestContents )

