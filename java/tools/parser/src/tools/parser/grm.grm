# This grammar defines the file format for a grammar.
# It can be used to parse .grm files.
#
# Export targets:
#
#   java - output the grammar as a Java RuleSet builder class for Parser.java
#
#   hugs - output the grammar in Haskell, for import by hwi.ath.cx's parser.hs
#
#   pojo (experimental and fugly) - create a set of bean-like classes to hold grammar atoms in Java
#

# TODO:
#
#   Allow easier definition of repeat and optional elements with + * and [ ... ]
#
#   The Var type is not very powerful.  An anonymous regexp match might be
#   preferable.  e.g. /[$@_a-zA-Z][$@_a-zA-Z0-9]*/
#

# CONSIDER:
#   Allow Comments without blank lines (inbetween other Atoms / almost anywhere)

Main = GrammarDefn

# java: "package grammars;\n\n" GrammarDefn

GrammarDefn = Grm
java: "package tools.parser;\n\nimport java.lang.String;\nimport java.util.Vector;\n\nimport tools.parser.*;\n\npublic class grmGrm {\n  public static void setupgrammar() {\n    Vector rulesets=Grammar.rulesets;\n    RuleSet ruleset;\n    Vector rule;\n\n" Grm "  }\n}\n"
hugs: "module Grammar where\n\ndata Type = Atom String | Var String | Str String\n          | VarExcl String String\n  deriving (Eq)\n\ndata Match = No | Yes Type String [Match] String\n  deriving (Eq)\n\ntype RuleSet = [[Type]]\n\ntype Rule = ( Type , RuleSet , [Replacement] )\n\ntype Replacement = ( String , [Type])\n\n\nrules = [ " Grm " ]\n"

Grm = GrmBit Grm
    | GrmBit

GrmBit = Whitespace
       | Comment
       | AtomDef

Comment = "#" <comment/"\n"> "\n"
java: "    //" <comment> "\n"
pojo: "    //" <comment> "\n"

OptComment = Comment | ""

# hugs: "-- " <comment> "\n"

NL = "\n"

OptSpc = SpcBit OptSpc
       | ""

SpcBit = " " | "\t"

# Note that two AtomDefs without an empty line between them will not parse!

AtomDef = <atomname/"^.<>\n!qt! ="> " = " Defn OptReplacements NL OptSpc NL
java: "    ruleset=new RuleSet(!qt!" <atomname> "!qt!);\n      rulesets.add(ruleset);\n      rule=new Vector();\n" Defn "      ruleset.add(rule);\n" OptReplacements "\n"
hugs: "  ( Atom !qt!" <atomname> "!qt!,[\n    [ " Defn " ]\n    ] , [\n" OptReplacements "\n  ] ) ,\n"
pojo: "interface " <atomname> " {\n\n}\n  class AnImplmentation {\n" Defn "  }\n\n"

# Replacements are the lines defining export targets: java, hugs, pojo

OptReplacements = "\n" Replacements
                | ""
java: "    // Replacements\n" Replacements

Replacements = TwoReplacements
             | Replacement

TwoReplacements = Replacement "\n" Replacements
hugs: Replacement ",\n" Replacements

Replacement = <target/"<>\n!qt! :"> ": " Defn
java: "    rule=new Vector();\n" Defn "    ruleset.replacements.put(!qt!" <target> "!qt!,rule);\n"
hugs: "      ( !qt!" <target> "!qt! , [ " Defn " ] ) "

Defn = DefnOr
     | DefnAnd
     | DefnBit

DefnBit = RelativeElement
        | BasicElement

BasicElement = Variable
             | ActiveReplacement
             | Text
             | AtomRef

DefnOr = DefnBit Whitespace "|" Whitespace Defn
java: DefnBit "      ruleset.add(rule);\n      rule=new Vector();\n" Defn
hugs: DefnBit "] ,\n      [ " Defn
pojo: DefnBit "  }\n  class AnotherImplementation {\n" Defn

DefnAnd = DefnBit " " Defn
java: DefnBit Defn
hugs: DefnBit ", " Defn

Variable = Var
         | VarDeny
         | VarAccept

Var = "<" <varname/"<>\n!qt!/ "> ">"
java: "        rule.add(new Var(!qt!" <varname> "!qt!));\n"
hugs: "Var !qt!" <varname> "!qt!"
pojo: "    String " <varname> ";\n"

VarDeny = "<" <varname/"<>\n!qt!/ ~"> "/!qt!" <denied/"!qt!"> "!qt!>"
java: "        rule.add(new Var(!qt!" <varname> "!qt!,!qt!" <denied> "!qt!));\n"
hugs: "VarExcl !qt!" <varname> "!qt! !qt!" <denied> "!qt!"
pojo: "    String " <varname> ";\n"

VarAccept = "<" <varname/"<>\n!qt!/ ~"> "~!qt!" <accepted/"!qt!"> "!qt!>"
java: "        rule.add(new Var(!qt!" <varname> "!qt!,null,!qt!" <accepted> "!qt!));\n"
hugs: "VarIncl !qt!" <varname> "!qt! !qt!" <denied> "!qt!"
pojo: "    String " <varname> ";\n"

AtomRef = <atomtype/"^.<>\n!qt! ">
java: "        rule.add(new Atom(!qt!" <atomtype> "!qt!));\n"
hugs: "Atom !qt!" <atomtype> "!qt!"
pojo: "    " <atomtype> " arg1;\n"

# pojo: "  /* Possible " <atomtype> " */\n"

Text = "!qt!" <text/"!qt!"> "!qt!"
     | "!qt!!qt!"
java: "        rule.add(new Text(!qt!" <text> "!qt!));\n"
hugs: "Str !qt!" <text> "!qt!"
pojo: "  /* Matched: !qt!" <text> "!qt! */\n"

Whitespace = WhitespaceBit Whitespace
           | WhitespaceBit

WhitespaceBit = "\n"
              | " "
              | "\t"
              | "\r"



# == Experimental Stuff ==

# This might be stable or entirely ignored - I don't know.

ActiveReplacement = "`" <java/"`"> "`"
java: "      rule.add( new ActiveReplacement() { public String replace() { " <java> " } } );\n"

# I think RelativeElement might be a dodgy way to access variables in parent/child types.
# ^SearchUp->SearchDown.DirectDown

RelativeElement = RelUp
                | RelDown

RelUp = Ref "^" BasicElement
java: "        { Vector realrule=rule; rule=new Vector(); " BasicElement " realrule.add(new RelElement('^'," Ref ",(Type)rule.get(0))); rule=realrule; }\n"

RelDown = Ref "." BasicElement
java: "        { Vector realrule=rule; rule=new Vector(); " BasicElement " realrule.add(new RelElement('.'," Ref ",(Type)rule.get(0))); rule=realrule; }\n"

Ref = <ref/" !qt!\n.^">
java: "!qt!" <ref> "!qt!"

