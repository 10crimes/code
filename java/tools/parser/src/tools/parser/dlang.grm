# DLang - A dumb language
#
# Export targets:
#
# dintj - runtime structures suitable for interpreting by Java dlang.interpreter.*

# TODO:
#   Array dereference (aka List shortcuts)
#   Member dereference (fields and methods of objects).  Similar for statics...
#   .. namespaces
#   Constructor definition and invocation
#   Templating (generics)
#   Anonymous implementations?  Or first order functions...
#   Shortcuts for hashmaps
#   Loops
#   Define terminator symbol, e.g. "\n" | ";"

# This is not exactly minimal, but we'd like a nicer way to access the last
# element in an array than l[l.length-1]

# @IMPORT DExpression "dexpr.grm"
# @OPTION wrap_meaningful_indentation "{" "}"

Main = DLangFile

DLangFile = DLangHeader MutableCodeBlock
java: "package dlang.parsed;\n\nimport java.lang.String;\nimport java.util.Vector;\n\nimport dlang.types.*;\n\npublic class DLangFile {\n  public static void build() {\n    \n\n" Grm "  }\n}\n"

# DLangHeader = DLangModuleBlock DLangImports

# DLangModuleBlock = Comment DLangModuleBlock
#                  | Space DLangModuleBlock
#                  | DLangModule
#                  | ""

DLangHeader = [ Comment ] [ DLangModule ] [ Comment ] [ DLangImports ]

DLangModule = "package" Space <module/"\n;"> EOL
            | "module" Space <module/"\n;"> EOL

# DLangImports = DLangImport [ DLangImports ]

# Bad defn but gets caught - try it!
# DLangImports = ( DLangImport | WS )*

DLangImports = ( DLangImport | Space )*

DLangImport = DLangImportProper
            | Comment
            | Space

DLangImportProper = "import" Space <import/"\n"> "\n"

# Should it be 0 or more?

Comment = "#" <comment/"\n"> "\n"
        | "//" <comment/"\n"> "\n"
dintj: "\n/*" <comment> "*/\n"

# TODO: Parametrised classes (templates)
ClassDefinition = "class" Space <className/" \n"> OptClassMods NL ClassBody
dintj: "new ClassDefinition(!qt!" className "!qt!, " ClassBody ", !qt!" OptClassMods "!qt!)"

OptClassMods = Space "extends" Space ClassRef
             | Space "implements" Space ClassRef
             | OptHorizSpace

ClassBody = ""
dintj: "[]"

# ClassBody = IndentedDLangBlock

# TODO: I guess it will be "{" OWS DLangFileSome OWS "}"
IndentedDLangBlock = DLangFileSome

FunctionDefinition = <fnname/" ("> "(" ArgumentSignatureList ")" WS "=" WS FunctionBody
dintj: "new Function(!qt!" <fnname> "!qt!, {" ArgumentSignatureList "}, " FunctionBody ")"

FunctionBody = NiceCode | MutableCodeBlock

## NiceCode swallowed the var from an assignment statement
## Should NiceCode demand that it ends neatly with an EOL?
# FunctionBody = MutableCode

# NiceCode = Expression Space "where" Space NiceNEDefs EOL
#          | Expression EOL

NiceCode = Expression ( Space "where" Space NiceNEDefs EOL | EOL )

NiceNEDefs = NamedExpression '\n' NiceNEDefs
           | NamedExpression

MutableCodeBlock = MutableCodeInner*
dintj: "new MutableCodeBlock({" MutableCodeInner "})"

# Note we test FunctionDefinition before FunctionCall - they both look similar at the start!

MutableCodeInner = Space | NonStatement | Statement

ArgumentSignatureList = ArgumentSignature MoreArgs
     | ArgumentSignature
     | WS

# ArgumentSignature = TypedArg | UntypedArg
ArgumentSignature = UntypedArg

UntypedArg = WS VarName WS

TypedArg = WS Type Space VarName WS

MoreArgs = "," ArgumentSignatureList

# Identifier = <varname/"<>\n!qt!. :^+-*()/">
Identifier = <varname~"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$@0-9">

VarName = Identifier

ClassName = Identifier

VarReference = VarName
dintj: "new VarReference(!qt!" VarName "!qt!)"

# Could also be called a PrimitiveLiteral
ConstReference = Number | String
dintj: "Constants.getConstRef(" Number String ")"

Statement = Assignment | FunctionCall | Loop

NonStatement = Comment | ClassDefinition | FunctionDefinition

Assignment = NormalAssignment
           | SpecialAssignment

NormalAssignment = VarOrMemberReference OptHorizSpace "=" Expression EOL
dintj: "new NormalAssignment(" VarOrMemberReference "," Expression ")"

SpecialAssignment = VarOrMemberReference OptHorizSpace SpecialAssignmentOperator Expression EOL
dintj: "new SpecialAssignment(" VarOrMemberReference ",!qt!" SpecialAssignmentOperator "!qt!," Expression ")"

SpecialAssignmentOperator = "+=" | "-=" | "*=" | "/="

# ConstReference must come first because ATM VarOrMemberReference swallows numbers!

ExpressionTerminal = ConstReference | VarOrMemberReference

Expression = ExpressionBit OptHorizSpace

# We have a problem with Algebra
# If I let Algebra contain Expressions, then it calls its repeatedly!

ExpressionBit = HorizSpace ExpressionBit
              | Algebra
              | ExpressionAtom

ExpressionAtom = HorizSpace ExpressionAtom
               | FunctionCall
               | BracketedExpression
               | ExpressionTerminal

# TODO: There is no support here for calling the results of expressions (or their members) :F
# If it is impossible to replace VarOrMemberReference with Expression because
# of infinite recursion, then perhaps OptFinalCall should be available at the
# end of any expression (or expression bit), as a postfix, the same way we
# dealt with + and * in grm.

FunctionCall = ConstructorCall | RealFunctionCall

RealFunctionCall = VarOrMemberReference "(" ArgumentParameterList ")"
dintj: "new FunctionCall(" VarOrMemberReference ", [" ArgumentParameterList "])"

ConstructorCall = "new" Space RealFunctionCall
dintj: "new ConstructorCall(" RealFunctionCall ")"

MemberName = VarName

VarOrMemberReference = VarReference "." VarOrMemberReference
                     | VarReference

#                      | VarName

ArgumentParameterList = Expression "," ArgumentParameterList
                      | Expression
                      | ""

BracketedExpression = "(" WS ExpressionBit WS ")"

## Can lock us in a cyclic loop ExpressionBit -> Algebra -> ExpressionBit !
# Algebra = ExpressionBit Operator ExpressionBit

Algebra = ExpressionAtom OptHorizSpace Operator OptHorizSpace Expression
dintj: "new Operation(" ExpressionAtom "," Operator "," Expression ")"

TerminalAlgebraicOperation = ExpressionAtom OptHorizSpace Operator OptHorizSpace Expression

Operator = OperatorSymbol
dintj: "Operators.getOperator(!qt!" OperatorSymbol "!qt!)"
# dintj: "new Operator(!qt!" OperatorSymbol "!qt!)"

# We can't do: Constants.getOperator("*") here because not all are defined by
# default, i.e. there may be an operator with a custom name.  I suppose
# context.lookupOperator("*") might work.  For the moment though, we refer to
# it by string, which would allow for operators to be defined after their first
# appearance in the file.

OperatorSymbol = BooleanOperator | AlgebraicOperator | OtherOperator

AlgebraicOperator = "*" | "/" | "+" | "-" | "^" | "<<" | ">>" | "&" | "|"

BooleanOperator = "==" | "!=" | ">" | "<" | ">=" | "<=" | "&&" | "||"

OtherOperator = "<" <varname/" \n\t,."> ">"


VarDeclaration = VarDeclarationAndAssignment
               | VarDeclarationWithoutAssignment

VarDeclarationWithoutAssignment = "var" Space VarName

#                                 | Type Space VarName
#                                 | "var" Space VarName WS ":" WS Type
#                                 | VarName WS ":" WS Type

Type = TypeWithoutTemplate | TypeWithTemplate

TypeWithoutTemplate = Identifier

TypeWithTemplate = TypeWithoutTemplate WS Template

Template = "<" TemplateBits ">"

TemplateBits = WS TemplateBit WS "," WS TemplateBits
             | WS TemplateBit

VarDeclarationAndAssignment = VarDeclarationWithoutAssignment WS "=" WS Expression

Number = Float | Int

Float = Digits "." Digits

Int = Digits

Digits = Digit Digits
       | Digit

# Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

Digit = <number~"0123456789">

String = "!qt!" <string/"!qt!"> "!qt!"

Loop = ForNumLoop | ForListLoop | WhileLoop

ForNumLoop = "for" Space VarName WS "=" WS LoopRange WS ForBody
dintj: "new ForNumLoop(" VarName "," LoopRange ")"
# "{" ForBody "}"

ForListLoop = "for" Space VarName Space "in" Space Expression WS ForBody
dintj: "new ForListLoop(" VarName "," Expression ")"
# "{" ForBody "}"

ForBody = MutableCodeBlock

## TODO: Gah - Expressions don't parse nicely here!  (They swallow the "to" or what?)
# LoopRange = Expression Space "to" Space Expression

LoopRange = ConstReference Space ( "to" | ".." ) Space Expression OptStep
dintj: "new LoopRange(" ConstReference "," Expression ")"

OptStep = WS ( "step" | "by" ) Space Expression
        | ""

WhileLoop = "while" Space Condition

Condition = Expression

# We hope to handle significant indentation by pre-parsing the lines and
# rewriting with "{" and "}"s which the grammar can easily detect.  This may
# cause issues on multi-line statements which should not have "{" and "}"s!



# WS    = Optional WhiteSpace
# Space = Required WhiteSpace

NL = "\n"

WS = Whitespace | ""

Space = Whitespace

# Whitespace = WhitespaceBit Whitespace
           # | WhitespaceBit
# 
# WhitespaceBit = "\n"
              # | " "
              # | "\t"
              # | "\r"

Whitespace = <whitespace~" \t\n\r">

# Expressions will eat into the next line if allowed to swallow "\n"s
# They don't know when to stop!
# So we only allow them to swallow HorizSpace

# HorizSpace = " " | "\t"
HorizSpace = <horizspace~" \t">

OptHorizSpace = HorizSpace | ""

# EOL = ";" | "\n"

EOL = "\n"

