# DLang - A dumb language
#
# Export targets:
#
# dintj - runtime structures suitable for interpreting by Java dlang.interpreter.*

# TODO:
#   Array dereference (aka List shortcuts)
#   Member dereference (fields and methods of objects).  Similar for statics...
#   .. namespaces
#   Constructor definition and invocation
#   Templating (generics)
#   Anonymous implementations?  Or first order functions...
#   Shortcuts for hashmaps
#   Loops

# @OPTION rewrite_meaningful_indentation "{" "}"

Main = DLangFile

DLangFile = DLangImports DLangFileSome

# DLangImports = DLangImport [ DLangImports ]

DLangImports = DLangImport DLangImports
             | DLangImport

DLangImport = DLangImportProper
            | Comment
            | Space

DLangImportProper = "import" Space <import/"\n"> "\n"

DLangFileSome = DLangFileBit DLangFile
              | DLangFileBit

# Should it be 0 or more?

DLangFileBit = Comment | ClassDefinition | FunctionDefinition | Statement

Comment = "#" <comment/"\n"> "\n"
        | "//" <comment/"\n"> "\n"

# DLangFileSome = 1 or more DLangFileBits
# TODO: Parametrised classes (templates)
ClassDefinition = "class" WS <className/" \n"> WS NL WS ClassBody

ClassBody = IndentedDLangFileSome

# TODO
IndentedDLangFileBit = DLangFileSome

FunctionDefinition = <fnname/" ("> "(" ArgumentSignatureList ")" WS "=" WS FunctionBody
dintj: "new Function(!qt!" <fnname> "!qt!," ArgumentSignatureList "," FunctionBody ")"

FunctionBody = NiceCode | MutableCode

NiceCode = Expression Space "where" Space NiceNEDefs
         | Expression

NiceNEDefs = NamedExpression '\n' NiceNEDefs
           | NamedExpression

MutableCode = WS Statement | MutableCode
            | WS Statement

ArgumentSignatureList = ArgumentSignature MoreArgs
     | ArgumentSignature
     | WS

ArgumentSignature = TypedArg | UntypedArg

TypedArg = WS VarName WS

UntypedArg = WS Type Space VarName WS

MoreArgs = "," ArgumentSignatureList

VarName = <varname/"<>\n!qt!. :^+-*/">

VarReference = VarName

Statement = Assignment

Assignment = NormalAssignment
           | SpecialAssignment

NormalAssignment = VarOrMemberReference WS "=" Expression

SpecialAssignment = VarOrMemberReference WS SpecialAssignmentOperator Expression

SpecialAssignmentOperator = "+=" | "-=" | "*=" | "/="

ExpressionTerminal = VarOrMemberReference

Expression = ExpressionBit

ExpressionBit = Space ExpressionBit
              | Algebra
              | FunctionCall
              | VarOrMemberReference
              | BracketedExpression

# TODO: There is no support here for calling the results of expressions (or their members) :F

FunctionCall = MemberReferenceOrNot "(" ArgumentParameterList ")"

MemberName = VarName

VarOrMemberReference = VarReference "." MemberName
                     | VarReference

#                      | VarName

ArgumentParameterList = Expression "," ArgumentParameterList
                      | Expression
                      | ""

BracketedExpression = "(" WS ExpressionBit WS ")"

Algebra = ExpressionBit Operator ExpressionBit

Operator = OperatorSymbol
dintj: "new Operator(" OperatorSymbol ")"

OperatorSymbol = AlgebraicOperator | BooleanOperator | OtherOperator

AlgebraicOperator = "*" | "/" | "+" | "-"

BooleanOperator = "==" | "!=" | ">" | "<" | ">=" | "<="

OtherOperator = "<" <varname/" \n\t,."> ">"


VarDeclaration = VarDeclarationAndAssignment
               | VarDeclarationWithoutAssignment

VarDeclarationWithoutAssignment = "var" Space VarName
                                | Type Space VarName
                                | "var" Space VarName WS ":" WS Type
                                | VarName WS ":" WS Type

VarDeclarationAndAssignment = VarDeclarationWithoutAssignment WS "=" WS Expression



# HTF will I deal with indentation?



# WS    = Optional WhiteSpace
# Space = Required WhiteSpace

NL = "\n"

WS = Whitespace | ""

Space = Whitespace

Whitespace = WhitespaceBit Whitespace
           | WhitespaceBit

WhitespaceBit = "\n"
              | " "
              | "\t"
              | "\r"

