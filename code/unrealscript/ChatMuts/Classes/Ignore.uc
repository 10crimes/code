
/* WARNING! This file was auto-generated by jpp.  You probably want to be editing ./Ignore.uc.jpp instead. */



// Ignore
// Lets players on your server ignore each other!
// vim: tabstop=2 shiftwidth=2 noexpandtab filetype=uc

class Ignore expands Mutator;

struct Victim {
 var int PIDs[32];
};

// Players are Victims because actually they are also Spammers.  The first index is the player being blocked.  The second index is the player who is blocking them.

var Victim Players[32];

function PostBeginPlay() {
 Level.Game.RegisterMessageMutator(Self);
}

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, out coerce string Msg, optional bool bBeep, out optional name Type) {
 local bool hideMessage;
 hideMessage = SuperCheckMessage(Sender,Receiver,Mid(Msg,InStr(Msg,":")+1));
 return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type) && (!hideMessage); // || !bSwallowSpokenCommands);
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
 local bool hideMessage;
 hideMessage = SuperCheckMessage(Sender,Receiver,Msg);
 return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage); // || !bSwallowSpokenCommands);
}

// Returns True if this message should be swallowed / hidden from other players.
function bool SuperCheckMessage(Actor Sender, Pawn Receiver, String Msg) {
 local Pawn Target;
 local Victim v;
 local int blocker,spammer;
 if (PlayerPawn(Sender) != None && PlayerPawn(Receiver) != None) {
  // if (Players[PlayerPawn(Receiver).PlayerReplicationInfo.PlayerID].PIDs[PlayerPawn(Sender).PlayerReplicationInfo.PlayerID] > 0) {
  blocker = PlayerPawn(Receiver).PlayerReplicationInfo.PlayerID;
  spammer = PlayerPawn(Sender).PlayerReplicationInfo.PlayerID;
  v = Players[spammer];
  // if (Players[spammer].PIDs[blocker] > 0) {
  if (v.PIDs[blocker] > 0) {
   // Receiver is ignoring Sender
   return true;
  }
 }
 if (Sender == Receiver && StrStartsWith(Caps(Msg),"!IGNORE")) {
  Target = FindPlayerNamed( StrAfterFirst(Msg," ") );
  AddIgnore(PlayerPawn(Sender), PlayerPawn(Target));
  PlayerPawn(Sender).ClientMessage("You are now ignoring "$Target.getHumanName());
 }
 return False;
}

function AddIgnore(PlayerPawn Receiver, PlayerPawn Target) {
 // Players[ Receiver.PlayerReplicationInfo.PlayerID ].PIDs[ Target.PlayerReplicationInfo.PlayerID ] = 1;
 local Victim v;
 local int blocker,spammer;
 blocker = Receiver.PlayerReplicationInfo.PlayerID;
 spammer = Target.PlayerReplicationInfo.PlayerID;
 v = Players[spammer];
 v.PIDs[blocker] = 1;
}

/*

function Mutate(String str, PlayerPawn Sender) {

	if (bAcceptMutateCommands) {

		CheckMessage(str, Sender);

	}

	Super.Mutate(str, Sender);

}

*/
/*

event Timer() {

	local Pawn p;



	if (bCheckMailOnPlayerJoin) {

		CheckForNewPlayers();

	}

}



function CheckForNewPlayers() {

	local Pawn p;

	while (Level.Game.CurrentID > lastPlayerChecked) {

		for (p=Level.PawnList; p!=None; p=p.NextPawn) {

			if (p.IsA('PlayerPawn') && p.PlayerReplicationInfo.PlayerID == lastPlayerChecked) {

				ProcessNewPlayer(PlayerPawn(p));

				break;

			}

		}

		lastPlayerChecked++;

	}

}



function ProcessNewPlayer(PlayerPawn p) {

	// Check for new mail for this player:

	if ( ! CheckMailFor(p) ) {

		// Only announce the mutator if they didn't have new mail:

		if (bAnnounceOnJoin) {

			p.ClientMessage("This server is running the PostBox mutator.");

			p.ClientMessage("You can leave messages for other players with the !mail command.");

		}

	}

}

*/
// Find player by name, or partial name
function Pawn FindPlayerNamed(String name) {
 local Pawn p;
 local Pawn found;
 for (p=Level.PawnList; p!=None; p=p.NextPawn) {
  if (p.IsA('PlayerPawn') || p.IsA('Bot')) {
   if (p.getHumanName() ~= name) { // exact case insensitive match, return player
    return p;
   }
   if (Instr(Caps(p.getHumanName()),Caps(name))>=0) { // partial match, remember it but keep searching for exact match
    found = p;
   }
  }
 }
 return found; // return partial match, or None
}
//===============//
//               //
//  JLib.uc.jpp  //
//               //
//===============//
function int SplitString(String str, String divider, out String parts[256]) {
 // local String parts[256];
 // local array<String> parts;
 local int i,nextSplit;
 i=0;
 while (true) {
  nextSplit = InStr(str,divider);
  if (nextSplit >= 0) {
   // parts.insert(i,1);
   parts[i] = Left(str,nextSplit);
   str = Mid(str,nextSplit+Len(divider));
   i++;
  } else {
   // parts.insert(i,1);
   parts[i] = str;
   i++;
   break;
  }
 }
 // return parts;
 return i;
}
function string GetDate() {
 local string Date, Time;
 Date = Level.Year$"/"$PrePad(Level.Month,"0",2)$"/"$PrePad(Level.Day,"0",2);
 Time = PrePad(Level.Hour,"0",2)$":"$PrePad(Level.Minute,"0",2)$":"$PrePad(Level.Second,"0",2);
 return Date$"-"$Time;
}
// NOTE: may cause an infinite loop if p=""
function string PrePad(coerce string s, string p, int i) {
 while (Len(s) < i)
  s = p$s;
 return s;
}
function bool StrStartsWith(string s, string x) {
 return (InStr(s,x) == 0);
 // return (Left(s,Len(x)) ~= x);
}
function bool StrEndsWith(string s, string x) {
 return (Right(s,Len(x)) ~= x);
}
function bool StrContains(String s, String x) {
 return (InStr(s,x) > -1);
}
function String StrAfter(String s, String x) {
 return StrAfterFirst(s,x);
}
function String StrAfterFirst(String s, String x) {
 return Mid(s,Instr(s,x)+Len(x));
}
function string StrAfterLast(string s, string x) {
 local int i;
 i = InStr(s,x);
 if (i == -1) {
  return s;
 }
 while (i != -1) {
  s = Mid(s,i+Len(x));
  i = InStr(s,x);
 }
 return s;
}
function string StrBefore(string s, string x) {
 return StrBeforeFirst(s,x);
}
function string StrBeforeFirst(string s, string x) {
 local int i;
 i = InStr(s,x);
 if (i == -1) {
  return s;
 } else {
  return Left(s,i);
 }
}
function string StrBeforeLast(string s, string x) {
 local int i;
 i = InStrLast(s,x);
 if (i == -1) {
  return s;
 } else {
  return Left(s,i);
 }
}
function int InStrOff(string haystack, string needle, int offset) {
 local int instrRest;
 instrRest = InStr(Mid(haystack,offset),needle);
 if (instrRest == -1) {
  return instrRest;
 } else {
  return offset + instrRest;
 }
}
function int InStrLast(string haystack, string needle) {
 local int pos;
 local int posRest;
 pos = InStr(haystack,needle);
 if (pos == -1) {
  return -1;
 } else {
  posRest = InStrLast(Mid(haystack,pos+Len(needle)),needle);
  if (posRest == -1) {
   return pos;
  } else {
   return pos + Len(needle) + posRest;
  }
 }
}
// Converts a string to lower-case.
function String Locs(String in) {
 local String out;
 local int i;
 local int c;
 out = "";
 for (i=0;i<Len(in);i++) {
  c = Asc(Mid(in,i,1));
  if (c>=65 && c<=90) {
   c = c + 32;
  }
  out = out $ Chr(c);
 }
 return out;
}
// Will get all numbers from string.
// If breakAtFirst is set, will get first number, and place the remainder of the string in rest.
// Will accept all '.'s only leading '-'s
function String StrFilterNum(String in, optional bool breakAtFirst, optional out String rest) {
 local String out;
 local int i;
 local int c;
 local bool onNum;
 out = "";
 onNum = false;
 for (i=0;i<Len(in);i++) {
  c = Asc(Mid(in,i,1));
  if ( (c>=Asc("0") && c<=Asc("9")) || c==Asc(".") || (c==Asc("-") && !onNum) ) {
   out = out $ Chr(c);
   onNum = true;
  } else {
   if (onNum && breakAtFirst) {
    // onNum = false;
    // out = out $ " ";
    rest = Mid(in,i);
    return out;
   }
  }
 }
 rest = "";
 return out;
}
// UT2k4 had Repl(in,search,replace).
function String StrReplace(String in, String search, String replace) {
 return StrReplaceAll(in,search,replace);
}
function String StrReplaceAll(String in, String search, String replace) {
 local String out;
 local int i;
 out = "";
 for (i=0;i<Len(in);i++) {
  if (Mid(in,i,Len(search)) == search) {
   in = Left(in,i) $ replace $ Mid(in,i+Len(search));
   i = i - Len(search) + Len(replace);
  } else {
   out = out $ Mid(in,i,1);
  }
 }
 return out;
}
function String StrPop(out String str, String delimiter) {
 local int i;
 local String result;
 i = InStr(str,delimiter);
 if (i>=0) {
  result = Left(str,i);
  str = Mid(str,i+Len(delimiter));
 } else {
  result = str;
  str = "";
 }
 return result;
}
// #include "../../JLib/findactor.uc.jpp"
