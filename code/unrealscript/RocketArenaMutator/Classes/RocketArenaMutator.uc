
/* WARNING! This file was auto-generated by jpp.  You probably want to be editing ./RocketArenaMutator.uc.jpp instead. */



class RocketArenaMutator expands Mutator config(RocketArenaMutator);

/* ============================================================================

=== RocketArenaMutator ===

A weak approximation of the Rocket Arena game mode physics, implemented as a
Mutator.  Only one file need be used on the server, and no downloads are
required.  There are no rounds, the actual gametype remains the same.  But self
boosting, and boost tweaking for all the damagetypes is set (actually more like
CTF warmup than RA).

Because it is a mutator, armor is lost on self-boosts and falls.  ARMOR_HACK
attempts to solve this, by recording and restoring armor, but it is not 100%
accurate.

=== TODOS ===

There may be some things we need to consider.  Have we got all the weaposn
right?  Does RA adjust anything we haven't thought of, such as splash radius,
affect on other players, times when InstigatedBy=None but we should save the
player from damage, scale of boost wrt damage might not be linear in the real
RA.  Most weapons will fire only one charge at a time.  Only rockets, grenades
and bio allow for a selected charge.

=== ARMOR_HACK BUGS ===

If you are wearing a shieldbelt or MetalSuit but by boosting or falling you
destroy it (or knock it down to normal armor), then it will be restored as
normal armor.

If one of your armors has a stronger charge, after boosting its charge may be
transferred to one of the *other* types of armour in your inventory.

Some damage types: 'Breathe' 'Burned' 'Corroded' 'DamTypeShieldImpact'
 'Decapitated' 'Drowned' 'Eradicated' 'Exploded' 'Fell' 'FlakDeath' 'GameInfo'
 'Gibbed' 'GrenadeDeath' 'Hacked' 'Mortared' 'None' 'RedeemerDeath'
 'RipperAltDeath' 'RocketDeath' 'Special' 'SpecialDamage' 'Suicided' 'Zapped'
 'burned' 'corroded' 'decapitated' 'destroyed' 'exploded' 'impact' 'jolted'
 'sgSpecial' 'shot' 'shredded' 'zapped'

============================================================================ */



var config bool bPreventDamageFromSelf;
var config bool bPreventDamageFromFall;
var config float SelfBoostScale;
var config int FallLimit;


var int ArmorCharge[64];
var int bRestoreArmor[64];


defaultproperties {
  bPreventDamageFromSelf=True
  bPreventDamageFromFall=True
  SelfBoostScale=1.4
  FallLimit=500
  // TODO: FlagCarrierBoostHandling: 0=self-boost allowed, 1=allowed_but_takes_damage lol, 2=normal_boost_and_damage_for_FC
}

function PostBeginPlay() {
 Super.PostBeginPlay();
 Level.Game.RegisterDamageMutator( Self );

 Enable('Tick');

}

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {

 // Deal with self-boosting (damage and boost amount).
 if (InstigatedBy == Victim) {

  if (bPreventDamageFromSelf) {
   ActualDamage = 0;
  }

  // This is the right amount to scale 2 rockets:
  Momentum *= SelfBoostScale;

  // But the other weapons need to be adjusted to give appropriate RA boost.
  if (DamageType == 'jolted') {
   Momentum *= 1.9;
  }
  if (DamageType == 'Mortared') {
   Momentum *= 1.8;
  }
  if (DamageType == 'FlakDeath') {
   Momentum *= 1.8;
  }
  if (DamageType == 'shredded') {
   Momentum *= 1.7;
  }
  if (DamageType == 'decapitated') {
   Momentum *= 1.6;
  }
  if (DamageType == 'Corroded') {
   Momentum *= 1.5;
  }


  RestoreArmor(Victim);


 }

 // Deal with falling.
 if (bPreventDamageFromFall && DamageType=='Fell') {
  // If you got hurt more than FallLimit, then you don't get fall
  // protection!  Why?  Well some maps you can fall off the edge, and the
  // author expects you to die from it.  If we don't kill the player, then
  // he will just sit alone at the bottom of the chasm!
  if (ActualDamage < FallLimit) {
   ActualDamage = 0;

   RestoreArmor(Victim);

  }
 }

 Super.MutatorTakeDamage( ActualDamage, Victim, InstigatedBy, HitLocation, Momentum, DamageType );
}



event Tick(float DeltaTime) {
 local Pawn p;
 local int pid;
 local Inventory inv;
 foreach AllActors(class'Pawn',p) {
  if (p.PlayerReplicationInfo != None) {
   pid = p.PlayerReplicationInfo.PlayerID % 64;
   inv = FindArmor(p);
   if (inv == None) {
    ArmorCharge[pid] = 0;
   } else {
    ArmorCharge[pid] = inv.Charge;
   }
  }
 }
}

function Inventory FindArmor(Pawn p) {
 local Inventory Inv;
 local Inventory Found;
 local int Count;

 for( Inv=p.Inventory; Inv!=None; Inv=Inv.Inventory )
 {
  if (Armor(Inv)!=None || ThighPads(Inv)!=None || Armor2(Inv)!=None || ShieldBelt(Inv)!=None || UT_ShieldBelt(Inv)!=None) {
   if (Found == None || Inv.Charge > Found.Charge)
    Found = Inv;
  }
  Count++;
  if ( Count > 1000 )
   break;
 }
 return Found;
}

function RestoreArmor(Pawn p) {
 local int pid;
 local Inventory inv;
 if (p.PlayerReplicationInfo != None && ArmorCharge[pid]>0) {
  // Log("Restoring Armor for "$p.getHumanName());
  pid = p.PlayerReplicationInfo.PlayerID % 64;
  inv = FindArmor(p);
  if (inv == None) {
   inv = Spawn(class'Armor2',p);
   inv.GiveTo(p);
   // inv.Activate();
   // Pickup(inv).PickupFunction();
  }
  if (inv != None) {
   // Log("Restoring Armor "$ArmorCharge[pid]$" into "$inv);
   inv.Charge = ArmorCharge[pid];
  }
 }
}
