class RocketArenaMutator expands Mutator config(RocketArenaMutator);

/* ============================================================================

A weak approximation of the Rocket Arena game mode physics, implemented as a
Mutator.  Only one file need be used on the server, and no downloads are
required.  There are no rounds, the actual gametype remains the same.  But self
boosting, and boost tweaking for all the damagetypes is set (actually more like
CTF warmup than RA).  Because it is a mutator, armor is lost on self-boosts and
falls.

TODOS:

There may be some things we need to consider.  Have we got all the weaposn
right?  Does RA adjust anything we haven't thought of, such as splash radius,
affect on other players, times when InstigatedBy=None but we should save the
player from damage, scale of boost wrt damage might not be linear in the real
RA.  Most weapons will fire only one charge at a time.  Only rockets allows for
a selected charge.

Some damage types: 'Breathe' 'Burned' 'Corroded' 'DamTypeShieldImpact'
 'Decapitated' 'Drowned' 'Eradicated' 'Exploded' 'Fell' 'FlakDeath' 'GameInfo'
 'Gibbed' 'GrenadeDeath' 'Hacked' 'Mortared' 'None' 'RedeemerDeath'
 'RipperAltDeath' 'RocketDeath' 'Special' 'SpecialDamage' 'Suicided' 'Zapped'
 'burned' 'corroded' 'decapitated' 'destroyed' 'exploded' 'impact' 'jolted'
 'sgSpecial' 'shot' 'shredded' 'zapped'

============================================================================ */

#define ARMOUR_HACK

var config bool bPreventDamageFromSelf;
var config bool bPreventDamageFromFall;
var config float SelfBoostScale;
var config int FallLimit;

#ifdef ARMOUR_HACK
var int ArmorCharge[64];
var int bRestoreArmor[64];
#endif

defaultproperties {
  bPreventDamageFromSelf=True
  bPreventDamageFromFall=True
  SelfBoostScale=1.4
  FallLimit=500
  // TODO: FlagCarrierBoostHandling: 0=self-boost allowed, 1=allowed_but_takes_damage lol, 2=normal_boost_and_damage_for_FC
}

function PostBeginPlay() {
	Super.PostBeginPlay();
	Level.Game.RegisterDamageMutator( Self );
	#ifdef ARMOUR_HACK
	Enable('Tick');
	#endif
}

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {

	// Deal with self-boosting (damage and boost amount).
	if (InstigatedBy == Victim) {

		if (bPreventDamageFromSelf) {
			ActualDamage = 0;
		}

		// This is the right amount to scale 2 rockets:
		Momentum *= SelfBoostScale;

		// But the other weapons need to be adjusted to give appropriate RA boost.
		if (DamageType == 'jolted') {
			Momentum *= 1.9;
		}
		if (DamageType == 'Mortared') {
			Momentum *= 1.8;
		}
		if (DamageType == 'FlakDeath') {
			Momentum *= 1.8;
		}
		if (DamageType == 'shredded') {
			Momentum *= 1.7;
		}
		if (DamageType == 'decapitated') {
			Momentum *= 1.6;
		}
		if (DamageType == 'Corroded') {
			Momentum *= 1.5;
		}

		RestoreArmour(Victim);

	}

	// Deal with falling.
	if (bPreventDamageFromFall && DamageType=='Fell') {
		// If you got hurt more than FallLimit, then you don't get fall
		// protection!  Why?  Well some maps you can fall off the edge, and the
		// author expects you to die from it.  If we don't kill the player, then
		// he will just sit alone at the bottom of the chasm!
		if (ActualDamage < FallLimit) {
			ActualDamage = 0;
			RestoreArmour(Victim);
		}
	}

	Super.MutatorTakeDamage( ActualDamage, Victim, InstigatedBy, HitLocation, Momentum, DamageType );
}

#ifdef ARMOUR_HACK
event Tick(float DeltaTime) {
	local Pawn p;
	local int pid;
	local Inventory inv;
	foreach AllActors(class'Pawn',p) {
		if (p.PlayerReplicationInfo != None) {
			pid = p.PlayerReplicationInfo.PlayerID % 64;
			inv = FindInventorySubclass(p,'Armor');
			if (inv != None) {
				ArmorCharge[pid] = inv.Charge;
			}
		}
	}
}

function Inventory FindInventorySubclass(Pawn p, name DesiredClass) {
	local Inventory Inv;
	local int Count;

	for( Inv=p.Inventory; Inv!=None; Inv=Inv.Inventory )
	{
		if ( Inv.IsA(DesiredClass) )
			return Inv;
		Count++;
		if ( Count > 1000 )
			return None;
	}
	return None;
}
#endif

function RestoreArmour(Pawn p) {
	local int pid;
	local Inventory inv;
	#ifdef ARMOUR_HACK
	if (p.PlayerReplicationInfo != None) {
		pid = p.PlayerReplicationInfo.PlayerID % 64;
		inv = FindInventorySubclass(p,'Armor');
		inv.Charge = ArmorCharge[pid];
	}
	#endif
}

