class PostBox expands Mutator config(PostBox);

var config bool bAcceptSpokenCommands;
var config bool bAcceptMutateCommands;
var config bool bSwallowSpokenCommands;

var config String mailFrom[1024];
var config String mailTo[1024];
var config String mailDate[1024];
var config String mailMessage[1024];

defaultproperties {
  bAcceptSpokenCommands=True
  bAcceptMutateCommands=True
  bSwallowSpokenCommands=True
}

function PostBeginPlay() {
	// If we were not added as a mutator, but run in some other way (e.g. as a ServerActor), then we need to register as a mutator:
   // Level.Game.BaseMutator.AddMutator(Self);

	// Register to receive spoken messages in MutatorTeamMessage() below:
	if (bAcceptSpokenCommands) {
		Level.Game.RegisterMessageMutator(Self);
	}

}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	local bool hideMessage;
	hideMessage = False;
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		hideMessage = CheckMessage(Mid(Msg,InStr(Msg,":")+1), PlayerPawn(Sender));
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage || !bSwallowSpokenCommands);
}

function Mutate(String str, PlayerPawn Sender) {
	if (bAcceptMutateCommands) {
		CheckMessage(str, Sender);
	}
	Super.Mutate(str, Sender);
}

// Returns True if the command was recognised.
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local Actor A;
	local String result;
	local int i,j;
	local String squishedName;
	local String url;

	// Log("PostBox.uc.CheckMessage() ("$Sender$"): "$Msg$"");
	argcount = SplitString(line," ",args);
	// TODO: strip leading "!" if any

	if (StrStartsWith(args[0],"!")) {
		args[0] = Mid(args[0],1);
	}

	if (args[0] ~= "HELP") {
		Sender.ClientMessage("PostBox commands: HELP | MAIL/POST | MAIL/POST <recipient> <message>");
		Sender.ClientMessage("  Note: for delivery, only the letters and numbers in <recipient>'s nick need to match.");
		return True;
	}

	if (args[0] ~= "MAIL" || args[0] ~= "POST") {
		if (args[1] == "") {
			// Check for mail for Sender
			squishedName = squishString(Sender.GetHumanName());
			for (i=0; i<1024; i++) {
				j = -1;
				if (squishString(mailTo[i])==squishedName) {
					j = i;
					Sender.ClientMessage("You have new mail:");
					Sender.ClientMessage(mailFrom[i] $ " -> " $ mailTo[i] $ " @ " $ mailDate[i] $ ": " $ mailMessage[i]);
					mailFrom[i] = "";
					mailTo[i] = "";
					mailDate[i] = "";
					mailMessage[i] = "";
					SaveConfig();
					break;
				}
			}
			if (j == -1) {
				Sender.ClientMessage("You have no new mail.");
			}
		} else {
			// Save message args[2..] for args[1] (from Sender)
			for (i=0; i<1024; i++) {
				if (mailFrom[i] == "" && mailTo[i] == "" && mailDate[i] == "" && mailMessage[i] == "") {
					mailFrom[i] = Sender.GetHumanName();
					mailTo[i] = args[1];
					mailDate[i] = GetDate();
						mailMessage[i] = "";
						for (j=2;j<argcount;j++) { mailMessage[i] = mailMessage[i] $ args[j] $ " "; }
						mailMessage[i] = Left(mailMessage[i], Len(mailMessage[i])-1);
					// Sender.ClientMessage("Message for " $ squishString(mailTo[i]) $ " stored at " $ mailDate[i] $ ".");
					Sender.ClientMessage("Message for " $ squishString(mailTo[i]) $ " has been saved.");
					SaveConfig();
					break;
				}
			}
		}
		return True;
	}

	return False;

}

// Removes all non-alphanumeric characters from a string
function String squishString(String str) {
	local String newStr;
	local int i,c;
	str = Caps(str);
	newStr = "";
	for (i=0; i<Len(str); i++) {
		c = Asc(Mid(str,i,1));
		if ( (c>=Asc("A") && c<=Asc("Z")) || (c>=Asc("0") && c<=Asc("9")) ) {
			newStr = newStr $ Chr(c);
		}
	}
	return newStr;
}



#include "/mnt/big/ut/ut_win/JLib/jlib.uc.jpp"

