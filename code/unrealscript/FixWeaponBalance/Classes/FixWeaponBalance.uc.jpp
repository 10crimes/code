class FixWeaponBalance expands Mutator config(FixWeaponBalance);

// vim: ft=uc
// DONE: bFixCrouchingBug for ZeroPingPlus103
// TODO: We may be able to process damage done before armour, by giving each
//       player a high-priority custom armour class.
// DONE: DO NOT adjust damage against general pawns (e.g. siege buildings),
//       only against players and bots.
// DONE: Alternative setup: keep ZP sniper strong, increase strength of all
//       other weapons to match.

// TODO: make sniper damage normal at close/medium range, less at long range

#define ADJUST_SNIPER_DAMAGE

// Debugging:

// #define DebugLog(X); if (bLogging) { Log("[FixWeaponDamage] "$(X)); } if (bLiveReports) { BroadcastMessage("[FWD] "$(X)); }
#define DebugLog(X) if (bLogging) { Log("[FixWeaponDamage] "$(X)); }
// #define DebugLog(X); 

var config bool bEnabled;
var config bool bLogging;
var config bool bLiveReports;

var config bool bKeepHeadshotsInAllModes;
var config float SniperDamageScale;
var config int SniperMaxDamage;
// We cannot apply SniperMinDamage globally in mutator mode.  Hitting an enemy with shield might/should idd inflict 0 health damage.  Currently it does provide a cap on SniperMaxRange's reduction.
var config int SniperMinDamage;
var config bool bFixCrouchingBug;   // For ZeroPingPlus103
var config float SniperPowerRange;
var config float SniperMaxRange;

var config float RocketDamageScale;
var config float RocketGrenadeDamageScale;
var config float BioDamageScale;
var config float EnforcerDamageScale;
var config float MinigunDamageScale;
var config float ShockPrimaryDamageScale;
var config float ShockBallDamageScale;
var config float FlakPrimaryDamageScale;
var config float FlakSecondaryDamageScale;
var config float PulseDamageScale;
var config float PulsebeamDamageScale;
var config float RipperDamageScale;
var config float RipperSecondaryDamageScale;
var config float RipperHeadshotDamageScale;
var config float MeleeWeaponDamageScale;

var config bool bAdjustBoost;


function PostBeginPlay() {
	Level.Game.RegisterDamageMutator(Self);
	Level.Game.RegisterMessageMutator(Self);
	SaveConfig(); // Just easier for admin to create file / missing vars
}

function ModifyPlayer(Pawn Other) {
	Super.ModifyPlayer(Other);
	if (bEnabled) {
		if (PlayerPawn(Other)!=None && PlayerPawn(Other).PlayerReplicationInfo.Deaths==0) {
			Other.ClientMessage("FixWeaponBalance is running.  See mutate status for details.");
		}
	}
}

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {

	local bool bSniperShot,bHeadshot; // bSniperShot also counts of Enforcer.
	local bool bHardcore,isShockPrimary,isEnforcer;
	local int NewDamage;
	local float distance;

	if (bEnabled && PlayerPawn(InstigatedBy)!=None) {

		bHardcore = DeathMatchPlus(Level.Game).bHardcoreMode;

		bHeadshot = (DamageType=='decapitated');

		bSniperShot = False;
		// Is this a sniper or enforcer hit?
		// BUG: This could identify a ripper headshot as a sniper shot, if the player changed to sniper before it hit!
		// I fear there is no solution to that in mutator.
		if (DamageType == 'shot' || DamageType == 'decapitated') {
			if (InstigatedBy!=None && SniperRifle(InstigatedBy.Weapon) != None) {
				bSniperShot = True;
			}
		}

		NewDamage = ActualDamage;

		if (bSniperShot) {

			if (bFixCrouchingBug && Victim!=None && Victim.IsA('PlayerPawn') && PlayerPawn(Victim).bIsCrouching) {
				// Headshots are not possible on crouched players, so we reduce the damage to a body hit.
				if (bHardcore) {
					if (ActualDamage > 67) {
						ActualDamage = 67;
					}
				} else {
					if (ActualDamage > 58) {
						ActualDamage = 58;
					}
				}
			}

			// Always scale damage for sniper rifle?
			NewDamage = ActualDamage * SniperDamageScale;

			if (SniperMaxRange > 0) {
				distance = VSize(Victim.Location - InstigatedBy.Location);
				if (distance < SniperPowerRange) {
					// Do nothing: leave strength unaffected
				} else {
					if (distance > SniperMaxRange) {
						NewDamage = SniperMinDamage;
					} else {
						// Scale from 1.0 at SniperPowerRange to 0.0 at SniperMaxRange.
						NewDamage = NewDamage * (1.0 - (distance - SniperPowerRange)/(SniperMaxRange - SniperPowerRange)) + 0.5;
						// +0.5 rounds float result to nearest int (NewDamage must be int!)
						if (NewDamage < SniperMinDamage) {
							NewDamage = SniperMinDamage;
						}
					}
					// SniperMinDamage may have been set even though ActualDamage was 0 (all absorbed by belt)!
					if (ActualDamage == 0) {
						NewDamage = 0;
					}
				}
			}

			// In non-hardcore mode, we may not want to scale headshots down, because they are only 100 to start with!
			if (bKeepHeadshotsInAllModes && ActualDamage>=100 && NewDamage<100) {
				NewDamage = 100;
			}

			if (NewDamage > SniperMaxDamage) {
				NewDamage = SniperMaxDamage;
			}

		// WARNING: Some of the damage dealt may have already been partially absorbed by armour, making the == comparisons we make later inaccurate - they may fail to scale up/down damage on a weapon they should have.  In case of inaccuracies, they will fall to the final else case, so at least the damage scale there will be applied.
		// If all their armour is gone, and they have only 12 health left, I believe 60 damage still reaches us as 60 (not reduced to 12).  If not for that, scaling damage down would make it impossible to kill people!
		} else if (DamageType == 'RocketDeath') {
			NewDamage *= RocketDamageScale;
		} else if (DamageType == 'GrenadeDeath') {
			NewDamage *= RocketGrenadeDamageScale;
		} else if (DamageType == 'Corroded') {
			NewDamage *= BioDamageScale;
		} else if (DamageType == 'shot') {
			// isEnforcer = (bHardcore && NewDamage==25 || !bHardcore && NewDamage==10);
			isEnforcer = Enforcer(InstigatedBy.Weapon)!=None;
			if (isEnforcer) {
				NewDamage *= EnforcerDamageScale;
			} else {
				// Presumably now Minigun2(InstigatedBy.Weapon)!=None
				// Or coule be sniper (if somehow we failed to recognise sniper above)
				NewDamage *= MinigunDamageScale;
			}
		} else if (DamageType == 'jolted') {
			// Bugs:
			// Armor absorpotion will fail to recognise primary, applying ShockBallDamageScale!
			// (More rarely, combos which caused ==60 after absorption will be marked primaries!)
			// Solution: Keep ShockPrimaryDamageScale and ShockBallDamageScale the same, or experience weirdness you did not want!
			//isShockPrimary = (bHardcore && NewDamage==60 || !bHardcore && NewDamage==40);
			// Compensation: Never misclassify true primary, often misclassify weak combo as primary.
			isShockPrimary = (bHardcore && NewDamage<=60 || !bHardcore && NewDamage<=40);
			if (isShockPrimary) {
				NewDamage *= ShockPrimaryDamageScale;
			} else {
				// The damage caused by a shock ball can vary (centrality?), so it counts with a shock combo.
				NewDamage *= ShockBallDamageScale;
			}
		} else if (DamageType == 'FlakDeath') {
			NewDamage *= FlakPrimaryDamageScale;
		} else if (DamageType == 'Mortared') {
			NewDamage *= FlakSecondaryDamageScale;
		} else if (DamageType == 'Pulsed') {
			NewDamage *= PulseDamageScale;
		} else if (DamageType == 'zapped') {
			NewDamage *= PulsebeamDamageScale;
		} else if (DamageType == 'shredded') {
			NewDamage *= RipperDamageScale;
		} else if (DamageType == 'RipperAltDeath') {
			NewDamage *= RipperSecondaryDamageScale;
		} else if (DamageType == 'decapitated') {
			NewDamage *= RipperHeadshotDamageScale;
		} else if (DamageType == 'Impact') { // hammer
			NewDamage *= MeleeWeaponDamageScale;
		} else if (DamageType == 'slashed') { // chainsaw
			NewDamage *= MeleeWeaponDamageScale;
		} else if (DamageType == 'RedeemerDeath') {
			// Do nothing
		} else {
			if (bLiveReports) {
				InstigatedBy.ClientMessage("Did not recognise DamageType="$DamageType);
			}
		}

		if (bAdjustBoost && NewDamage != ActualDamage && ActualDamage!=0) {
			Momentum = Momentum * (NewDamage/ActualDamage);
		}

		if (NewDamage != ActualDamage) {
			DebugLog("Adjusting "$DamageType$": "$ActualDamage$" -> "$NewDamage$" ( "$GHN(InstigatedBy)$" -> "$GHN(Victim)$" )");
			if (bLiveReports) {
				InstigatedBy.ClientMessage("Inflicted "$DamageType$": "$ActualDamage$" -> "$NewDamage);
				if (PlayerPawn(Victim) != None) {
					Victim.ClientMessage("Received "$DamageType$": "$ActualDamage$" -> "$NewDamage);
				}
			}
		}

		ActualDamage = NewDamage;

		// if (ActualDamage == 0) {
			// DamageType = ''; //// Does not pr_vent blood spurts from appearing
		// }

	}

	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
}

function String GHN(Actor a) {
	if (Pawn(a) != None) {
		return Pawn(a).getHumanName();
	} else {
		return String(a);
	}
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrStartsWith(Msg,"!")) {
			CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, coerce string Msg, optional bool bBeep, optional name Type) {
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrContains(Msg,":!")) {
			// Spectator messages start with the extra "<nick>:".  We remove this.
			CheckMessage(Mid(Msg,InStr(Msg,":!")+1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type);
}

function Mutate(String str, PlayerPawn Sender) {
	CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local String command;
	local String tmpstr;

	// DebugLog("FixWeaponBalance.CheckMessage() ("$Sender$"): "$Msg$"");
	argCount = SplitString(line," ",args);

	command = args[0];

	if (command ~= "STATUS") {
		SendStatusTo(Sender);
		return True;
	}

	if (!Sender.bAdmin) {
		return False;
	}
	// The following commands are for ADMINS ONLY

	if (command ~= "HELP") {
		Sender.ClientMessage("FixWeaponBalance.bEnabled = "$bEnabled);
		Sender.ClientMessage("FixWeaponBalance commands: fwb | report | status");
		return True;
	}

	// Admin can easily turn this on for testing, but it won't be saved for next map
	if (command ~= "REPORT" || command ~= "FWBREPORT") {
		bLiveReports = !bLiveReports;
		if (bLiveReports)
			BroadcastMessage(Sender.getHumanName()$" has ENABLED FixWeaponBalance reporting with \"mutate report\".");
		if (!bLiveReports)
			BroadcastMessage(Sender.getHumanName()$" has DISABLED FixWeaponBalance reporting with \"mutate report\".");
	}

	if (command ~= "FWB") {
		bEnabled = !bEnabled;
		if (bEnabled)
			tmpstr = "ENABLED";
		else
			tmpstr = "DISABLED";
		if (bLiveReports)
			BroadcastMessage(Sender.getHumanName()$" has "$tmpstr$" FixWeaponBalance.");
		else
			Sender.ClientMessage("You have "$tmpstr$" FixWeaponBalance.");
		return True;
	}

	return False;

}

//// Normally we send the info to the caller:
// #define Send Sender.ClientMessage
//// But sometimes I want the output logged to the logfile, so I can post-process it:
// #define Send DebugLog
// #define Send(X); Sender.ClientMessage(X); Log(X);
#define Send(X); if (Sender==None) { Log(X); } else { Sender.ClientMessage(X); }
function SendStatusTo(Pawn Sender) {
	Send("FixWeaponBalance settings:");
	Send("  Enabled = "$bEnabled);
	Send("  Logging = "$bLogging);
	Send("  Reporting = "$bLiveReports);
	Send("  SniperDamageScale = "$PercentageChangeStr(SniperDamageScale));
	// Send("  SniperBoostScale = "$PercentageChangeStr(SniperBoostScale));
	Send("  SniperMaxDamage = "$SniperMaxDamage);
	Send("  RocketDamageScale = "$PercentageChangeStr(RocketDamageScale));
	Send("  RocketGrenadeDamageScale = "$PercentageChangeStr(RocketGrenadeDamageScale));
	Send("  BioDamageScale = "$PercentageChangeStr(BioDamageScale));
	Send("  EnforcerDamageScale = "$PercentageChangeStr(EnforcerDamageScale));
	Send("  MinigunDamageScale = "$PercentageChangeStr(MinigunDamageScale));
	Send("  ShockPrimaryDamageScale = "$PercentageChangeStr(ShockPrimaryDamageScale));
	Send("  ShockBallDamageScale = "$PercentageChangeStr(ShockBallDamageScale));
	Send("  FlakPrimaryDamageScale = "$PercentageChangeStr(FlakPrimaryDamageScale));
	Send("  FlakSecondaryDamageScale = "$PercentageChangeStr(FlakSecondaryDamageScale));
	Send("  PulseDamageScale = "$PercentageChangeStr(PulseDamageScale));
	Send("  PulsebeamDamageScale = "$PercentageChangeStr(PulsebeamDamageScale));
	Send("  RipperDamageScale = "$PercentageChangeStr(RipperDamageScale));
	Send("  RipperSecondaryDamageScale = "$PercentageChangeStr(RipperSecondaryDamageScale));
	Send("  RipperHeadshotDamageScale = "$PercentageChangeStr(RipperHeadshotDamageScale));
	Send("  MeleeWeaponDamageScale = "$PercentageChangeStr(MeleeWeaponDamageScale));
	Send("  bAdjustBoost = "$bAdjustBoost);
	Send("So hardcore headshot 150 now gives "$ Int(150*SniperDamageScale) $" and bodyhit 67 gives "$ Int(67*SniperDamageScale) $".");
}

function String PercentageChangeStr(float proportion) {
	if (proportion == 1.0) {
		return "normal";
	}
	if (proportion < 1.0) {
		return Int(100*(1.0-proportion)+0.5)$"% smaller";
	}
	if (proportion > 1.0) {
		return Int(100*(proportion-1.0)+0.5)$"% larger";
	}
}

#include "../../JLib/jlib.uc.jpp"

defaultproperties {
	bEnabled=True
	bLogging=False
	bLiveReports=False
	bKeepHeadshotsInAllModes=True
	// SniperDamageScale=0.78
	// SniperMaxDamage=102
	SniperDamageScale=1.0
	SniperMaxDamage=150
	SniperMinDamage=12
	bFixCrouchingBug=True
	SniperPowerRange=384
	SniperMaxRange=6144

	RocketDamageScale=1.00
	RocketGrenadeDamageScale=1.00
	BioDamageScale=1.00
	EnforcerDamageScale=1.00
	MinigunDamageScale=1.00
	ShockPrimaryDamageScale=1.00
	ShockBallDamageScale=1.00
	FlakPrimaryDamageScale=1.00
	FlakSecondaryDamageScale=1.00
	PulseDamageScale=1.00
	PulsebeamDamageScale=1.00
	RipperDamageScale=1.00
	RipperSecondaryDamageScale=1.00
	RipperHeadshotDamageScale=1.00
	MeleeWeaponDamageScale=1.00

	bAdjustBoost=True

}

// Note that this does not affect damage to armour, only damage to health.
// Usually a headshot does 150 damage, and a body shot does 67.

// We might want a headshot to do 102, and a bodyshot 52.  (scale 0.78)
// This is the minimum that will look normal on a guy with 100 hp and 0 armour.

// (Alternatively, for bodyshot 55, use scale 0.825.)

// In non-hardcore mode (which Siege requires for jetpack), headshots usually
// cost 100 and bodyshots 58.

