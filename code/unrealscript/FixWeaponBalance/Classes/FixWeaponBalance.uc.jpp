class FixWeaponBalance expands Mutator config(FixWeaponBalance);

// vim: ft=uc cindent
// DONE: bFixCrouchingBug for ZeroPingPlus103
// TODO: We may be able to process damage done before armour, by giving each
//       player a high-priority custom armour class.
// DONE: DO NOT adjust damage against general pawns (e.g. siege buildings),
//       only against players and bots.
// DONE: Alternative setup: keep ZP sniper strong, increase strength of all
//       other weapons to match.

// DONE: make sniper damage normal at close/medium range, less at long range

// TODO: Having got this far, at least make headshot vs body shot configurable.
//       I suppose we could have two different scales.

// TODO: Try to become first mutator if not already.  (To avoid other mutators seeing some damage twice, or bad momentum values.)

// TODO: Boost should work equally on team-mates (no damage) as it would against an enemy (with damage).

// Debugging:

// #define DEBUG(X); if (bLogging) { Log("[FixWeaponDamage] "$(X)); } if (bLiveReports) { BroadcastMessage("[FWD] "$(X)); }
#define DEBUG(X) if (bLogging) { Log("[FixWeaponDamage] "$(X)); }
#define REPORT(W,X) if (bLogging || bLiveReports) { Report(W,X); }
// #define DEBUG(X); 

var config bool bEnabled;
var config bool bLogging;
var config bool bAdvertise;
var bool bLiveReports;
var config bool bReportAllDamage;

var config bool bKeepHeadshotsInAllModes;
var config float SniperDamageScale;
var config int SniperMaxDamage;
var config bool bScaleSniperByDistance;
var config float SniperPowerRange;
var config float SniperMidRange;    // TODO: This should define where power is one-quarter.  The shape should correspond somewhat to the danger from other weapons across that range.
var config float SniperMaxRange;
var config int SniperMinDamage;
var config bool bFixCrouchingBug;   // For ZeroPingPlus103

var config float RocketDamageScale;
var config float RocketGrenadeDamageScale;
var config float BioDamageScale;
var config float EnforcerDamageScale;
var config float MinigunDamageScale;
var config float ShockPrimaryDamageScale;
var config float ShockBallDamageScale;
var config float FlakPrimaryDamageScale;
var config float FlakSecondaryDamageScale;
var config float PulseDamageScale;
var config float PulsebeamDamageScale;
var config float RipperDamageScale;
var config float RipperSecondaryDamageScale;
var config float RipperHeadshotDamageScale;
var config float MeleeWeaponDamageScale;

var config bool bAdjustBoost;
var config bool bOnlyAdjustBoostDownwards;


var int Stage;
// Stored by first call to FWBArmor.ArmorAbsorbDamage()
var int InDamage;
var name InDamageType;
var Vector InHitLocation;
// Stored by first call to MutatorTakeDamage()
var Pawn LastInstigator;
var Vector LastMomentum;
var Vector NewMomentum;
var int NewDamage;


function PostBeginPlay() {
	Level.Game.RegisterDamageMutator(Self);
	Level.Game.RegisterMessageMutator(Self);
	SaveConfig(); // Just easier for admin to create file / missing vars
}

function ModifyPlayer(Pawn Other) {
	Super.ModifyPlayer(Other);
	if (bEnabled) {
		GiveMagicArmorToPlayer(Other);
	}
}

// Unfortunately some versions of siege (XXL2e, XTreme02) forget to call ModifyPlayer, so they player does not get their armour on spawn.
// We check harder here, to ensure they get it.
function bool AlwaysKeep(Actor Other) {
	local Pawn p;
	if (Other.IsA('Enforcer')) {
		Log("Someone is being given an enforcer.  Dunno who.");
		for (p=Level.PawnList; p!=None; p=p.NextPawn) {
			if ((p.bIsPlayer && !p.IsA('Spectator')) || p.IsA('Bot')) {
				GiveMagicArmorToPlayer(p);
				if (PlayerPawn(Other)!=None && PlayerPawn(Other).PlayerReplicationInfo.Deaths==0) {
					if (bScaleSniperByDistance) {
						PlayerPawn(Other).ClientMessage("The sniper rifle is now a close-range weapon.  See !status for details.");
					} else {
						PlayerPawn(Other).ClientMessage("FixWeaponBalance is running.  See !status for details.");
					}
				}
			}
		}
	}
	if ( NextMutator != None )
		return ( NextMutator.AlwaysKeep(Other) );
	return false;
}

// Implementation of AddMutator which prevents double or recursive adding:
function AddMutator(Mutator Other) {
	if (Other != None && Other.Class == Self.Class) {
		if (Other == Self) {
			DEBUG(Self$".AddMutator("$Other$") No need to add mutator self again.");
		} else {
			DEBUG(Self$".AddMutator("$Other$") Destroying other instance.");
			Other.Destroy(); // seems to do nothing useful; the mutator continues to run through PostBeginPlay().
		}
	} else {
		Super.AddMutator(Other);
	}
}

function GiveMagicArmorToPlayer(Pawn Other) {
	local Inventory inv;
	local FWBArmor arm;
	inv = Other.FindInventoryType(class'FWBArmor');
	if (inv == None) {
		arm = Spawn(class'FWBArmor',Other,,Other.Location);
		if (arm != None) {
			arm.Mut = Self;
			arm.GiveTo(Other);
		}
	}
}

// Unfortunately Inventory.ArmorAbsorbDamage() is not given the Instigator, which is rather inconvenient if we want to scale a weapon's strength according to the distance between the two players!
// The solution was somewhat convoluted and dirty.
//   - Override ArmorAbsorbDamage in the first armor inventory item (ensured by AbsorptionPriority=-999).
//   - Have that DO NOTHING, except leave a TODO for the mutator.  (I.e. it absorbs all damage on that first call, and waits for second call from the mutator, once MutatorTakeDamage is reached.)
//   - Wait for MutatorTakeDamage to be called on the mutator.  Now we have the InstigatedBy!
//   - Now we must do whatever we didn't do before, by calling Victim.TakeDamage *a second time*.
//   - Except this time, we allow things to pass through as "normal", applying our changes as intended.

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {

	if (bEnabled /*&& PlayerPawn(InstigatedBy)!=None*/) {

		if (Stage == 1) {
			Stage = 2;
			LastInstigator = InstigatedBy;
			LastMomentum = Momentum;
			Victim.TakeDamage(InDamage,InstigatedBy,HitLocation,Momentum,DamageType);
			Momentum = vect(0,0,0); // We have just added the desired momentum, so return momentum 0 so we don't add it again!
			return; // No point walking the chain now - we have just done it!
		} else if (Stage == 3) {
			Stage = 0;
			//// OK it's all over.  We just need to 
			//// The current value for Momentum might be bogus.
			//// Anyway, we return the one stored for us by ModifyDamage().
			Momentum = NewMomentum;
			// Instead of NewMomentum vector we could have passed around ScaleMomentum.
			// if (VSize(LastMomentum - Momentum)>0.000001) {
			// 	REPORT(InstigatedBy,"Momentum got lost Last="$ VSize(LastMomentum) $" Bogus="$ VSize(Momentum));
			// }
			/* Seems to  be working fine; check/log disabled
			if (VSize(LastMomentum - NewMomentum)>0.000001) {
				#define momChange Int(VSize(LastMomentum)) $" to "$ Int(VSize(NewMomentum))
				REPORT(InstigatedBy,"Adjusted momentum "$ momChange);
				// This confirmed the right numbers were getting through:
				// " InDamage="$InDamage$" NewDamage="$NewDamage);
			}
			*/
		} else {
			Log("BUG! Stage="$ Stage $" in FixWeaponBalance.MutatorTakeDamage()!");
		}

	}

	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
}

// Stores outputs NewDamage and NewMomentum.
function int ModifyDamage(int ActualDamage, Pawn Victim, Pawn InstigatedBy, Vector HitLocation, Vector Momentum, name DamageType) {

	local bool bSniperShot,bHeadshot; // bSniperShot also counts of Enforcer.
	local bool bHardcore,isShockPrimary,isEnforcer;
	local bool bDidCrouchReduction;
	local float distance;
	local String ReportStr;

	bHardcore = DeathMatchPlus(Level.Game).bHardcoreMode;

	bHeadshot = (DamageType=='decapitated');

	bSniperShot = False;
	// Is this a sniper hit?
	// Note that mini and enforcer also produce DamageType 'shot' and ripper also gives 'decapitated'.
	// BUG: Checking instigator's weapon could identify a ripper headshot ('decapitated') or mini or enforcer ('shot') as a sniper shot, if the player changed to sniper before it hit!
	/*
	if (DamageType == 'shot' || DamageType == 'decapitated') {
		if (InstigatedBy!=None && SniperRifle(InstigatedBy.Weapon) != None) {
			bSniperShot = True;
		}
	}
	*/
	// Alternative: Detect from damage values.
	if (DamageType == 'decapitated') {
		if (bHardcore) {
			if (ActualDamage == 150) {
				bSniperShot = True; // detected a headshot
			}
		} else {
			if (ActualDamage == 100) {
				bSniperShot = True; // detected a headshot
			}
		}
	} else if (DamageType == 'shot') {
		if (bHardcore) {
			if (ActualDamage == 67) {
				bSniperShot = True; // detected a body hit
			}
		} else {
			// I saw 45 for a bodyhit in siege.  Where does 58 come from?
			if (ActualDamage == 58 || ActualDamage == 45) {
				bSniperShot = True; // detected a body hit
			}
		}
	}

	if (DamageType != InDamageType) {
		REPORT(InstigatedBy,"DamageType changed from "$InDamageType$" to "$DamageType);
	}
	//// Fine if we are scaling any weapons up.
	// if (ActualDamage >= InDamage) {
		// REPORT(InstigatedBy,"ActualDamage > InDamage! "$ InDamage $" < "$ ActualDamage);
	// }

	NewDamage = ActualDamage;

	if (bSniperShot) {

		if (bFixCrouchingBug && Victim!=None && Victim.IsA('PlayerPawn') && PlayerPawn(Victim).bIsCrouching) {
			// Headshots are not possible on crouched players, so we reduce the damage to a body hit.
			if (bHardcore) {
				if (ActualDamage > 67) {
					ActualDamage = 67;
					bDidCrouchReduction = True;
				}
			} else {
				if (ActualDamage > 58) {
					ActualDamage = 58;
					bDidCrouchReduction = True;
				}
			}
			// TODO: If we can find accurate values in zeroping, we could compare HitLocation.Z against Victim.Location.Z, to see if the shot went over their head!
		}

		// Always scale damage for sniper rifle?
		NewDamage = ActualDamage * SniperDamageScale;

		if (bScaleSniperByDistance && InstigatedBy!=None) {
			/*
			distance = VSize(Victim.Location - InstigatedBy.Location);
			scale = (0.5) ^ (distance / SniperHalflifeDistance);
			*/
			if (distance < SniperPowerRange) {
				// Do nothing: leave strength unaffected
			} else if (distance > SniperMaxRange) {
				NewDamage = SniperMinDamage;
			} else {
				if (distance < SniperMidRange) {
					// Scale from 1.0 at SniperPowerRange to 0.25 at SniperMidRange.
					#define thruMid ((distance - SniperPowerRange)/(SniperMidRange - SniperPowerRange))
					NewDamage = float(NewDamage) * (1.0 - thruMid) + float(NewDamage) * thruMid / 4.0 + 0.5;
					// +0.5 rounds float result to nearest int (NewDamage must be int!)
				} else {
					// Scale from 0.25 at SniperMidRange to 0.0 at SniperMaxRange.
					#define thruMax ((distance - SniperMidRange)/(SniperMaxRange - SniperMidRange))
					NewDamage = float(NewDamage) * (1.0 - thruMax) / 4.0 + float(SniperMinDamage) * thruMax + 0.5;
					// +0.5 rounds float result to nearest int (NewDamage must be int!)
				}
				if (NewDamage < SniperMinDamage) {
					NewDamage = SniperMinDamage;
				}
				// SniperMinDamage may have been set even though ActualDamage was 0 (all absorbed by belt)!
				if (ActualDamage == 0) {
					NewDamage = 0;
				}
			}
		}

		// In non-hardcore mode, we may not want to scale headshots down, because they are only 100 to start with!
		if (bKeepHeadshotsInAllModes && ActualDamage>=100 && NewDamage<100) {
			NewDamage = 100;
		}

		if (NewDamage > SniperMaxDamage) {
			NewDamage = SniperMaxDamage;
		}

	// WARNING: Some of the damage dealt may have already been partially absorbed by armour, making the == comparisons we make later inaccurate - they may fail to scale up/down damage on a weapon they should have.  In case of inaccuracies, they will fall to the final else case, so at least the damage scale there will be applied.
	// If all their armour is gone, and they have only 12 health left, I believe 60 damage still reaches us as 60 (not reduced to 12).  If not for that, scaling damage down would make it impossible to kill people!
	} else if (DamageType == 'RocketDeath') {
		NewDamage *= RocketDamageScale;
	} else if (DamageType == 'GrenadeDeath') {
		NewDamage *= RocketGrenadeDamageScale;
	} else if (DamageType == 'Corroded') {
		NewDamage *= BioDamageScale;
	} else if (DamageType == 'shot') {
		// isEnforcer = (bHardcore && ActualDamage==25 || !bHardcore && ActualDamage==10);
		isEnforcer = InstigatedBy!=None && Enforcer(InstigatedBy.Weapon)!=None;
		if (isEnforcer) {
			NewDamage *= EnforcerDamageScale;
		} else {
			// Presumably now Minigun2(InstigatedBy.Weapon)!=None
			// Or coule be sniper (if somehow we failed to recognise sniper above)
			NewDamage *= MinigunDamageScale;
		}
	} else if (DamageType == 'jolted') {
		// Quite unlikely, but this check might flag a combo of just the right strength as a primary.
		isShockPrimary = (bHardcore && ActualDamage==60) || (!bHardcore && ActualDamage==40);
		if (isShockPrimary) {
			NewDamage *= ShockPrimaryDamageScale;
		} else {
			// The damage caused by a shock ball can vary (centrality?), so it counts with a shock combo.
			NewDamage *= ShockBallDamageScale;
		}
	} else if (DamageType == 'FlakDeath') {
		NewDamage *= FlakPrimaryDamageScale;
	} else if (DamageType == 'Mortared') {
		NewDamage *= FlakSecondaryDamageScale;
	} else if (DamageType == 'Pulsed') {
		NewDamage *= PulseDamageScale;
	} else if (DamageType == 'zapped') {
		NewDamage *= PulsebeamDamageScale;
	} else if (DamageType == 'shredded') {
		NewDamage *= RipperDamageScale;
	} else if (DamageType == 'RipperAltDeath') {
		NewDamage *= RipperSecondaryDamageScale;
	} else if (DamageType == 'decapitated') {
		NewDamage *= RipperHeadshotDamageScale;
	} else if (DamageType == 'Impact') { // hammer
		NewDamage *= MeleeWeaponDamageScale;
	} else if (DamageType == 'slashed') { // chainsaw
		NewDamage *= MeleeWeaponDamageScale;
	} else if (DamageType == 'RedeemerDeath') {
		// Do nothing
	} else {
		REPORT(InstigatedBy,"Did not recognise DamageType '"$DamageType$"'");
	}

	if (bAdjustBoost && NewDamage != ActualDamage && ActualDamage!=0) {
		if (!bOnlyAdjustBoostDownwards || NewDamage<ActualDamage) {
			// REPORT(InstigatedBy,"Changing momentum "$VSize(Momentum));
			Momentum = (Momentum * NewDamage) / ActualDamage;
		}
	}

	if (NewDamage != ActualDamage || bLiveReports && bReportAllDamage) {
		if (bDidCrouchReduction) {
			ReportStr = " [crouch]";
		} else {
			ReportStr = "";
		}
		if (bSniperShot) {
			ReportStr = ReportStr $ " [sniper]";
		}
		if (NewDamage == ActualDamage) {
			REPORT(InstigatedBy,"Normal '"$DamageType$"': "$ActualDamage $ ReportStr);
		} else {
			REPORT(InstigatedBy,"Inflicted '"$DamageType$"': "$ActualDamage$" -> "$NewDamage $ ReportStr);
			REPORT(Victim,"Received '"$DamageType$"': "$ActualDamage$" -> "$NewDamage $ ReportStr);
		}
	}

	NewMomentum = Momentum;
	// NewMomentum = vect(Momentum.X,Momentum.Y,Momentum.Z);
	// NewMomentum = Momentum*1;

	// if (NewDamage == 0) {
		// DamageType = ''; //// Does not pr_vent blood spurts from appearing
	// }

	return NewDamage;

}

// Don't call me direct.  Call REPORT instead, to avoid constructing strings which will never be used.
function Report(Pawn Target, String Msg) {
	DEBUG("("$ GHN(Target) $") "$ Msg);
	if (bLiveReports && PlayerPawn(Target)!=None) {
		Target.ClientMessage(Msg);
	}
}

function String GHN(Actor a) {
	if (Pawn(a) != None) {
		return Pawn(a).getHumanName();
	} else {
		return String(a);
	}
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrStartsWith(Msg,"!")) {
			CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, coerce string Msg, optional bool bBeep, optional name Type) {
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrContains(Msg,":!")) {
			// Spectator messages start with the extra "<nick>:".  We remove this.
			CheckMessage(Mid(Msg,InStr(Msg,":!")+1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type);
}

function Mutate(String str, PlayerPawn Sender) {
	CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local String command;
	local String tmpstr;

	// DEBUG("FixWeaponBalance.CheckMessage() ("$Sender$"): "$Msg$"");
	argCount = SplitString(line," ",args);

	command = args[0];

	if (command ~= "STATUS") {
		SendStatusTo(Sender);
		return True;
	}

	if (!Sender.bAdmin) {
		return False;
	}
	// The following commands are for ADMINS ONLY

	if (command ~= "HELP") {
		Sender.ClientMessage("FixWeaponBalance.bEnabled = "$bEnabled);
		Sender.ClientMessage("FixWeaponBalance commands: fwb | report | status");
		return True;
	}

	// Admin can easily turn this on for testing, but it won't be saved for next map
	if (command ~= "REPORT" || command ~= "FWBREPORT") {
		bLiveReports = !bLiveReports;
		if (bLiveReports)
			BroadcastMessage(Sender.getHumanName()$" has ENABLED FixWeaponBalance reporting with \"mutate report\".");
		if (!bLiveReports)
			BroadcastMessage(Sender.getHumanName()$" has DISABLED FixWeaponBalance reporting with \"mutate report\".");
	}

	if (command ~= "FWB") {
		bEnabled = !bEnabled;
		if (bEnabled)
			tmpstr = "ENABLED";
		else
			tmpstr = "DISABLED";
		if (bLiveReports)
			BroadcastMessage(Sender.getHumanName()$" has "$tmpstr$" FixWeaponBalance.");
		else
			Sender.ClientMessage("You have "$tmpstr$" FixWeaponBalance.");
		return True;
	}

	return False;

}

//// Normally we send the info to the caller:
// #define Send Sender.ClientMessage
//// But sometimes I want the output logged to the logfile, so I can post-process it:
// #define Send DEBUG
// #define Send(X); Sender.ClientMessage(X); Log(X);
#define Send(X); if (Sender==None) { Log(X); } else { Sender.ClientMessage(X); }
function SendStatusTo(Pawn Sender) {
	Send("FixWeaponBalance settings:");
	Send("  Enabled = "$bEnabled);
	Send("  Logging = "$bLogging);
	Send("  Reporting = "$bLiveReports);
	Send("  bKeepHeadshotsInAllModes = "$bKeepHeadshotsInAllModes);
	Send("  SniperDamageScale = "$PercentageChangeStr(SniperDamageScale));
	Send("  SniperMaxDamage = "$SniperMaxDamage);
	Send("  bScaleSniperByDistance = "$bScaleSniperByDistance);
	Send("    SniperPowerRange = "$SniperPowerRange);
	Send("    SniperMaxRange = "$SniperMaxRange);
	Send("    SniperMinDamage = "$SniperMinDamage);
	Send("  bFixCrouchingBug = "$bFixCrouchingBug);
	Send("  RocketDamageScale = "$PercentageChangeStr(RocketDamageScale));
	Send("  RocketGrenadeDamageScale = "$PercentageChangeStr(RocketGrenadeDamageScale));
	Send("  BioDamageScale = "$PercentageChangeStr(BioDamageScale));
	Send("  EnforcerDamageScale = "$PercentageChangeStr(EnforcerDamageScale));
	Send("  MinigunDamageScale = "$PercentageChangeStr(MinigunDamageScale));
	Send("  ShockPrimaryDamageScale = "$PercentageChangeStr(ShockPrimaryDamageScale));
	Send("  ShockBallDamageScale = "$PercentageChangeStr(ShockBallDamageScale));
	Send("  FlakPrimaryDamageScale = "$PercentageChangeStr(FlakPrimaryDamageScale));
	Send("  FlakSecondaryDamageScale = "$PercentageChangeStr(FlakSecondaryDamageScale));
	Send("  PulseDamageScale = "$PercentageChangeStr(PulseDamageScale));
	Send("  PulsebeamDamageScale = "$PercentageChangeStr(PulsebeamDamageScale));
	Send("  RipperDamageScale = "$PercentageChangeStr(RipperDamageScale));
	Send("  RipperSecondaryDamageScale = "$PercentageChangeStr(RipperSecondaryDamageScale));
	Send("  RipperHeadshotDamageScale = "$PercentageChangeStr(RipperHeadshotDamageScale));
	Send("  MeleeWeaponDamageScale = "$PercentageChangeStr(MeleeWeaponDamageScale));
	Send("  bAdjustBoost = "$bAdjustBoost);
	//// Inaccurate approximation, given thresholds.
	/* Send("So hardcore headshot 150 now gives "$ Int(150*SniperDamageScale) $" and bodyhit 67 gives "$ Int(67*SniperDamageScale) $"."); */
}

function String PercentageChangeStr(float proportion) {
	if (proportion == 1.0) {
		return "normal";
	}
	if (proportion < 1.0) {
		return Int(100*(1.0-proportion)+0.5)$"% smaller ["$proportion$"]";
	}
	if (proportion > 1.0) {
		return Int(100*(proportion-1.0)+0.5)$"% larger ["$proportion$"]";
	}
}

#include "../../JLib/jlib.uc.jpp"

defaultproperties {
	bEnabled=True
	bLogging=True
	bLiveReports=False
	bAdvertise=True
	bReportAllDamage=True

	bKeepHeadshotsInAllModes=False
	SniperDamageScale=1.0
	SniperMaxDamage=150
	bScaleSniperByDistance=True
	SniperPowerRange=256
	SniperMaxRange=3072
	SniperMinDamage=12
	bFixCrouchingBug=False

	RocketDamageScale=1.00
	RocketGrenadeDamageScale=1.00
	BioDamageScale=1.00
	EnforcerDamageScale=1.00
	MinigunDamageScale=1.00
	ShockPrimaryDamageScale=1.00
	ShockBallDamageScale=1.00
	FlakPrimaryDamageScale=1.00
	FlakSecondaryDamageScale=1.00
	PulseDamageScale=1.00
	PulsebeamDamageScale=1.00
	RipperDamageScale=1.00
	RipperSecondaryDamageScale=1.00
	RipperHeadshotDamageScale=1.00
	MeleeWeaponDamageScale=1.00

	bAdjustBoost=True
	bOnlyAdjustBoostDownwards=True
}

// Note that this does not affect damage to armour, only damage to health.
// Usually a headshot does 150 damage, and a body shot does 67.

// We might want a headshot to do 102, and a bodyshot 52.  (scale 0.78)
// This is the minimum that will look normal on a guy with 100 hp and 0 armour.

// (Alternatively, for bodyshot 55, use scale 0.825.)

// In non-hardcore mode (which Siege requires for jetpack), headshots usually
// cost 100 and bodyshots 58.

