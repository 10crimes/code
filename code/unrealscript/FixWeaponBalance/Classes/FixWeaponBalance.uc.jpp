class FixWeaponBalance expands Mutator config(FixWeaponBalance);

// TODO: OK we have done sniper and headshots.  But I also want to fix minigun (and pulse), in the cases when PureStats is not present - either reduce the amount of shit it spits out, or somehow limit the max amount of damage it can do over the course of 0.1 of a second.
// TODO: Optionally, we should treat shock the same way we treat enforcer.

// #define SHOTS_JUST_FAIL
#define REDUCED_COLLISION_CYLINDER
#define TRACE_METHOD_RETRACE

// #define ADJUST_DAMAGE_AND_BOOST(X) 
#define DO_FIDDLE_HEADSHOT
#define ADJUST_DAMAGE_AND_BOOST(X) X

// Debugging:

// #define COLLECT_STATS(X) 
#define DO_COLLECT_STATS
#define COLLECT_STATS(X) X

#define SPAWN_LINE

#define DebugLog(X); if (bLogging) { Log("[FixWeaponDamage] "$(X)); BroadcastMessage("[FWD] "$(X)); }
// #define DebugLog(X); 

var config bool bEnabled;
var config bool bLogging;
#ifdef SHOTS_JUST_FAIL
var config float HeadshotFailRate;
var config float BodyhitFailRate;
// TODO: implement!
#endif
#ifdef REDUCED_COLLISION_CYLINDER
//// TODO: hard code these variables (maybe even use #define!) for official release.
// var float HeadRadiusScale,HeadHeightScale;
var config float HeadRadiusScale,HeadHeightScale;
var config float BodyRadiusScale;
var config float SniperDamageScale,SniperBoostScale;
#ifdef DO_FIDDLE_HEADSHOT
var config float HeadshotDamageScale,HeadshotBoostScale;
#endif
#endif

#ifdef DO_COLLECT_STATS
var int HeadshotCount, HeadshotWideCount, HeadshotLowCount, HeadshotRespectedCount;
var float AverageHeadshotRadius, AverageHeadshotHeight;
var float MaxHeadshotRadius, MinHeadshotRadius, MaxHeadshotHeight, MinHeadshotHeight;
var int BodyhitCount, BodyhitWideCount;
var float AverageBodyhitRadius, AverageBodyhitHeight;
var float MaxBodyhitRadius, MinBodyhitRadius, MaxBodyhitHeight, MinBodyhitHeight;
#endif

function PostBeginPlay() {
	if (bEnabled) {
		Level.Game.RegisterDamageMutator(Self);
	}
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrStartsWith(Msg,"!")) {
			CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

function Mutate(String str, PlayerPawn Sender) {
	CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local String command;

	/*
	if (!Sender.bAdmin) {
		return False;
	}
	*/

	// DebugLog("FixWeaponBalance.CheckMessage() ("$Sender$"): "$Msg$"");
	argcount = SplitString(line," ",args);

	command = args[0];

	//// Normally we send the info to the caller:
	// #define Send Sender.ClientMessage
	//// But sometimes I want the output logged to the logfile, so I can post-process it:
	#define Send DebugLog
	if (command ~= "STATUS") {
		Send("FixWeaponBalance.bEnabled = "$bEnabled);
		Send("FixWeaponBalance.bLogging = "$bLogging);
		Send("FixWeaponBalance.HeadHeightScale = "$HeadHeightScale);
		Send("FixWeaponBalance.HeadRadiusScale = "$HeadRadiusScale);
		Send("FixWeaponBalance.BodyRadiusScale = "$BodyRadiusScale);
		Send("FixWeaponBalance.SniperBoostScale = "$SniperBoostScale);
		Send("FixWeaponBalance.SniperDamageScale = "$SniperDamageScale);
		ADJUST_DAMAGE_AND_BOOST(
		Send("FixWeaponBalance.HeadshotDamageScale = "$HeadshotDamageScale);
		Send("FixWeaponBalance.HeadshotBoostScale = "$HeadshotBoostScale);
		)
		#ifdef DO_COLLECT_STATS
		Send(HeadshotCount $" headshots, "$ HeadshotWideCount $" wide, "$ HeadshotLowCount $" low.");
		// Send("HeadshotCount = "$HeadshotCount);
		// Send("HeadshotWideCount = "$HeadshotWideCount);
		// Send("HeadshotLowCount = "$HeadshotLowCount);
		// Send("HeadshotRespectedCount = "$HeadshotRespectedCount);
		// Send("BodyhitCount = "$BodyhitCount);
		// Send("BodyhitWideCount = "$BodyhitWideCount);
		Send("HeadshotRadius was ~ ["$MinHeadshotRadius$" - "$AverageHeadshotRadius$" - "$MaxHeadshotRadius$"]");
		Send("HeadshotHeight was ~ ["$MinHeadshotHeight$" - "$AverageHeadshotHeight$" - "$MaxHeadshotHeight$"]");
		Send("BodyhitRadius was ~ ["$MinBodyhitRadius$" - "$AverageBodyhitRadius$" - "$MaxBodyhitRadius$"]");
		Send("BodyhitHeight was ~ ["$MinBodyhitHeight$" - "$AverageBodyhitHeight$" - "$MaxBodyhitHeight$"]");
		// Send("AverageHeadshotRadius = "$AverageHeadshotRadius);
		// Send("AverageHeadshotHeight = "$AverageHeadshotHeight);
		// Send("AverageBodyhitRadius = "$AverageBodyhitRadius);
		#endif
		return True;
	}

	if (command ~= "HELP") {
		Sender.ClientMessage("FixWeaponBalance.bEnabled = "$bEnabled);
		Sender.ClientMessage("FixWeaponBalance mutate commands: status");
		return True;
	}

	return False;

}

#ifdef SPAWN_LINE
	function DrawLine(Vector from,Vector to) {
		local Actor a;
		a = Spawn(class'Effects',,,,);
		// a = Spawn(class'Projectile',,,,);
		a.SetLocation((from+to)/2);
		a.DrawType = DT_Mesh;
		a.Mesh = Mesh'Botpack.bolt1';
		a.Texture = Texture'UMenu.Icons.Bg41';
		a.DrawScale = VSize(from-to)/64.0;
		a.SetRotation(rotator(to-from));
		a.LifeSpan = 3.0;
		// TODO: kill old lines!
	}

	function DrawCylinder(Vector centre, float height, float radius) {
		local float angle;
		local vector outV;
		for (angle=0;angle<2.0*3.1415;angle+=2.0*3.1415/11.0) {
			outV = vect( 1.0, 1.0, 0.0 );
			outV.x = radius*sin(angle);
			outV.y = radius*cos(angle);
			DrawLine(centre-height*vect(0.0,0.0,1.0)+outV,centre+height*vect(0.0,0.0,1.0)+outV);
			DrawLine(centre+height*vect(0.0,0.0,1.0)+outV,centre+height*vect(0.0,0.0,1.0)-outV);
		}
		// DrawCircle(centre-height*vect(0,0,1),radius);
		// DrawCircle(centre+height*vect(0,0,1),radius);
	}

	function DrawStar(Vector centre, float radius) {
		local int i;
		local Vector vOut;
		// We could spawn an sgProtector
		for (i=0;i<5;i++) {
			vOut = radius * VRand();
			DrawLine(centre-vOut,centre+vOut);
		}
	}

	function DrawSplat(Vector centre, float radius, Vector normal) {
		local int i;
		local Vector vOut;
		// We could spawn an sgProtector
		for (i=0;i<5;i++) {
			vOut = radius * VRand();
			if (vOut Dot normal < 0)
				vOut = -vOut;
			DrawLine(centre,centre+vOut);
		}
	}
#endif

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {

	local bool bSniperShot,bHeadshot; // bSniperShot also counts of Enforcer.
	local float Shoulders,HeadRadiusThreshold,BodyRadiusThreshold;
	local int NewDamage;
	local Vector StartTrace,X,Y,Z,closestPoint;
	local float HitHeight,HitDistance;
	local rotator AdjustedAim;
	local Vector HitVec,HitVec2D;
	local float dotpx,dotpy;
	local bool bHitHead,bHitBody;
	local vector headHitLocation,headHitNormal;
	local vector bodyHitLocation,bodyHitNormal;

	// Detect headshot like in Botpack.SniperRifle, but reduce radius, and if outside boundary, fail.
	// Consider: if player is dodging, does headshot cylinder really appear where the head is in the mesh?

	// With/without zeroping we might want different damage/boost values.

	// TODO: Check crouch!

	// DONE: Appears to vary far wide of target if sniping from high above target.  Ah that was cos I was using Rotation instead of ViewRotation.
	// TODO: Instead of InstigatedBy.Location, it should be his View/Eyes Location!

	// TODO: Alternative method.  Temporarily change the player's cylinder size, and re-perform the trace, once for body cylinder, once for headshot cylinder.  Reset their cylinder size to normal.

	if (PlayerPawn(InstigatedBy)!=None) {

		// Is this a headshot?
		if (DamageType == 'decapitated' /*ActualDamage==100*/ ) { // ActualDamage can be 150, or less if the victim had armour.

			// From Botpack.SniperRifle:
			if ( Victim.bIsPawn && (InstigatedBy.IsA('PlayerPawn') || (InstigatedBy.IsA('Bot') && !Bot(InstigatedBy).bNovice)) ) {
			// If bots make as many headshots with our cylinder checks as they did without, we must reduce their probability of success another way.

				if (SniperRifle(InstigatedBy.Weapon)!=None) {

					bSniperShot = True;
					bHeadshot = True;

				}

			} else {

				DebugLog("Got 'decapitated' but from unexpected weapon: "$ InstigatedBy.Weapon);
				// Ripper should appear here.

			}

		}

		// TODO: minigun bullets also register as 'shot'.  Let's check InstigatedBy.Weapon?
		// Is this a sniper or enforcer hit (not a headshot)?
		if (DamageType == 'shot') { // Enforcer hit, or sniper hit (not headshot), or ...

			if ( SniperRifle(InstigatedBy.Weapon)!=None || Enforcer(InstigatedBy.Weapon)!=None ) {

				bSniperShot = True;

			} else {

				if (Minigun2(InstigatedBy.Weapon)==None) {
					DebugLog("Got 'shot' but from unexpected weapon: "$ InstigatedBy.Weapon);
				}

			}

		}

		if (bSniperShot) {
			// OK so we will check this shot in a moment, one way or ther other (head/body).  Let's prepare information variables by calculation now:

			// Code from pawn.PlayDying()
			GetAxes(Victim.Rotation,X,Y,Z);
			X.Z = 0;
			HitVec = Normal(HitLocation - Victim.Location);
			HitVec2D = HitVec;
			HitVec2D.Z = 0;
			// dotpx = HitVec2D dot X; // left/right
			dotpx = VSize(HitVec2D); // how much out horizontally?  relative to Z :P
			dotpy = HitVec dot Y; // forward/back?

			// DONE: We still haven't fixed that we are projecting from InstigatedBy.Location instead of .EyePos!
			GetAxes(InstigatedBy.ViewRotation,X,Y,Z);
			StartTrace = InstigatedBy.Location + InstigatedBy.Eyeheight * Z;
			// TODO: Some weapons require AdjustThingy?
			#define AimError 0.0
			AdjustedAim = InstigatedBy.AdjustAim(1000000, StartTrace, 2*AimError, False, False);
			X = vector(AdjustedAim);

			/*
			#ifdef TRACE_METHOD_RETRACE
			oldRadius = Victim.CollisionRadius;
			Victim.SetCollisionRadius(Victim.CollisionRadius*HeadRadiusScale);
			// Hit = Trace( blah );
			if (Hit != Victim) {
				// Should have been a headshot, but retrace did not hit the thinner cylinder.  FAIL!
				ActualDamage=0; Momentum=vect(0,0,0);
				// TODO: we should trace again to see if we hit the shorter body cylinder, making this a shoulder shot.
			}
			Victim.SetCollisionRadius(oldRadius);
			#endif
			*/

			// closestPoint = TraceClosestPoint( Victim.Location+vect(0,0,1)*Victim.CollisionHeight/2, StartTrace, Normal(X) );
			closestPoint = TraceClosestPoint( HitLocation, StartTrace, Normal(X) );
			// closestPoint = TraceClosestPoint( Victim.Location+vect(0,0,1)*Victim.CollisionHeight/2, StartTrace, Normal(Vector(InstigatedBy.ViewRotation)) );
			// [FixWeaponDamage] HeadshotRadius was ~ [0.000682 - 1.044139 - 9.069862]
			// [FixWeaponDamage] HeadshotHeight was ~ [0.679466 - 16.927570 - 19.462646]
			// [FixWeaponDamage] HeadshotRadius was ~ [0.003030 - 2.570150 - 10.887547]
			// [FixWeaponDamage] HeadshotHeight was ~ [-1.077423 - 13.717910 - 19.432686]
			// [FixWeaponDamage] HeadshotRadius was ~ [0.000576 - 0.122577 - 0.626369]
			// [FixWeaponDamage] HeadshotHeight was ~ [15.797211 - 18.642834 - 19.470581]
			//// With new implementation:
			// [FixWeaponDamage] HeadshotRadius was ~ [0.422036 - 1.746531 - 6.234318]
			// [FixWeaponDamage] HeadshotHeight was ~ [-0.085449 - 0.429157 - 2.902924]
			// [FixWeaponDamage] BodyhitRadius was ~ [0.000000 - 2.795679 - 20.520248]
			// [FixWeaponDamage] BodyhitHeight was ~ [-30.031872 - 2.288820 - 10.138580]
			// [FixWeaponDamage] HeadshotRadius was ~ [0.207370 - 1.339465 - 15.005936] usually 0.2 to 2.0, but occasionally larger
			// [FixWeaponDamage] HeadshotHeight was ~ [-38.886261 - -1.092013 - 2.626350]
			// [FixWeaponDamage] BodyhitRadius was ~ [0.000000 - 1.455932 - 23.485250]
			// [FixWeaponDamage] BodyhitHeight was ~ [-38.886261 - -1.395907 - 0.285797]
			// [FixWeaponDamage] 22 headshots, 13 wide, 9 low.
			// [FixWeaponDamage] HeadshotRadius was ~ [0.211071 - 2.779450 - 5.220775] when shooting downwards, got values 3.0 to 5.0
			// [FixWeaponDamage] HeadshotHeight was ~ [-0.108917 - 0.547277 - 1.574543]
			// [FixWeaponDamage] BodyhitRadius was ~ [0.000000 - 1.936938 - 5.484522]
			// [FixWeaponDamage] BodyhitHeight was ~ [-0.108917 - 2.386558 - 37.708881]
			// [FixWeaponDamage] 45 headshots, 8 wide, 36 low.
			// [FixWeaponDamage] HeadshotRadius was ~ [0.237819 - 1.172129 - 5.559518]
			// [FixWeaponDamage] HeadshotHeight was ~ [-0.359375 - 0.500799 - 9.676178]
			// [FixWeaponDamage] BodyhitRadius was ~ [0.000000 - 0.821304 - 6.010615]
			// [FixWeaponDamage] BodyhitHeight was ~ [-0.359375 - 0.111522 - 4.677551]
			// without zp:
			// [FixWeaponDamage] 20 headshots, 5 wide, 0 low.
			// [FixWeaponDamage] HeadshotRadius was ~ [0.225763 - 1.807922 - 6.595231]
			// [FixWeaponDamage] HeadshotHeight was ~ [-0.066315 - 0.986322 - 7.304016]
			// [FixWeaponDamage] BodyhitRadius was ~ [0.000000 - 1.738852 - 6.052964]
			// [FixWeaponDamage] BodyhitHeight was ~ [-0.320099 - 0.701654 - 4.199036]

			// closestPoint = TraceClosestPoint( Victim.Location+vect(0,0,1)*Victim.CollisionHeight/2, StartTrace, Normal(HitLocation-StartTrace) );
			// closestPoint = TraceClosestPoint( Victim.Location+vect(0,0,1)*Victim.CollisionHeight/2, HitLocation, Normal(HitLocation-StartTrace) );
			HitHeight = closestPoint.Z-Victim.Location.Z;
			HitDistance = HDist(closestPoint,Victim.Location);

			// Default Pawn radius is 17 and height is 39.
			// Shoulders = (0.1 - 0.38*HeadHeightScale)*Victim.CollisionHeight;
			// Shoulders = (0.9 - 0.45*HeadHeightScale)*Victim.CollisionHeight;
			// Shoulders = 19.0 + 0.47*(1.0-HeadHeightScale);
			// Shoulders = -0.45 + (10.0)*(1.0-HeadHeightScale);
			Shoulders = Victim.CollisionHeight * (1.0-0.38*HeadHeightScale);
			// TODO: Both HDist and TraceClosestPoint could be buggy - test against alternatives.
			// HeadRadiusThreshold = Victim.CollisionRadius * HeadRadiusScale;
			// HeadRadiusThreshold = 2.08;
			// HeadRadiusThreshold = 0.626 * HeadRadiusScale;
			// HeadRadiusThreshold = 3.5 * HeadRadiusScale;
			HeadRadiusThreshold = Victim.CollisionRadius * HeadRadiusScale;
			// BodyRadiusThreshold = Victim.CollisionRadius * BodyRadiusScale;
			// BodyRadiusThreshold = 6.01 * BodyRadiusScale;
			BodyRadiusThreshold = Victim.CollisionRadius * BodyRadiusScale;

			// #define HitCylinder(crs,chs) (DidHitCylinder(InstigatedBy,StartTrace,StartTrace+1.5*(HitLocation-StartTrace),Victim,crs,chs)==Victim)
			// #define HitCylinder(crs,chs,hlOut,hnOut) (DidHitCylinder(InstigatedBy,StartTrace,StartTrace+1.5*(HitLocation-StartTrace),Victim,crs,chs,hlOut,hnOut)==Victim)
			#define HitCylinder(crs,chs) (DidHitCylinder(InstigatedBy,StartTrace,StartTrace+10000*Normal(X),Victim,crs,chs)==Victim)
			#define HitCylinder(crs,chs,delta,hlOut,hnOut) (DidHitCylinder(InstigatedBy,StartTrace,StartTrace+10000*Normal(X),Victim,crs,chs,delta,hlOut,hnOut)==Victim)

			bHitHead = HitCylinder(HeadRadiusScale,1.0,0.0,headHitLocation,headHitNormal);
			// bHitBody = HitCylinder(BodyRadiusScale,0.62,bodyHitLocation,bodyHitNormal);
			bHitBody = HitCylinder(BodyRadiusScale,0.62,0.0,bodyHitLocation,bodyHitNormal);
			// TODO: we have chopped off 0.38 of his feet in the last check!
			// bHitBody = HitCylinder(BodyRadiusScale,0.81,-0.19,bodyHitLocation,bodyHitNormal);

			#ifdef SPAWN_LINE
				// DrawLine(HitLocation,StartTrace);
				if (bHitHead) {
					DrawLine(headHitLocation,StartTrace);
					// DrawStar(headHitLocation,2.5);
					DrawSplat(headHitLocation,4.5,headHitNormal);
				} else if (bHitBody) {
					DrawLine(bodyHitLocation,StartTrace);
					// DrawStar(bodyHitLocation,2.5);
					DrawSplat(bodyHitLocation,4.5,bodyHitNormal);
				} else {
					DrawLine(HitLocation,StartTrace);
					// DrawStar(HitLocation,2.5);
					DrawSplat(HitLocation,4.5,-Normal(Momentum));
				}
				// DrawCylinder(Victim.Location,Victim.CollisionHeight,Victim.CollisionRadius);
				// DrawCylinder(Victim.Location,Victim.CollisionHeight,17.00);
				// DrawCylinder(Victim.Location,Victim.CollisionHeight*0.62,17.00);
				// Instead of -1.0 to 1.0, we want -1.0 to 0.62, the average of which is -0.19, and totalling 2*0.81
				DrawCylinder(Victim.Location-0.19*Victim.CollisionHeight*vect(0,0,1),Victim.CollisionHeight*0.81,Victim.CollisionRadius);
				DrawCylinder(Victim.Location+vect(0,0,1)*Victim.CollisionHeight*(0.62+0.38/2.0),Victim.CollisionHeight*0.38/2,17.00*HeadRadiusScale);
				Log("Victim's CHeight="$Victim.CollisionHeight$" and CRadius="$Victim.CollisionRadius);
			#endif

		}

		if (bSniperShot && bHeadshot) {

			Log("dotpx "$dotpx$" dotpy "$dotpy);

			// It's actually quite normal to get ActualDamage<100, if the enemy had shieldbelt, some of the damage has already been absorbed!
			Log("# HitLoc.Z = "$ (HitLocation.Z-Victim.Location.Z) $" HitLoc.Dist = "$ HDist(HitLocation,Victim.Location) $" HitHeight = "$ HitHeight $" HitDistance = "$ HitDistance );

			if (ActualDamage<100) {
				DebugLog("Headshot detected but damage "$ActualDamage$" < 100 !");
			}

			// Check it fits with Botpack.SniperRifle:
			if (HitLocation.Z - Victim.Location.Z > 0.62 * Victim.CollisionHeight) {
				// DebugLog("Detected headshot and agree.");
			} else {
				DebugLog("Detected headshot BUT Botpack.SniperRifle DISAGREES!!");
			}

			// Check our new cylinders:
			// Damn the horizontal distance we get from HitLocation and Victim.Location is useless!  (Always 0.00 or 8.17)
			// Without zp we get HDist ~ 10.39 - 15.9
			// Bots sometimes produce 10,17,21

			COLLECT_STATS( HeadshotCount++; )
			COLLECT_STATS( MaxHeadshotRadius = FMax( MaxHeadshotRadius, HitDistance ); )
			COLLECT_STATS( MinHeadshotRadius = FMin( MinHeadshotRadius, HitDistance ); )
			COLLECT_STATS( MaxHeadshotHeight = FMax( MaxHeadshotHeight, HitHeight ); )
			COLLECT_STATS( MinHeadshotHeight = FMin( MinHeadshotHeight, HitHeight ); )
			COLLECT_STATS( AverageHeadshotRadius = ( AverageHeadshotRadius*(HeadshotCount-1) + HitDistance ) / HeadshotCount; )
			COLLECT_STATS( AverageHeadshotHeight = ( AverageHeadshotHeight*(HeadshotCount-1) + HitHeight ) / HeadshotCount; )

			#ifdef COLLECT_STATS
				// DebugLog("Distance "$ Abs(HitDistance)/AverageHeadshotRadius $", "$ );
				Log("DeltaHeight = "$ (HitHeight-AverageHeadshotHeight) $" DeltaRadius="$ (HitDistance-AverageHeadshotRadius) );
			#endif

			#ifdef TRACE_METHOD_RETRACE

				if (bHitHead) {
					// Yes headshot!
					COLLECT_STATS( HeadshotRespectedCount++; )
					ADJUST_DAMAGE_AND_BOOST(
					if (HeadshotDamageScale != 1.0) {
						DebugLog("Scaling headshot damage by "$ Int(HeadshotDamageScale*100) $"%");
					}
					ActualDamage = ActualDamage*HeadshotDamageScale;
					)
				} else if (bHitBody) { // 0.64 right ?
					// Bodyshot!
					DebugLog("BELOW HEAD!"); // Neck-shot or Shoulder-shot!
					COLLECT_STATS( HeadshotLowCount++; )
					// bHeadshot = False; // Leaving it alone right now, to avoid the lower checks.
					if (ActualDamage>45)
						ActualDamage = 45;
				} else {
					DebugLog("OUTSIDE HEAD!"); // You clipped X's ear!
					// DebugLog("OUTSIDE HEAD!  "$ HDist(closestPoint,Victim.Location) $" > "$ HeadRadiusThreshold); // You clipped X's ear!
					// DebugLog("EAR SHOT!"); // You clipped X's ear!
					// if (bLogging) { BroadcastMessage(InstigatedBy.getHumanName()$" took "$Victim.getHumanName()$"'s ear off!"); }
					COLLECT_STATS( HeadshotWideCount++; )
					bHeadshot = False;
					ActualDamage = 0;
					Momentum = vect(0,0,0);
				}

			#else

				// HitLocation = closestPoint; // DONE: don't alter HitLocation, replace references to it below
				// if (closestPoint.Z-Victim.Location.Z < (1.0 - 0.38*HeadHeightScale)*Victim.CollisionHeight) {
				// Should be 0.38 but it was saying "below" too often!
				if (HitHeight < Shoulders) {
					DebugLog("BELOW HEAD!"); // Neck-shot or Shoulder-shot!
					// DebugLog("BELOW HEAD!  "$ HitHeight $" < "$ Shoulders $""); // Neck-shot or Shoulder-shot!
					bHeadshot = False;
					// DamageType = 'shot';
					if (ActualDamage>45)
						ActualDamage = 45;
					// Proceed to process normal body shot...
					COLLECT_STATS( HeadshotLowCount++; )
				} else if (HitDistance > HeadRadiusThreshold) {
					DebugLog("OUTSIDE HEAD!"); // You clipped X's ear!
					// DebugLog("OUTSIDE HEAD!  "$ HDist(closestPoint,Victim.Location) $" > "$ HeadRadiusThreshold); // You clipped X's ear!
					// DebugLog("EAR SHOT!"); // You clipped X's ear!
					// if (bLogging) { BroadcastMessage(InstigatedBy.getHumanName()$" took "$Victim.getHumanName()$"'s ear off!"); }
					bHeadshot = False;
					ActualDamage = 0;
					Momentum = vect(0,0,0);
					COLLECT_STATS( HeadshotWideCount++; )
				} else {
					// OK we accept it as a headshot.
					// Any changes?
					ADJUST_DAMAGE_AND_BOOST(
					if (HeadshotDamageScale != 1.0) {
						DebugLog("Scaling headshot damage by "$ Int(HeadshotDamageScale*100) $"%");
					}
					ActualDamage = ActualDamage*HeadshotDamageScale;
					)
					COLLECT_STATS( HeadshotRespectedCount++; )
				}

			#endif

			// proportionFromTop = (HitLocation.Z - VictimLocation.Z) / Victim.CollisionHeight ... (now 1 to -1 but want 0 to 1)

		}

		if (bSniperShot && !bHeadshot) {

			COLLECT_STATS( BodyhitCount++; )
			COLLECT_STATS( MaxBodyhitRadius = FMax( MaxBodyhitRadius, HitDistance ); )
			COLLECT_STATS( MinBodyhitRadius = FMin( MinBodyhitRadius, HitDistance ); )
			COLLECT_STATS( MaxBodyhitHeight = FMax( MaxBodyhitHeight, HitHeight ); )
			COLLECT_STATS( MinBodyhitHeight = FMin( MinBodyhitHeight, HitHeight ); )
			COLLECT_STATS( AverageBodyhitRadius = ( AverageBodyhitRadius*(BodyhitCount-1) + HDist(closestPoint,Victim.Location) ) / BodyhitCount; )
			COLLECT_STATS( AverageBodyhitHeight = ( AverageBodyhitHeight*(BodyhitCount-1) + closestPoint.Z-Victim.Location.Z ) / BodyhitCount; )

			#ifdef TRACE_METHOD_RETRACE

				// Check collision:
				if (!bHitBody) {
					DebugLog("MISSED BODY!");
					ActualDamage = 0;
					Momentum = vect(0,0,0);
					COLLECT_STATS( BodyhitWideCount++; )
				}

			#else

				// Was this a wide headshot which the engine told us was a bodyshot?
				if (HitHeight > Shoulders) {
					if (HDist(closestPoint,Victim.Location) > HeadRadiusThreshold) {
						DebugLog("ABOVE SHOULDER SHOT");
						ActualDamage = 0;
						Momentum = vect(0,0,0);
						COLLECT_STATS( BodyhitWideCount++; )
					} else {
						DebugLog("HEADSHOT from low!");
					}
				}

				// Check collision:
				if (HDist(closestPoint,Victim.Location) > BodyRadiusThreshold) {
					DebugLog("OUTSIDE BODY!");
					ActualDamage = 0;
					Momentum = vect(0,0,0);
					COLLECT_STATS( BodyhitWideCount++; )
				}

			#endif

			// Scale damage?
			NewDamage = ActualDamage * SniperDamageScale;
			if (NewDamage < ActualDamage) {
				DebugLog("Reducing SHOT "$ActualDamage$" -> "$NewDamage$" ( "$GHN(InstigatedBy)$" -> "$GHN(Victim)$" )");
			}
			ActualDamage = NewDamage;
			Momentum = Momentum * SniperBoostScale;

		}

	}

	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
}

/*
function float Max(float a, float b) {
	if (a>b)
		return a;
	else
		return b;
}

function float Min(float a, float b) {
	if (a<b)
		return a;
	else
		return b;
}
*/

function Actor DidHitCylinder(Pawn InstigatedBy, vector StartTrace, vector EndTrace, Pawn Target, float crs, float chs, optional float delta, optional out Vector HitLocation, optional out Vector HitNormal) {
	local Actor hitActor;
	local float oldCH,oldCR;
	oldCH = Target.CollisionHeight;
	oldCR = Target.CollisionRadius;
	Target.SetCollisionSize(oldCR*crs,oldCH*chs);
	// TODO: Pfff we need to do Target.Move(vect(0,0,1)*delta) ...
	// hitActor = InstigatedBy.TraceShot(HitLocation, HitNormal, EndTrace, StartTrace);
	hitActor = InstigatedBy.Trace(HitLocation, HitNormal, EndTrace, StartTrace, true);
	Target.SetCollisionSize(oldCR,oldCH);
	Log("We hit "$hitActor$".  We were supposed to hit "$Target$".");
	return hitActor;
}
// If it hit the thin cylinder, but below the head, then really it's a shoulder shot, although we could say it's a neck shot, although at really steep angle we might only be reaching the centre at his feet.

function String GHN(Actor a) {
	if (Pawn(a) != None) {
		return Pawn(a).getHumanName();
	} else {
		return String(a);
	}
}

function float HDist(Vector a, Vector b) {
	// // Log("Distance is "$ sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) ) $"");
	// return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );
	a.Z = 0; b.Z = 0; return VSize(a-b);
}

function Vector TraceClosestPoint(Vector target, Vector start, Vector direction) {
	// Note: direction should be normalised before we get it!
	local Vector closestPoint;
	local Vector planeNormal;
	local Vector direction2d;
	local float horDist;

	/*
	local Vector normalUp,normalIn;
	local float closestDistance;
	normalUp = Normal(target-start) Cross direction;
	normalIn = normalUp Cross direction;
	closestDistance = (target - start) Dot normalIn;
	closestPoint = target - normalIn*closestDistance;
	// Log("closestDistance="$ closestDistance $" hor="$ HDist(closestPoint,target) $" ver="$ (closestPoint.Z-target.z) );
	// closestDistance = Abs(closestDistance);
	*/

	// NEW:
	/*
	closestPoint = start + direction * VSize(target-start);
	*/

	// Make a plane?
	planeNormal = start-target;
	planeNormal.Z = 0;
	planeNormal = Normal(planeNormal);
	// Where does trajectory line hit plane?
	// Calculate horizontal distance:
	horDist = (target-start) Dot -planeNormal;
	closestPoint = start + direction*horDist;
	direction2d = direction;
	direction2d.Z = 0;
	horDist = VSize(DropZ(target)-DropZ(start));
	// horDist = VSize(DropZ(HitLocation)-DropZ(start));
	// How many times direction must we move to reach the plane?
	#define times (horDist/VSize(direction2d))
	closestPoint = start + direction*times;

	// (target - start) Dot direction;
	// closestPoint = 

	// closestPoint = HitLocation + direction*17.0;
	// closestPoint = HitLocation + DropZ(direction)*17.0;

	return closestPoint;
}

function Vector DropZ(Vector v) {
	v.Z = 0;
	return v;
}

#include "../../JLib/jlib.uc.jpp"

defaultproperties {
	bEnabled=True
	bLogging=True
	// If all these values are 1.0 then FixWeaponBalance *should* do nothing in default non-zp mode.
	// If zp is running, it may see shots as outside the cylinder!
	// SniperDamageScale=0.667
	HeadHeightScale=1.0
	HeadRadiusScale=0.3
	BodyRadiusScale=0.9
	SniperDamageScale=1.000
	// SniperBoostScale=0.667
	ADJUST_DAMAGE_AND_BOOST(
	HeadshotDamageScale=1.000
	HeadshotBoostScale=1.000
	)
	SniperBoostScale=1.000
	MinHeadshotRadius=100000
	MinHeadshotHeight=100000
}


