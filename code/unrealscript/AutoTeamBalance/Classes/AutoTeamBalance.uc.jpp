/*

// NEW:

// Changes in 1.3
// Added MinRequestsForRebalance
// Added bSeparateStatsByMutators (sony_scarface, or anyone who had bSeparateStatsByGamemode in earlier versions, should set this to True to keep your database as it was)
// Fixed the "X has lost N cookies" appearing when it shouldn't bug
// Scaled FlagStrength for non-CTF gametypes, so it is not disproportional
// (The question of FlagStrength: do you want to make entirely even teams after the balancing - FlagStrength=0, or do you want to "punish" the winning team by giving them virtual strength according to their team-score lead?)

// CONSIDER TODO: ok mutator signature is optional - but what if i only want to differentiate between *certain* gametypes, not all?
//                let's say, i want CTFGame and DeathMatchPlus grouped together, but SiegeGI separate from them.

// TODO: should we scale FlagStrength according to #players?  (Max(#players-2,0)?) -- may fix pizzaman's bug

// TODO: make 2-player balancing optional
// TODO: when one team has >2 players, don't require MinRequestsForRebalance, and switch as many as needed!

// TESTING: min-requests-to-rebalance

// TODO: integrate with AKA

// FIXED: bBroadcastStuff was causing BroadcastMessageAndLog(""$ p.getHumanName() $" has lost "$ Int(previous_average-avg_score[i]) $" cookies."); }, but now it is only when bFlashCookies=True

// TODO: increase mintimewhenipchanges, *especially* if first two digits remain the same

// TODO: when ip does change (often), delete the old record - it's no use to us

// DONE: only broadcast fakenickers when nick changes, not IP :P (but maybe still log)

// TODO: fix the bug that occasionally creates multiple records for one player+ip pair
// BUG: duplicates are appearing in the database, player strength (=cookies) are not being updated.
// BUG: FlagStrength=20 constributed reasonable strength for CTF, but on DOM/DM it contributes far too much!  Assume and end-score of 200, except for CTF=10, Siege=20, DM=100, to scale FlagStrength according to GameType.
// BUG: FlagStrength really should be low; we don't want silly revenge, we want even teams!
// BUG: bReportFlagStrength
// BUG: people complaining about flashing cookies

// TODO: we should really add last_date_played, so that we can recycle old records suitably.

// October 2007: For version 1.3 I stripped out a lot of comments.  If you don't understand the reasons for certain bits of code, you may wish to refer to the comments in version 1.2.



// OLD:

// FORGET: refuse to perform mid-game rebalance if the resulting change in team strength difference will be below a threshold.

// CONSIDER: players who join part-way through a game, will tend to make the teams a little uneven, and as a result that player may score higher than he really deserves, which then mucks up the balance for the next game.

// TODO: pizzaman said it would sometimes refuse to balance a 2v0 ... that's either because a player has negative score, or because the 0-player team has more caps.  Assume FlagStrength==0 when balancing with only 2 players on the server?

// TODO: kinda undesirable with the initial pug-balancing algorithm: if there are 5 players, the strongest will get 2 on his team (red) while blue only have 2!

// TODO: request to refuse to rebalance, unless a minimum number of players say "!teams".

// TODO: request to work on 4-team games

// TODO: consider using lastBalanceTime to meet the request that bForceEvenTeams should not act more often than, say, 1 minute.

// DONE: bRelativeNormalisation

// DONE: Make the Shaking and Buzzing on bWarnMidGameUnbalance optional.  It's very annoying.  Somem servers might just prefer a broadcast message.  (bFlashOnWarning bShakeOnWarning bBuzzOnWarning)

// DONE: when a player is switched by the mod, broadcast it, so that it is
// clear what happened, in addition to the flash+shake in that player's HUD.

// TODO: guess weak players (score<50 or never been on server) and put them on
// the *winning* team, in the hope that the next player to join will be
// stronger.  Argh we can't look up players who are just joining the server,
// because ModifyLogin has their nick but not their IP.

// DONE (bSeparateRankingsForDifferentGametypes):
// For SoNY_scarface, add option bSeparateRankingsForDifferentGametypes;
// this could append the gametype to each players nick in the DB, in order to
// store multiple databases.  Problem is, he might be playing all CTF gametype,
// but just with different mutators!  Maybe I could take the mutator signature
// too (e.g. compress/hash the list of mutators). bSeparateRankingsForDifferentMutators

// DUNNO   : i get this with bots when bRankBots=True, and i think i may get it with players too
//           when a new player joins the server for the first time, their strength mid-game appears to be 0, when it should be UnknownStrength.  the record says it gets created with strength UnknownStrength, but checking later it's 0
//           mmmm now i can't reproduce it; maybe it was copying another bot's record which had score or time 0

// CONSIDER TODO: (thinking of nzp where X=me) if X is an average skilled player who plays on the server a lot against weaker players, then X's ranking will be high
//  maybe occasionally l33t players will join the server, but X will have a similar ranking to them - inaccurate!  :|
//  if AutoTeamBalance was really clever, it would remember that there are l33t players out there who are stronger than X, and it would keep his (and all the noobs') ranking(s) lower, or the l33t players' ranking higher, to compensate
//  well i guess at least X's ranking will go down a *little* bit when those l33t players do play, and the l33t players will be top, but the fact that X plays a lot more on the server than those l33t players will cause this information to be hidden
//  maybe some sort of ladder system should be employed
//  I wonder if I can work out the maths for this...

// CONSIDER: i set UT's bBotsBalanceTeams=False, to see if ATB would balance the bots when they join, but it doesn't.  ModifyLogin() does not appear to get called for bots.

// DONE: switching team with !red when u have the flag, u keep the flag :E   Try doing the RestartPlayer before they switch teams!

// DONE: mutate kick is not working!  try using Sender.ConsoleCommand("admin kick "$getHumanName());  mmm if sender isn't full admin, maybe we can't do it -- could still be useful for admin tho, because whole nick is not needed, and may contain weird chars

// DONE: Added ScoringMethod 3 which I hope will work nicely.
//       I'm beginning to think that the strength building is still not very accurate.
//       For example, one pug Golyat scored 200 points on defence, from 40 frags (12 flagkills).
//       After normalisation, his high score would push down the scores of all the other players on the server, reducing their strengths in the database, even if some of them also played very well.
//       Maybe it would be better just to order the players on the server by score, and then award a strength between 10 and 100, so nobody can score too highly from one game.
// Also, after one 2v2 game of joust, all 4 players gained cookies.  I guess we all had low scores before, but since we were 4 noobs, now we all moved up closer to the average.  Is that desirable?

// DONE: allow admin to choose whether score or frags are used to build stats

// TODO: record last_date_played for each player
// This may be useful:
function string GetDate() {
    local string Date, Time;
    Date = Level.Year$"-"$PrePad(Level.Month,"0",2)$"-"$PrePad(Level.Day,"0",2);
    Time = PrePad(Level.Hour,"0",2)$":"$PrePad(Level.Minute,"0",2)$"."$PrePad(Level.Second,"0",2);
    return Date$"-"$Time"-";
}
function string PrePad(coerce string s, string p, int i) {
    while (Len(s) < i)
        s = p$s;
    return s;
}

// DONE: add command "mutate switch", faster than tored/toblue

// DONE: when doing "mutate strengths", show also hoursPlayed, relevant stats.  make it non-passworded

// FIXED: when i try to !play on f0x2, it tried to send me to 0.0.0.0

// TODO: test if switching players fails when UT's MaxTeamSize is low enough.  Solve it if neccessary (by temporarily changing MaxTeamSize).

// DONE: really we want (optional) automatic balancing, when 2 players from 1 team leave the game
//       or maybe just flash a warning that teams need to be balanced
//       yes, mid-game teambalance should always be instigated by a user

// When mid-game balancing, we try to find the player whos strength will make the teams most even.  But we may wish to give priority to switching the player who most recently joined the server, if the strengths are not so relevant.

// I don't think we are storing enough stats.
// We are only storing enough stats to perform teambalance according to my algorithms.
// Since we are storing stats, we may as well generate all interesting information.
// e.g.: deaths, suicides, last_date_played, frags (as opposed to score), most_used_weapon, ...

//// From PlayerPawn.ClientMessage():
// pawn.Player.Console.Message( pawn.PlayerReplicationInfo, "...", 'Event' );
// pawn.myHUD.Message( pawn.PlayerReplicationInfo, "...", 'Event' );

// CONSIDER: when a player joins the server before the game starts, we could message them to overwrite the default "you are on red" message, to tell them their team has not yet been assigned

// DONE: the defaults (for the XOL release at least) should be as close as possible to Sourceror's original XOL mod.  make options for other servers

// DONE: consider: should we normalise player scores in terms of time before we normalise the scores around the average?

// TODO: test: does this work ok as a ServerActor?  (I think it does, but one more test won't hurt)

// DONE: i had a report thata game was left running for a long time, then a player entered for the last minute and made 1 cap
//       they got +3294724 points!  try to reproduce this problem, then fix it.
//       i believe this was related to incorrectly recording the game start-time, which was fixed

// CONSIDER: sourceror recommends updating stats for any player who leaves the game part-way through.  maybe idefix's code knows how to detect this

// CONSIDER: viking recommends averaging score and frags, to get a mix of a player's DM skill and CTF skill (make it a bool option imo)

// DONE: optionally, use in-game scores for "!teams" and balancing when a new player joins, by doing a mid-game new-stats-calculation of the current players on the server (altho not an update)

// CONSIDER: (actually i think the boolean we have atm for broadcasting are just fine)
// AutoTeamBalance logging: 0=none, 1=to logfile, 2=broadcast in-game, 3=both
// // AutoTeamBalance logging level: 0=none, 1=hello etc, 2=details(show stats)
// AutoTeamBalance detailed stats logging: 0=none, 1=to logfile, 2=broadcast in-game, 3=both
// Cookies: 0=none, 1=console message to each player, 2=HUD message to each player, 3=broadcast message to all players
// CONSIDER:
// mm well we got 3 types of logging:
//   developer logging, we don't want live, except for major debugging, and it can be removed in final version
//   user(admin) friendly-logging
//   user(admin) friendly-logging, but it's inefficient so should be disabled except when admin is debugging

// DONE: mid-game team balancing should NOT switch players who have the flag (this requires some adjustment of the teambalance algorithm)  LOL atm if it does, the player keeps the flag, and the flag does not change colour :P
// DONE: mid-game team balancing should make as few switches as possible: yeah let's just switch 1 or 2 players, based on their stats.  If a new player has just joined (no stats yet), we could update their stats, to judge whether they really pwn.  (This might cause a little error in their total_time_on_server when end-game stats are processed)

// CONSIDER: we could now move to the list-of-gametype-strings method instead of all those bools (idefix prefers bools, since it's how mapvote does it)

// DONE: if mid-game-player-join teambalance is still slow after my attempts to make it more efficient,
//       try doing it without player stats lookup, just with in-game scores (optional)
// CONSIDER doing this anyway :P
// DONE: let the option whether to use recorded stats or in-game scores for balancing be configurable mid-game, so admin can try both methods during play
// CONSIDER: provide a few different algorithms for balancing teams, on different "!teams" commands, so they can be tested and evaluated

// DONE: watch for somebody saying "!teams" or "teams" and do mid-game balancing (TODO: based on current scores in case some players aren't in the stats)
// DONE: catch a player saying "!teams", maybe write some custom code to balance the teams then (by swapping 1/2 players only, maybe slightly randomised so it can be repeated if unsatisfactory; noo that could get too spammy :E)

// DONE: provide (semi-admin) commands to force players onto different teams, e.g. "mutate tored Tigz [<pass>]"
// DONE: if we do this, then make a "mutate teams [<pass>]" also

// DONE: configure hours_copied (if ppl change nick alot, we may want to keep all their hours!)
// DONE: add mid-game teambalance (on !teams, by scores plz)
// DONE: fix on-join teambalance (do it by scores if it's less laggy)

// NOTE: mid-game rebalancing puts me (when just 1 player) on a different team from the one it gives me at startup (lol because there are bots and the bots atm have better rankings than me :P )

// TODO: the balancing now says "X you have N cookies" which hides the message "You are on the Red team" which is kinda useful info, especially for mid-game balancing.  (is this still the case?)

// DONE: add configurable winningteambonus score (e.g. +10 frags/points) for every player on the winning team
//       this will help ranking to demote non-CTF players, and balance teams for games with even caps, not just even scores
// CONSIDER: instead of +10 for winning, -10 for losing?  what difference does that make to the stats anyway?
// CONSIDER: WinningTeamBonus could be combined with FlagStrength into just one config var.  With their current values, the bonus would need to be divided by #players on team.
// TODO: maybe the bonus should be hidden from the scoreboard.  DONE BUG it should definitely be disabled in tournament mode!
// CONSIDER: does WinningTeamBonus really help?  a DMer will end up on winning teams anyway, because his rating will be low, even tho he might frag well, so he'll be put with strong teammates.  true?  contradiction: why will his rating be low, if he's fragging well and getting on strong teams and hence winning the CTF?  :P

// CONSIDER: when seeking player records, should we do a case-insensitive match on player names?  (problem: would make the lookup slower)

// Some forms of stats building might tend to make it harder and harder for frequent players on the server.  (They will always been trying to regain points lost by earlier mistakes, until their MaxPollsBeforeRecyclingStrength is reached.)
// Well not neccessarily frequent players, but players with good stats.

//== AutoTeamBalance ==========================================================

// A mutator that makes fair teams at the beginning of each teamgame, by recording the relative strengths of players on the server (linked to their nick/ip).
// It also attempts to put a player joining the game on an appropriate team.
// It can only build player stats for regular players who stay until the end of the game.
// It will also take a while after running to build up accurate stats of the players.
// For the first week or so you may wish to collect stats but not attempt team-balancing: just set bAutoBalanceTeamsFor*=False but leave bUpdatePlayerStatsFor*=True.
// by Daniel Mastersourcerer at Kitana's Castle and F0X|nogginBasher.
// (c)opyleft May 2007 under GNU Public Licence
// Thanks to iDeFiX, unrealadmin, Matt and the author of adwvaad
// Code snippets lifted from iDeFiX's team balancer, TeamBallancer, and the adwvaad thread

// vim: tabstop=2 shiftwidth=2 expandtab filetype=uc

// NOTE: If your server has custom maps, it might be a good idea to increase NetWait to 20 or 30 seconds, to give each player a better chance of downloading the map and joining the game before it starts, so that player can be included in the teambalancing.  BUG: Do not use NetWait<3; it may cause the teambalance to occur before anyone joins the server!

// The field delimeter for playerData in the config files is a space " " since that can't appear in UT nicks (always _)

// HALF-DONE TODO: when the playerData array gets full, old records are not recycled properly (atm the last is just overwritten repeatedly :| )   - ok now we recycle the record with shortest play hours.  TODO: It's not perfect because the new player's stats might get overwritten pretty soon.  We either need a little randomnity, or we could store date_last_played[] (if I knew how to get a date in unrealscript)

// Done now: i shouldn't be taking averages over time, but over #polls :S  Actually either is fine, but I was doing it weirdly before.

// CONSIDER: in cases of a standoff (e.g. none of the players are found in the DB so all have UnknownStrength), choose something random!  What we are given may not be random enough (like bPlayersBalanceTeams).

// DONE: config options bRankBots and bBalanceBots (might be interesting to see how Visse compares to the humans ^^ )

// DONE: could also analyze TDM (DeathMatchPlus) scores, but without the CTF bonuses, these will be much lower (store in separate fields? e.g. avg_TDM_score TDM_hours_played)  What about a method to separate all teamgames?  OR Easier: make a separate player with nick+" "+ip+" "+gameType hash.  Mmm now that Normalising scores is the default, TDM and CTF stats can be recorded and should merge together nicely.

// Current rankings method:
// We wait until the end of the game, then we update the stats for each player.
// We optionally normalise their score, then multiply it up to (normalised) score-per-hour, then divide by 4 to get score per 1/4 hour.
// Hence we collect each player's average (normalised) score per 15 minutes.

// So what else could we try?
// - DONE Team Cap Bonus: regardless of frags, the team which played the best CTF will get the most caps.  All players on the winning team could be rewarded for having done so, even if their actual score was pretty low.
// - The actual scores might not be useful, but the distribution of those scores might be interesting.
//   For example, the order of players on the scoreboard (imagine if both teams were merged into one) should give an idea of the relative skills of certain players.  e.g. top player gets 100 points, all other players get less, bottom player gets 10.
//   DONE: Or the relative scores could be considered.  E.g. the scores from the game could be scaled so that they always have a mean of say 50 points.  So we can still use the game scores, but the scaling will "normalise" those scores so that as much benefit comes from doing well in a low-scoring game as in a high-scoring game.
//        Ofc this would mean the best noobs get similar scores to the best el33ts, if they the noobs and leets never actually play at the same time, which kinda makes sense.  ^^

// TODO: consider adding just a little randomnity.  If we have the same 8 players on the server for 4 games in a row, and their stats don't change enough to actually switch any of their positions in the ranking, won't Daniel's initial teambalance create identical teams for every game?  Can we find a way to avoid that?  Mix up the lower skilled players a bit, since that will have least impact?
// looks like FRand() might return a number between 0 and 1.

// TODO: throughout the code and comments i have referred to strength,avg_score,ranking,rating,stats but often meant the same thing.  Daniel stuck to "Strength" so maybe I should consolidate around that name.
// consider using a new word "judge" as the process of observing and maintaining user stats (as opposed to balancing or other features)

// Note: at the moment no attempt is made to update the strengths of players who leave the server before the end of the game.
// Only players on the server when the game ends will get their strenghts updated.
// Maybe that's undesirable.  iDeFiX's teambalancer updates stats mid-game (but i think it caches the info and does more processesing at the end of the game).

// CONSIDER: If players manage to make the teams unfair anyway, and then go and cap 10 flags 3v1, then the scores from that game will hardly be an accurate representation of what they should have been.  So should we be detecting whether teams were actually fair when we update the stats?  Well, maybe it's ok: the lamers who teamed up will get punished by unrealistically high stats, so next time they play they will get balanced with weak players on their team.  Mwuhahaha!  And the guy who got bullied will obviously need a break, so him losing some strength stats will just mean he gets some stronger team-mates in future.  :)  So I guess we don't really need to detect whether teams were fair when updating stats!

// CONSIDER: should we record lots of stats, like frags-per-hour, score-per-hour, normalised-score-per-hour, num-games-played, num-games-won, num-games-lost (diff = num-drawn or left before end)
// HALF-DONE we optionally output the extra stats to the log

*/

//=============================================================================

class AutoTeamBalance expands Mutator config(AutoTeamBalance);

// #define ENABLE_USEISPNOTFULLIP
#define ENABLE_ADMIN_COMMANDS
#define ENABLE_MUTATOR_SIGNATURE
#define ENABLE_MIN_REQUESTS_FOR_REBALANCE

// var string HelloBroadcast; // CONSIDER: make this configurable, and make it say nothing if ""

var config bool bBroadcastStuff;   // Be noisy to in-game console
var config bool bBroadcastCookies; // Silly/fun way to debug; each players strength change is spammed at end of game as their number of cookies
var config bool bFlashCookies;     // Silly/fun way to debug; each players has their cookies and cookie-change flashed on their screen at the beginning and end of each game.
var config bool bDebugLogging;     // logs are more verbose/spammy than usual; recommended only for developers
// bLogBalancing, bLogDatabase
// TODO: now we are doing p.ClientMessage() sometimes, we don't really need to BroadcastMessage as well (I only want it as a developer to see changes during the game.)
// var config bool bOnlyMoreCookies;  // only broadcast a players cookies when they have recently increased

var config bool bEnablePlayerCommands;
var config bool bLetPlayersRebalance;
#ifdef ENABLE_MIN_REQUESTS_FOR_REBALANCE
var config int MinRequestsForRebalance;
// var config int MinRequestsForRebalancePercent;
var int pidsRequestingRebalance[64];
var int lastRebalanceRequestTime;
#endif
var config bool bForceEvenTeams;
var config bool bWarnMidGameUnbalance;
var config bool bFlashOnWarning;
var config bool bShakeOnWarning;
var config bool bBuzzOnWarning;
var config bool bAllowSemiAdminKick;
var config bool bAllowSemiAdminForceTravel;
var config bool bBalanceBots; // Include bots in the rebalancing (CONSIDER: what happens if bBalanceBots is set but bRankBots is not?)
var config bool bRankBots; // Record stats for bots as if they were players.
var config int MinSecondsBeforeRebalance;
var config String SemiAdminPass;

var config bool bAutoBalanceTeamsForCTF;
var config bool bAutoBalanceTeamsForTDM;
var config bool bAutoBalanceTeamsForAS;
var config bool bAutoBalanceTeamsForOtherTeamGames;
// var config string BalanceTeamsForGameTypes; // TESTING_List_desired_gametypes
// For updating player strength in-game:
var config bool bUpdatePlayerStatsForCTF;
var config bool bUpdatePlayerStatsForTDM;
var config bool bUpdatePlayerStatsForAS;
var config bool bUpdatePlayerStatsForOtherTeamGames;
var config bool bUpdatePlayerStatsForNonTeamGames;
// var config string UpdateStatsForGameTypes; // TESTING_List_desired_gametypes
// var config bool bUpdateStatsForCTFOnly;  // Stats were updating during other gametypes, which yield entirely different scores.  (Maybe stats for different gametypes should be handled separately.)  If your server runs only one team gametype, or gametypes with comparably scores, you can set this to False.
//// These didn't work for me; maybe config vars can't be complex types like "name"
// var config name OnlyBalanceTeamsIfGametypeIsA; // Defaults to 'TeamGamePlus' so it will try to balance teams for all team games.
// var config name OnlyUpdateStatsIfGametypeIsA;  // Stats were updating during other gametypes than CTF, which yield entirely different scores.  (Maybe stats for different gametypes should be handled separately.)  You can set this to your own server's favourite gametype, or to 'TeamGamePlus' if you only host one gametype, or player scores are comparable across all your gametypes.

var config bool bLogExtraStats;       // in case you want to analyze the end-game stats yourself, instead of leaving that to AutoTeamBalance
// var config float PollMinutes;    // e.g. every 2.4 minutes, update the player stats from the current game
var config float MaxHoursWhenCopyingOldRecord;     // If you have lots of fakenicklamers or ip-changers on your server, set this high.  If not, set it low, so that players who unluckily share the same IP or nick, don't get their stats confused.
// var config int MaxPollsBeforeRecyclingStrength;    // after this many polls, player's older scores are slowly phased out.  This feature is disabled by setting MaxPollsBeforeRecyclingStrength=0 // DONE: refactored this to HoursBeforeRecyclingStrength
var config float HoursBeforeRecyclingStrength;
var config int MinHumansForStats; // below this number of human players, stats will not be updated, i.e. current game scores will be ignored
var config int ScoringMethod; // 0=score, 1=frags, 2=average_frags_and_score, 3=0-100_ordered_ranking
var config bool bNormaliseScores; // Recommended for servers where some games end with very high scores and some not (e.g. if you have different styles of map and game-modes, like mixing normal weapons clanwar maps with instagib action maps).  You can turn this off if your server has a fixed mapcycle and always the same game-mode.  Normalising results in a *relative* ranking of players who play the same games.  Not normalising would be better for separating weak and strong players who never actually played together.  If you have 10 strong players getting high scores on one game, and 10 noobs getting low scores during a different game, normalising would actually put the strongest noob up with the strongest pwnzor.  CONSIDER: would it be a useful compromise to "half-normalise"?  And how would we do that?  I think some logarithmic maths might be required.
var config bool bRelativeNormalisation; // During normalisation, the target average will be relative to the current strengths of players in the game.  So if you played against strong players, the strength you gain/lose will reflect this.
var config bool bScalePlayerScoreToFullTime; // After much consideration, I got close to implementing this.  But my final argument is: Why should a player be punished because they didn't play the game from the start?  Answer: Because there was a 50:50 chance that they made teams uneven when they joined, becoming the extra man on a team which was closely matched to the opponent.  Therefore it is quite likely that they will score well, because their team will be slaughtering the opponents.  (Their whole team will score better though.)    OK so I implemented it, although a little untidily in two places; maybe it's good to punish those players who join a game and score well, by giving them a high ranking and putting them on a weak team in future.  Also, even if their score is magnified by their short time in the server, that score will only count towards their ranking relative to that size of time.  :)
// deprecated: var config bool bDoWeightedUpdates;

// Defaults (Daniel's):
var config int NormalisedStrength; // The average forced when normalising scores.
var config int UnknownStrength;    // Default strength for unknown players.  It's only used briefly, if a new player stays until the end of the game then their stats will be generated, and this value forgotten.
// var config float UnknownMinutes;   // Initial virtual time spend on server by new players
var config int BotStrength;        // Default strength for bots
var config int FlagStrength;       // Strength modifier for captured flags
var config int StrengthThreshold;
var config int WinningTeamBonus;   // Players on the winning team get these bonus points at the end of the game (they contribute to stats)
var config bool bClanWar;
var config string clanTag;
var config bool bUseOnlyInGameScoresForRebalance;    // AKA bMidGameBalancingUsesInGameScoresNotPlayerRecords.  Completely new players cause the most strain on the server, because the whole record DB must be searched before they are "not found", ofc this could be smaller if MaxPlayerData is smaller, or if our search was made more efficient
var config bool bLogFakenickers;
var config bool bBroadcastFakenickers;
#ifdef ENABLE_USEISPNOTFULLIP
var config bool bUseISPNotFullIP;
#endif
#ifdef ENABLE_MUTATOR_SIGNATURE
var config bool bSeparateStatsByGamemode;
var config bool bSeparateStatsByMutators;
#endif
// var config bool bTesting;

// For storing player strength data:
var int MaxPlayerData; // The value 4096 is used in the following array declarations and the defaultproperties, but throughout the rest of the code, MaxPlayerData can be used to save duplication lol
var config String playerData[4096]; // String-format of the player data stored in the config (ini-file), including ip/nick/avg_score/time_played data

// Internal (parsed) player data:
var bool CopyConfigDone; // set to true after the arrays have been populated (so we don't do it twice)
var String ip[4096]; // We could consider using instead the default struct Guid { var int A, B, C, D; };
var String nick[4096];
var float avg_score[4096];
var float hours_played[4096];
// var int games_played[4096];
// TODO: var int date_last_played[4096]; // would be good for recycling old stats; otherwise recycle on lowest hours_played I guess, although if the server/playerData lasts 1billion years, it might be hard for the current generation of players to get into the ranking

// For local state caching (not repeating when called by Tick's or Timer's):
var bool initialized;              // Mutator initialized flag
var bool gameStartDone;            // Teams initialized flag (we never initialise this to False, but I guess Unreal does that for us)
var bool gameEndDone;

var int timeGameStarted;
var int lastBalanceTime;

defaultproperties {
  bBroadcastStuff=True      // whether or not to broadcast information to players
  bBroadcastCookies=False   // when enabled, players will see changes in their strength as earning or losing cookies
  bFlashCookies=False       // when enabled, players will see changes in their strength as earning or losing cookies
  bDebugLogging=False       // enable this only if you need to de-bug AutoTeamBalance
  bEnablePlayerCommands=True  // allows players to use !red !blue !spec !play !vote !stats (you might want to disable this if, for example, you are already using ASC to do this.)
  bLetPlayersRebalance=True    // allows players to fix teams mid-game by typing "teams" or "!teams"
  #ifdef ENABLE_MIN_REQUESTS_FOR_REBALANCE
  MinRequestsForRebalance=2            // Will not rebalance unless 2 players request it
  // MinRequestsForRebalancePercent=25    // or 25% of players request it.
  #endif
  bForceEvenTeams=False        // Still testing this
  bWarnMidGameUnbalance=False  // Warns players if teams become uneven mid-game
  bFlashOnWarning=True         // The warning will flash across the HUD, instead of appearing in the chat area
  bShakeOnWarning=False        // The warning will shake the screens of players on the stronger team
  bBuzzOnWarning=False         // The warning will make the sound of buzzing flies for players on the stronger team
  bAllowSemiAdminKick=True     // you can prev.nt semi-admins from kicking players by switching this off
  bAllowSemiAdminForceTravel=True  // you can prev.nt semi-admins from forcing a server move by switching this off
  bBalanceBots=False        // whether or not to balance bots as if they were humans (recommended off, since it might create 2v0 if bots are as strong as humans)
  bRankBots=False           // whether or not to record strengths for the bots (just for curiosity really)
  MinSecondsBeforeRebalance=20  // prev.nts players from spamming "!teams"; should be at least 1, to avoid a bug with multiple calls to MutatorTeamMessage
  SemiAdminPass="defaults_to_admin_pass"  // set this if you want semi-admins to use a different pass from the server admin pass
  bAutoBalanceTeamsForCTF=True
  bAutoBalanceTeamsForTDM=True  // you can select which game-modes will be balanced, and which will not
  bAutoBalanceTeamsForAS=True
  bAutoBalanceTeamsForOtherTeamGames=True
  bUpdatePlayerStatsForCTF=True  // BUG TODO:  Argh!  Won't this update scores from BT games too?!
  bUpdatePlayerStatsForTDM=True  // If you are normalising scores, then updating stats for TDM should be ok.  But if you are not normalising scores, then the different bonuses in CTF will make stats from the different gametypes incompatible.  (Basically TDMers will get lower strengths because they never get the bonus points from caps/covers/etc.)  So in this case you are recommended only to build stats for your server's most popular gametype.
  bUpdatePlayerStatsForAS=False  // Probably best left False (unless you are running an AS-only server) because AS scores are crazy (one guy gets 100 for the last objective, even though it was a team effort)
  bUpdatePlayerStatsForOtherTeamGames=False
  bUpdatePlayerStatsForNonTeamGames=True  // DM scores are a good indication of a player's strength, even though it's not a team-game
  bLogExtraStats=False      // records some extra player stats to the logfile at game-end, in case you are interested
  MaxHoursWhenCopyingOldRecord=4.0    // when a player changes nick or IP, his hours_played with the new nick or ip will be reduced to this
  HoursBeforeRecyclingStrength=6.0   // once a player has played for this long, his older scores start to fade away in favour of his more recent scores
  MinHumansForStats=4       // It's probably not healthy to update stats for 1v1 games, scores can be a little extreme
  ScoringMethod=2
  bNormaliseScores=True             // Normalises scores so that the average score for every 15 minutes is 50, or whatever specified below.  This is useful if scores from different games can be very different.  E.g. small spammy games get higher scores than large 2v2 games, and CTF has bonuses which you don't get in TDM.  Disadvantage: if strong and weak players play at different times on the server, they will get similar strengths, until they do actually meet.  Disable normalisation if your server has similar scores at the end of every game.
  bRelativeNormalisation=True       // During normalisation, the target average will be relative to the current strengths of players in the game.  So if you played against strong players, the strength you gain/lose will reflect this.
  bScalePlayerScoreToFullTime=True  // Should be True to make normalisation (score comparison) work properly, when some players have joined the game late.  Players strength records will still only be updated relative to the time they spent playing.
  NormalisedStrength=50
  UnknownStrength=45      // New player records start with an initial strength of 50 (Should be the same as NormalisedStrength.  Otherwise it should be the average endgame-score-per-hour/4 of new players on your server.  Actually maybe it should be the *mode*, which on my server tends to be around 45.
  BotStrength=10          // maybe 20 or 30 is better, if you disable normalisation, or increase NormaliseScore
  FlagStrength=10         // If it's 3:0, the winning team will appear to have an extra 30 points of strength; used for mid-game balancing.  Now auto-adjusts for non-CTF gametypes.  20 is a reasonably strong setting, 0 of course has no effect.
  StrengthThreshold=150   // If bWarnMidGameUnbalance and team strength difference is greater than this and stronger team has more players, warns all players of team inbalance.  (Some threshold was needed, otherwise any player which switched to the smaller team would just make it look unbalanced the other way, causing never-ending team-unbalance warning!  In theory this might still happen with players whose strength exceeds the threshold, in which case increase the threshold, or disable bWarnMidGameUnbalance)
  WinningTeamBonus=0      // Maybe you scored low, but played good teamplay, so your team won, and you deserve higher strength for that.  Recommended values: 0/5/10
  bClanWar=False          // For clan wars; on player login, or game start, make teams by clan tag
  clanTag="XOL"           // Clan tag of red team (all other players are sent to blue)
  bUseOnlyInGameScoresForRebalance=False     // Mid-game balancing usually looks up player records to see their strengths.  If you feel this causes lag on the server when a new player joins, or you only want to balance using current game scores anyway, then set this to True.
  bLogFakenickers=False        // Write to log any players who had a previous record with a different nick or IP.
  bBroadcastFakenickers=False  // Broadcast to game any players who had a previous record with a different nick or IP.
  #ifdef ENABLE_USEISPNOTFULLIP
  bUseISPNotFullIP=False        // Many ISPs regularly assign players with a new IP.  Enabling this option will strip the last two numbers of each player's IP address, to reveal their ISP only.  Disadvantage: more likely to incorrectly match a different player from the same ISP when player changes nick.  TODO: probably better to keep full IP to detect when a player has changed nick, but ignore the last two digits to detect when a player has changed IP.  I.e. smth like: if nick match is found, ignore last two digits of IP, but if no nick match is found, look for full IP.  So what if a player changes nick and last 2 digits of IP?  If they are the only player on that ISP, then match to that record, otherwise create a new one I guess.
  #endif
  #ifdef ENABLE_MUTATOR_SIGNATURE
  bSeparateStatsByGamemode=False
  bSeparateStatsByMutators=False
  #endif
  MaxPlayerData=4096
}





// ==== Hooks or overrides - functions and events called externally: ==== //

// Initialize the system
function PostBeginPlay() {

  Super.PostBeginPlay();

  if (initialized) {
    if (bDebugLogging) { Log(Self$".PostBeginPlay() called with initialized already true; quitting."); }
    return;
  }

  if (bDebugLogging) { Log(Self$".PostBeginPlay() initialising"); }

  // If AutoTeamBalance was installed as a ServerActor, we need to register it as a mutator:
  // AddMutator() will check that it is not already in the mutator chain.
  Level.Game.BaseMutator.AddMutator(Self);
  if (initialized) {
    if (bDebugLogging) { Log(Self$".PostBeginPlay() disabling self on request"); }
    gameStartDone=True;
    Disable('Tick');
    return;
  }
  if (bDebugLogging) { Log(Self$".PostBeginPlay() added self as mutator"); }

  // TODO TEST: When I was testing both ServerActor and mutator, it seemed "!teams" was not working

  // We always want to register as a messenger, so that players may type "!red" or "!blue"
  Level.Game.RegisterMessageMutator(Self);
  if (bDebugLogging) { Log(Self$".PostBeginPlay() registered self as messenger"); }

  // This is how we detect the moment just before game-start (in CheckGameStart()), to do a final team balance:
  SetTimer(1,True);

  gameEndDone = false; // Kinda redundant, since it will have been default initialised to false anyway.

  CopyConfigIntoArrays();  // First time the data is needed, we must convert it.

  initialized = true;

}

// Implementation of AddMutator which prevents double or recursive adding:
function AddMutator(Mutator Other) {
  if (bDebugLogging) { Log(Self$".AddMutator("$Other$") called."); }
  if (Other != None && Other.Class == Self.Class) {
    if (Other == Self) {
      if (bDebugLogging) { Log(Self$".AddMutator("$Other$"): not adding mutator self again!"); }
    } else {
      if (bDebugLogging) { Log(Self$".AddMutator("$Other$"): destroying other instance with "$Other$".Destroy()"); }
      AutoTeamBalance(Other).initialized = true; // tell the other copy it should not initialize
      Other.Destroy(); // seems to do nothing useful; the mutator continues to run through PostBeginPlay().
    }
  } else {
    Super.AddMutator(Other);
  }
}

// Timer is initially set at 1 second to detect the moment before game-start for ForceFullTeamsRebalance().
// Then it is set to 10 seconds during play, to detect mid-game unbalance, if bWarnMidGameUnbalance or bForceEvenTeams is set.
// Also (after HandleEndGame() is called), it detects the real game end, and calls UpdateStatsAtEndOfGame().
event Timer() {
  if (!gameStartDone) CheckGameStart();
  if (gameStartDone) CheckGameEnd();
  if ((bWarnMidGameUnbalance || bForceEvenTeams) && gameStartDone && !gameEndDone && Level.Game.IsA('TeamGamePlus') && !DeathMatchPlus(Level.Game).bTournament) CheckMidGameBalance();
}

// If a new player joins a game which has already started, this will send him to the most appropriate ("weaker") team (based on summed strength of each team, plus capbonuses).
// This may cause a little lag on slow CPU servers when a new player joins, because it will search the whole database to find his record; if this is a problem, set bUseOnlyInGameScoresForRebalance.
function ModifyLogin(out class<playerpawn> SpawnClass, out string Portal, out string Options) {
  local int selectedTeam;
  local int teamSize[2];
  local int teamSizeWithBots[2];
  local int teamStr[2]; // each team's strength, only used if the #players on each team is equal
  local int teamnr;
  local String plname;
  local Pawn p;
  local TournamentGameReplicationInfo GRI;

  if (NextMutator!= None) NextMutator.ModifyLogin(SpawnClass, Portal, Options);

  if (!ShouldBalance(Level.Game)) return;

  if (bDebugLogging) { Log("AutoTeamBalance.ModifyLogin("$SpawnClass$","$Portal$",\""$Options$"\")"); }

  // read this player's selected team
  selectedTeam=Level.Game.GetIntOption(Options,"Team",255);

  // get team scores
  GRI=TournamentGameReplicationInfo(Level.Game.GameReplicationInfo);
  teamStr[0]=GRI.Teams[0].Score*GetFlagStrength();
  teamStr[1]=GRI.Teams[1].Score*GetFlagStrength();
  teamSize[0]=0;
  teamSize[1]=0;
  teamSizeWithBots[0]=0;
  teamSizeWithBots[1]=0;

  // Check team balance of current players in game
  // Calculate sum of player strengths for each team (as well as the flagbonus above)
  for (p=Level.PawnList; p!=None; p=p.NextPawn)
  {
    // ignore non-player pawns
    if (p.bIsPlayer && !p.IsA('Spectator'))
    {
      teamnr=p.PlayerReplicationInfo.Team;
      if (teamnr<2)
      {
        // I changed this from Daniel's version, so that bot strengths are not considered.
        // Since a player is joining, one of the bots will probably leave, so counting that bot's strength is inaccurate, and we don't know which bot it will be.  So let's just count player strengths.
        if (!p.IsA('Bot')) {
          teamSize[teamnr]++;
          teamStr[teamnr] += GetPawnStrength(p);
        }
        teamSizeWithBots[teamnr]++;
      }
    }
  }

  if (bClanWar)
  {

    // send player to his clan's team
    teamnr=0;
    plname=Level.Game.ParseOption(Options,"Name");
    if (Instr(Caps(plname),Caps(clanTag))==-1) teamnr=1;

  } else {

    // if both teams have the same number of players send the new player to the weaker team
    if (teamSize[0]==teamSize[1])
    {
      // teamnr=0; if (teamStr[0]>teamStr[1]) teamnr=1;
      teamnr=0; if (teamStr[0]>=teamStr[1]+Rand(2)) teamnr=1;
      if (bDebugLogging) { Log("AutoTeamBalance.ModifyLogin(): "$teamSize[0]$"v"$teamSize[1]$" and "$teamStr[0]$"v"$teamStr[1]$" so sending new player to WEAKER team "$getTeamName(teamnr)$"."); }
    } else {
      // send player to the team with fewer players
      // teamnr=0; if (teamSize[0]>teamSize[1]) teamnr=1;
      teamnr=0; if (teamSize[0]>=teamSize[1]+Rand(2)) teamnr=1;
      if (bDebugLogging) { Log("AutoTeamBalance.ModifyLogin(): "$teamSize[0]$"v"$teamSize[1]$" so sending new player to SMALLER team "$getTeamName(teamnr)$"."); }
    }

  }

  // if selected team does not equal forced team then modify login
  if (teamnr!=selectedTeam) Options="?Team=" $ teamnr $ Options;

  // fix teamsize bug in Botpack.TeamGamePlus
  if (GRI.Teams[0].Size!=teamSizeWithBots[0] || GRI.Teams[1].Size!=teamSizeWithBots[1])
  {
    if (bDebugLogging) { Log("AutoTeamBalance.ModifyLogin(): Fixing team size (" $ GRI.Teams[0].Size $ "," $ GRI.Teams[1].Size $ ") should be (" $ teamSizeWithBots[0] $ "," $ teamSizeWithBots[1] $ ")"); }
    GRI.Teams[0].Size=teamSizeWithBots[0];
    GRI.Teams[1].Size=teamSizeWithBots[1];
  }

}

// We use MutatorTeamMessage and MutatorBroadcastMessage to catch messages said by players and spectators respectively.

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, out coerce string Msg, optional bool bBeep, out optional name Type) {
  if (Sender == Receiver && Sender.IsA('Spectator')) { // Only process the message once.
    if (bDebugLogging) { Log("AutoTeamBalance.MutatorBroadcastMessage() Checking ("$Sender$" -> "$Receiver$") "$Msg$""); }
    // Spectator messages start with the extra "<nick>:".  We remove this.
    CheckMessage(Mid(Msg,InStr(Msg,":")+1), Sender);
  }
  return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type);
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
  if (Sender == Receiver) { // Only process the message once.
    if (bDebugLogging) { Log("AutoTeamBalance.MutatorTeamMessage() Checking ("$Sender$" -> "$Receiver$") "$Msg$""); }
    CheckMessage(Msg, Sender);
  }
  return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

// Catch mutate messages (from players, semi-admins or admins)
function Mutate(String str, PlayerPawn Sender) {

  local String args[256];
  // local array<String> args;
  local int argcount;

  local String localPass; // the password we will require for semi-admin commands
  local String pass_if_needed; // for the help (to display whether pass is needed or not)

  local String msg;
  local int i;

  local Pawn p;

  local bool bTempBool;

  if (bDebugLogging) { Log("AutoTeamBalance.Mutate("$str$","$sender$") was called."); }

  if (Sender.bAdmin)
    localPass = ""; // any or no pass is accepted
  else if (SemiAdminPass == "defaults_to_admin_pass")
    localPass = ConsoleCommand("get engine.gameinfo AdminPassword");
  else
    localPass = SemiAdminPass;

  argcount = SplitString(str," ",args);

  // Commands which do not require a password:

  if ( args[0]~="STRENGTHS" || args[0]~="STRENGTH" ) {

      for (p=Level.PawnList; p!=None; p=p.NextPawn) {
        if (AllowedToBalance(p)) {
          // Sender.ClientMessage(p.getHumanName()$" has strength "$GetPawnStrength(p));
          i = FindPlayerRecord(p);
          if (i > -1) {
            Sender.ClientMessage(p.getHumanName()$" has strength "$Int(avg_score[i])$" after "$Left(""$hours_played[i],5)$" hours.");
          }
        }
      }
      Sender.ClientMessage("Red team strength is "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$".");
      Sender.ClientMessage("Flag bonus this game is "$GetFlagStrength()$".");

  }

  // Commands which do require the password:

  if (localPass=="" || args[argcount-1]~=localPass) { // Semi-admin privilege commands:

    switch ( Caps(args[0]) ) {

      case "TEAMS":
        if (!Level.Game.GameReplicationInfo.bTeamGame) {
          Sender.ClientMessage("AutoTeamBalance cannot balance teams: this isn't a team game!");
        } else {
          MidGameRebalance();
        }
      break;

      case "FORCETEAMS":
        // Sender.ClientMessage("AutoTeamBalance performing full teams rebalance...");
        // if (bBroadcastStuff) { BroadcastMessageAndLog(Sender.getHumanName()$" has forced a full teams rebalance."); }
        // To make this balance as accurate as possible, we update the stats now, so we can use the scores from this game so-far.
        // But since this would mess up the end-game stats updating (counting this part of the game twice), we restore the stats from the config afterwards.
        UpdateStatsAtEndOfGame();
        ForceFullTeamsRebalance();
        CopyConfigIntoArrays();
      break;

      case "TORED":
        // if (bBroadcastStuff) { BroadcastMessageAndLog(Sender.getHumanName()$" is trying to fix the teams."); }
        ChangePlayerToTeam(FindPlayerNamed(args[1]),0,true);
        Sender.ClientMessage("Red team strength is now "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$".");
      break;

      case "TOBLUE":
        // if (bBroadcastStuff) { BroadcastMessageAndLog(Sender.getHumanName()$" is trying to fix the teams."); }
        ChangePlayerToTeam(FindPlayerNamed(args[1]),1,true);
        Sender.ClientMessage("Red team strength is now "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$".");
      break;

      case "TOGREEN":
        ChangePlayerToTeam(FindPlayerNamed(args[1]),2,true);
        Sender.ClientMessage("Red team strength is now "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$".");
      break;

      case "TOGOLD":
        ChangePlayerToTeam(FindPlayerNamed(args[1]),3,true);
        Sender.ClientMessage("Red team strength is now "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$".");
      break;

      case "SWITCH":
        SwitchTwoPlayers(Sender,args[1],args[2]);
      break;

      case "SWAP":
        SwitchTwoPlayers(Sender,args[1],args[2]);
      break;

      case "WARN":
        msg=""; for (i=2;i<argcount;i++) { if (!(args[i]~=localPass)) msg = msg $ args[i] $ " "; } // hack to rebuild args without password
	p = FindPlayerNamed(args[1]);
        FlashMessageToPlayer(p,msg);
        p.ShakeView(3.0,8000.0,12000.0);
        Sender.ClientMessage("I warned "$p.getHumanName()$" with the message \""$msg$"\".");
      break;

      case "KICK":
        if (bAllowSemiAdminKick) {
          msg=""; for (i=2;i<argcount;i++) { if (!(args[i]~=localPass)) msg = msg $ args[i] $ " "; } // hack to rebuild args without password
	  p = FindPlayerNamed(args[1]);
          FlashMessageToPlayer(p,msg);
          // If the player is a semi-admin, but not admin, we must temporarily make him an admin, for this to run successfully:
          bTempBool = Sender.bAdmin;
          Sender.bAdmin = True;
          Sender.Kick(p.getHumanName());
          Sender.bAdmin = bTempBool;
        }
      break;

      case "KICKBAN":
        if (bAllowSemiAdminKick) {
          msg=""; for (i=2;i<argcount;i++) { if (!(args[i]~=localPass)) msg = msg $ args[i] $ " "; } // hack to rebuild args without password
	  p = FindPlayerNamed(args[1]);
          FlashMessageToPlayer(p,msg);
          // If the player is a semi-admin, but not admin, we must temporarily make him an admin, for this to run successfully:
          bTempBool = Sender.bAdmin;
          Sender.bAdmin = True;
          Sender.KickBan(p.getHumanName());
          Sender.bAdmin = bTempBool;
        }
      break;

      case "FORCETRAVEL":
        if (bAllowSemiAdminForceTravel) {
          //// We may not want to publicise the password of the server we are forwarding to.  (e.g. server may have an irc reporter)
          // if (bBroadcastStuff) { BroadcastMessageAndLog("Admin has forced a Server Travel to: "$args[1]); }
          if (bBroadcastStuff) { BroadcastMessageAndLog("Admin is forcing a server switch!"); }
          for (p=Level.PawnList; p!=None; p=p.NextPawn) {
            if (p.IsA('PlayerPawn')) { // yes we forward spectators too!
              PlayerPawn(p).PreClientTravel();
              PlayerPawn(p).ClientTravel(args[1], TRAVEL_Absolute, False);
            }
          }
        }
      break;

      Default:
      break;

    }

  }

  #ifdef ENABLE_ADMIN_COMMANDS

  // Admin only commands:
  // These are not really needed for AutoTeamBalance, but useful commands nonetheless.
  // I especially like to use "mutate set" instead of "admin set", since it provides feedback on whether or not the variable existed, and was successfully written!  "mutate get" can be used beforehard, to check the value of the variable.
  if (Sender.bAdmin) {

    switch ( Caps(args[0]) ) {

      // Allows admins to read variables from the config files (and maybe some live variables too; untested)
      case "GET":
        Sender.ClientMessage( args[1] $ ":" $ args[2] $ " = " $ ConsoleCommand("get " $ args[1] $ " " $ args[2]) );
      break;

      // Allows admins to write to config variables (probably equivalent to: admin set <package> <name> <value>)
      case "SET":
        ConsoleCommand("set " $ args[1] $ " " $ args[2] $ " " $ args[3]);
        Sender.ClientMessage( args[1] $ ":" $ args[2] $ " = " $ ConsoleCommand("get " $ args[1] $ " " $ args[2]) );
      break;

      case "GETPROP":
        Sender.ClientMessage( args[1] $ " = " $ GetPropertyText(args[1]) );
      break;

      // Allows admins to write to in-game variables
      case "SETPROP":
        SetPropertyText(args[1],args[2]);
        Sender.ClientMessage( args[1] $ " = " $ GetPropertyText(args[1]) );
        Sender.ClientMessage(args[1] $ " = " $ ConsoleCommand("get " $ args[1] $ " " $ args[2])); // read it back to the user, to check it worked
      break;

      // Allows admins to run any console command on the server
      case "CONSOLE":
        msg=""; for (i=2;i<argcount;i++) { if (!(args[i]~=localPass)) msg = msg $ args[i] $ " "; } // hack to rebuild args without password
        Sender.ClientMessage( "" $ ConsoleCommand(msg) );
      break;

      case "SAVECONFIG":
        UpdateStatsAtEndOfGame();
        CopyArraysIntoConfig();
        SaveConfig();
        // CopyConfigIntoArrays(); // If the game ends after this, we will re-do this time period, but damn we can't copy back now
      break;

      case "GRANTADMIN":
        ToggleAdminOnPlayer( FindPlayerNamed(args[1]) );
        Sender.ClientMessage("Admin toggled on "$FindPlayerNamed(args[1]).getHumanName()$".");
      break;

      Default:
      break;

    }

  }

  #endif

  if ( args[0]~="HELP" ) {
    if (localPass == "")
      pass_if_needed = "";
    else
      pass_if_needed = " [password]";
    Sender.ClientMessage("AutoTeamBalance say commands:");
    if (bEnablePlayerCommands) {
      Sender.ClientMessage("    teams !teams !red !blue !spec !play !vote !stats");
    } else {
      Sender.ClientMessage("    teams !teams");
    }
    Sender.ClientMessage("AutoTeamBalance console commands:");
    Sender.ClientMessage("    mutate strengths"); // also just "strength"
    Sender.ClientMessage("AutoTeamBalance semi-admin commands:");
    Sender.ClientMessage("    mutate teams" $ pass_if_needed);
    Sender.ClientMessage("    mutate forceteams" $ pass_if_needed);
    Sender.ClientMessage("    mutate tored <player>" $ pass_if_needed);
    Sender.ClientMessage("    mutate toblue <player>" $ pass_if_needed);
    Sender.ClientMessage("    mutate switch <player> <player>" $ pass_if_needed);
    Sender.ClientMessage("    mutate warn <player> <message>" $ pass_if_needed);
    if (bAllowSemiAdminKick) {
      Sender.ClientMessage("    mutate kick <player> [<reason>]" $ pass_if_needed);
      Sender.ClientMessage("    mutate kickban <player> [<reason>]" $ pass_if_needed);
    }
    if (bAllowSemiAdminForceTravel) {
      Sender.ClientMessage("    mutate forcetravel <url>" $ pass_if_needed);
    }
    #ifdef ENABLE_ADMIN_COMMANDS
    if (Sender.bAdmin) {
      Sender.ClientMessage("AutoTeamBalance admin-only commands:");
      Sender.ClientMessage("    mutate saveconfig");
      Sender.ClientMessage("    mutate grantadmin <player>");
      Sender.ClientMessage("    mutate get <package> <variable>");
      Sender.ClientMessage("    mutate set <package> <variable> <new_value>");
      Sender.ClientMessage("    mutate getprop <variable>");
      Sender.ClientMessage("    mutate setprop <variable> <new_value>");
      Sender.ClientMessage("    mutate console <command>");
    }
    #endif
  }

  Super.Mutate(str,Sender);
}

function SwitchTwoPlayers(PlayerPawn sender, String name1, String name2) {
  local Pawn player1, player2;
  local int newteam1, newteam2;
  player1 = FindPlayerNamed(name1);
  player2 = FindPlayerNamed(name2);
  if (player1 == None) {
    Sender.ClientMessage("Could not find player \""$name1$"\".");
    return;
  }
  if (player2 == None) {
    Sender.ClientMessage("Could not find player \""$name2$"\".");
    return;
  }
  if (player1.PlayerReplicationInfo.Team == player2.PlayerReplicationInfo.Team) {
    Sender.ClientMessage("Players \""$player1.getHumanName()$"\" and \""$player2.getHumanName()$"\" are on the same team!");
    return;
  }
  newteam1 = player2.PlayerReplicationInfo.Team;
  newteam2 = player1.PlayerReplicationInfo.Team;
  ChangePlayerToTeam(player1,newteam1,true);
  ChangePlayerToTeam(player2,newteam2,true);
}

function ToggleAdminOnPlayer(Pawn p) {
  local PlayerPawn player;
  if (p!=None && p.IsA('PlayerPawn')) {
    player = PlayerPawn(p);
    player.bAdmin = !player.bAdmin;
    player.PlayerReplicationInfo.bAdmin = player.bAdmin;
  }
}

// HandleEndGame gets called when the game time limit expires, BUT the game may go into overtime without us knowing (one of the earlier mutators, or the gametype itself, might decide this).
// So at this point I set a Timer to check in 10 seconds whether the game really has ended or not.
// DONE: if not needed for bWarnMidGameUnbalance or bForceEvenTeams, the timer is disabled after one check, then we wait for this function to get called again before it is started again.
function bool HandleEndGame() {
  local bool b;

  SetTimer(10,bWarnMidGameUnbalance || bForceEvenTeams); // only loop if we need to check team balance during overtime; if we are only looking for the real end-game, then we only need to use the timer once more
  if (bDebugLogging) { Log("AutoTeamBalance.HandleEndGame(): Set Timer() for 10 seconds. [bOverTime="$Level.Game.bOverTime$",bGameEnded="$Level.Game.bGameEnded$"]"); }

  if ( NextMutator != None ) {
    b = NextMutator.HandleEndGame();
    return b;
  }
  return false;
}



// =========== Our State Model =========== //

// Checks if the game has begun.
function CheckGameStart() {
  local int c,n,e;

  // We can disable the timer immediately, if AutoTeamBalance is not needed for this game.
  // If we are going to balance, then the timer waits until 2 seconds before the game starts.
  // If we are going to update stats, we need to record the time the game actually started at, so we wait the same way.
  if (!ShouldBalance(Level.Game) && !ShouldUpdateStats(Level.Game)) { // We do this early, to check at the very least that this is a teamgame, to avoid accessed none's below
    DoGameStart();
    return;
  }

  // TODO BUG: if bUpdatePlayerStatsForNonTeamGames is enabled, then on DM maps, we reach here and throw some Accessed None errors.
  //           But we still want the game start-time.
  e = TeamGamePlus(Level.Game).ElapsedTime; // after the first player joins, appears to count up to NetWait, then game starts, and once all the bots join, it stops increasing
  n = TeamGamePlus(Level.Game).NetWait;
  c = TeamGamePlus(Level.Game).countdown; // appears to stay fixed at 10, but daniel checked it
  // should never get logged:
  if (gameStartDone && bDebugLogging) { Log("AutoTeamBalance.CheckGameStart(): c="$c$" n="$n$" e="$e$" t="$Level.TimeSeconds$""); }
  c = Min(c,n-e); // My theory: ElapsedTime starts counting up from 0 as soon as a player enters the server (altho it stops on 9!), but the game won't start until NetWait and/or Countdown seconds have passed.

  // BUG: This can occasionally get called twice within one second (when the Timer was set to 1 second).
  // BUG: Also gets called at 0.
  // if (bBroadcastStuff && (n-e)<n && ((n-e)/10*10)==(n-e) && (n-e)>0) {
    // // BroadcastMessage((n-e)$" seconds until game starts...");
    // BroadcastMessage((n-e)$" seconds until game starts...",True,'CriticalEvent');
  // }

  // Initialize teams 1 or 2 seconds before the game starts:
  // NOTE: when i set NetWait to 1 for testing, I think this 2 caused the ForceFullTeamsRebalance to happen before any bots or players had entered the game.  With NetWait 5 it seems ok.  So BUG: Do not set your NetWait below 3!
  if (c<2) {
    DoGameStart();
  }

}

function DoGameStart() {
  timeGameStarted = Level.TimeSeconds+1.5; // (since we are called on average 1.5 seconds before starting countdown ends)
  if (ShouldBalance(Level.Game)) {
    //// TESTING: how well can we do by just switching 1 or 2 players?
    // if (bTesting) { lastBalanceTime=0; MidGameRebalance(); }
    // if (bTesting) { lastBalanceTime=0; MidGameRebalance(); }
    // if (bTesting) { lastBalanceTime=0; MidGameRebalance(); }
    //// We could also do this once or twice *after* the ForceFullTeamsRebalance(), to make teams really even by strength (not pickup style).
    ForceFullTeamsRebalance();
  }
  gameStartDone=True; // Should ensure CheckGameStart() is never called again.
  Disable('Tick');
  // We disable the timer, if it is not needed to check mid-game teambalance.
  // HandleEndGame() will set it again, if it is needed for CheckGameEnd().
  if (bWarnMidGameUnbalance || bForceEvenTeams) {
    SetTimer(10,True); // the frequency of the "uneven teams" bleep is 10 seconds, but we also don't want to wait any longer than this after the end of the game, in case the map changes before we detect the game-end and update the stats.
  } else {
    SetTimer(0,False);
  }
}

// Deals with mid-game team unbalance, only called if bForceEvenTeams and/or bWarnMidGameUnbalance are set.
function CheckMidGameBalance() {
  local int redTeamCount,blueTeamCount;
  local int redTeamStrength,blueTeamStrength;
  local int weakerTeam;
  local String problem; // human-readable explanation of the team unbalance
  local Pawn p;
  weakerTeam = -1;
  redTeamCount = GetTeamSize(0);
  blueTeamCount = GetTeamSize(1);

  // Is one of the teams down 2 or more players?
  if (redTeamCount>=blueTeamCount+2) {
    weakerTeam = 1; problem=""; // problem = " ("$redTeamCount$"v"$blueTeamCount$") ";
  }
  if (redTeamCount<=blueTeamCount-2) {
    weakerTeam = 0; problem=""; // problem = " ("$redTeamCount$"v"$blueTeamCount$") ";
  }

  // If so, and bForceEvenTeams is set, then take action!
  if (bForceEvenTeams && weakerTeam != -1) {
    MidGameRebalance();
    return;
    // bForceEvenTeams does *not* take action if the teams differ by less than 2 players.
  }

  // Do we want to warn players of any inbalance?
  if (bWarnMidGameUnbalance) {

    if (weakerTeam == -1 && redTeamCount+blueTeamCount>=3) { // no point checking this on a 1v1 ;)
      // So teams differ by <2 players.  Now calculate which team is weaker, and check if that team has fewer players:
      redTeamStrength = GetTeamStrength(0);
      blueTeamStrength = GetTeamStrength(1);
      if (redTeamCount>blueTeamCount && redTeamStrength>blueTeamStrength+StrengthThreshold) {
        weakerTeam = 1; problem = " (strength "$redTeamStrength$" v "$blueTeamStrength$") ";
      }
      if (redTeamCount<blueTeamCount && blueTeamStrength>redTeamStrength+StrengthThreshold) {
        weakerTeam = 0; problem = " (strength "$redTeamStrength$" v "$blueTeamStrength$") ";
      }
    }
    // TODO: So note, we never warn of strength inbalance if #players is the same - maybe we should :P

    if (weakerTeam == -1) {
      return;
    }

    // Send all players the team inbalance warning:
    for (p=Level.PawnList; p!=None; p=p.NextPawn) {
      if (p.IsA('PlayerPawn') && !p.IsA('Spectator')) {
	// Players on different teams get slightly different messages:
        if (p.PlayerReplicationInfo.Team == weakerTeam) {
          if (bLetPlayersRebalance) {
            p.ClientMessage("Teams look uneven! "$problem$" Type !teams to fix them",ConditionalName(bFlashOnWarning,'CriticalEvent','Event'),False);
          }
        } else {
          p.ClientMessage("Teams look uneven! "$problem$" Type "$ConditionalString(bLetPlayersRebalance,"!teams or ","")$"!"$Locs(getTeamName(weakerTeam))$"",ConditionalName(bFlashOnWarning,'CriticalEvent','Event'),False);
	  // We may "punish" the stronger team, by shaking their view, or sending them a buzzing sound:
          if (bShakeOnWarning) {
            p.ShakeView(1.0,2000.0,2000.0);
          }
          if (bBuzzOnWarning) {
            p.PlaySound(sound'FlyBuzz', SLOT_Interface, 2.5, False, 32, 16); // an annoying buzzing fly sound
          }
        }
      }
    }
  }
}

function String ConditionalString(bool b, String yes, String no) {
  if (b) { return yes; } else { return no; }
}

function name ConditionalName(bool b, name yes, name no) {
  if (b) { return yes; } else { return no; }
}

function CheckGameEnd() {
  if (Level.Game.bGameEnded) {
    if (gameEndDone) return;
    gameEndDone = true;
    // We could (but don't) turn the Timer off now
    if (ShouldUpdateStats(Level.Game)) {
      UpdateStatsAtEndOfGame();
      CopyArraysIntoConfig();
      SaveConfig();
    }
  }
}

function bool CheckMessage(String Msg, Actor Sender) {

  // if (Msg ~= "!HELP") {
    // PlayerPawn(Sender).ClientMessage("Commands are: !teams !red !blue !spec !play !vote !stats");
  // }

  if (bEnablePlayerCommands) {

    if (Msg ~= "!RED") {
      ChangePlayerToTeam(PlayerPawn(Sender),0,false);
    }

    if (Msg ~= "!BLUE") {
      ChangePlayerToTeam(PlayerPawn(Sender),1,false);
    }

    if (Msg ~= "!GREEN") {
      ChangePlayerToTeam(PlayerPawn(Sender),2,false);
    }

    if (Msg ~= "!GOLD" || Msg ~= "!YELLOW") {
      ChangePlayerToTeam(PlayerPawn(Sender),3,false);
    }

    if (Msg ~= "!SPEC" || Msg ~= "!SPECTATE") {
      if (!Sender.IsA('Spectator')) {
        PlayerPawn(Sender).PreClientTravel(); // not sure if this is actually needed
        PlayerPawn(Sender).ClientTravel("?OverrideClass=Botpack.CHSpectator",TRAVEL_Relative, False);
      }
    }

    if (Msg ~= "!PLAY") {
      if (Sender.IsA('Spectator')) {
        PlayerPawn(Sender).PreClientTravel(); // not sure if this is actually needed
        PlayerPawn(Sender).ClientTravel("?OverrideClass=",TRAVEL_Relative, False);
      }
    }

    if (Msg ~= "!VOTE" || Msg ~= "!MAPVOTE") {
      Level.Game.BaseMutator.Mutate("bdbmapvote votemenu",PlayerPawn(Sender));
    }

    if (Msg ~= "!STATS") { 
      Level.Game.BaseMutator.Mutate("smartctf stats",PlayerPawn(Sender));
    }

  }

  if (Msg ~= "TEAMS" || Msg ~= "!TEAMS") {
    if (bLetPlayersRebalance && !DeathMatchPlus(Level.Game).bTournament) {
      if (bDebugLogging) { Log("AutoTeamBalance.MutatorTeamMessage(): Calling MidGameRebalance()."); }
      RequestMidGameRebalance(PlayerPawn(Sender));
    }
  }

}



// =========== Balancing Algorithms =========== //

// Also see ModifyLogin() above, for the decision of which team to send a player to when they join a running game.

// Balance the teams just before the start of a new game.  No need for FlagStrength here.
// It can also be forced by a semi-admin mid-game, using "mutate forceteams".
// In this case, it doesn't check which players are holding flags.
function ForceFullTeamsRebalance() {
  local Pawn p;
  local int st;
  local int pid;
  local Pawn pl[64]; // hashmap of playerpawns, with i = PlayerID%64
  local int ps[64]; // their strengths
  local int moved[64]; // so 0=false 1=true :P
  local int plorder[32];
  local int i;
  local int n;
  local int mx;
  local int teamnr;
  local int teamstr[2];
  local TeamGamePlus g; // my linux ucc make had trouble with TeamGamePlus :|
  local int oldMaxTeamSize;
  local bool oldbPlayersBalanceTeams, oldbNoTeamChanges;

  // We can't balance if it's not a teamgame
  if (!Level.Game.GameReplicationInfo.bTeamGame) return;

  if (bDebugLogging) { Log("AutoTeamBalance.ForceFullTeamsRebalance(): Running..."); }
  if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance is attempting to balance the teams..."); }

  // rate all players, and put them in a temporary structure:
  for (p=Level.PawnList; p!=None; p=p.NextPawn)
  {
    if (AllowedToBalance(p))
    {
      st=GetPawnStrength(p);
      pid=p.PlayerReplicationInfo.PlayerID % 64;
      pl[pid]=p;
      ps[pid]=st;
      moved[pid] = 0;
      if (bDebugLogging) { Log("AutoTeamBalance.ForceFullTeamsRebalance(): Player " $ p.getHumanName() $ " on team " $ p.PlayerReplicationInfo.Team $ " has ip " $ getIP(p) $ " and score " $ p.PlayerReplicationInfo.Score $ "."); }
    }
  }

  // sort players by strength (move them out of the structure, into plorder[])
  n=0;
  do
  {
    pid=-1;
    mx=0;
    // find pid=i with max tg[i]
    for (i=0; i<64; i++)
    {
      // Is this the strongest not-yet-moved player in this cycle?
      if ( pl[i] != None && moved[i]==0 && (pid == -1 || ps[i]>mx) ) {
        pid=i;
        mx=ps[i];
      }
    }
    // If we found one, add him as the next player in the list
    if (pid != -1) {
      plorder[n]=pid;
      // ps[pid]=0;
      moved[pid] = 1;
      n++;
      if (bDebugLogging) { Log("AutoTeamBalance.ForceFullTeamsRebalance(): [Ranking] "$ps[pid]$" "$ pl[pid].getHumanName() $""); }
    }
  } until (pid==-1);

  // save team changing rules before we override them
  g=TeamGamePlus(Level.Game);
  oldMaxTeamSize=g.MaxTeamSize;
  oldbPlayersBalanceTeams=g.bPlayersBalanceTeams;
  oldbNoTeamChanges=g.bNoTeamChanges;

  // deactivate team changing rules
  g.MaxTeamSize=32;
  g.bPlayersBalanceTeams=False;
  g.bNoTeamChanges=False;

  if (bClanWar)
  {

    // rebuild teams by clan tags
    teamstr[0]=0;
    teamstr[1]=0;
    for (i=0; i<n; i++)
    {
      pid=plorder[i];
      teamnr=0;
      if (Instr(Caps(pl[pid].PlayerReplicationInfo.Playername),Caps(clanTag))==-1) teamnr=1;
      ChangePlayerToTeam(pl[pid],teamnr,gameStartDone && !gameEndDone);
      teamstr[teamnr]+=ps[pid];
    }

  } else {

    // Rebuild teams by strength, assigning in order: red-blue-blue-red-red-blue-blue-...
    // (On the way we also calculate total team strengths)
    teamstr[0]=0;
    teamstr[1]=0;
    for (i=0; i<(n&254); i++)
    {
      pid=plorder[i];
      teamnr=0;
      if ((i&3)==1 || (i&3)==2) teamnr=1;
      if (bDebugLogging) { Log("AutoTeamBalance.ForceFullTeamsRebalance(): i="$i$" Putting pid="$pid$" pl="$pl[pid].getHumanName()$" into team "$teamnr$"."); }
      ChangePlayerToTeam(pl[pid],teamnr,gameStartDone && !gameEndDone);
      teamstr[teamnr]+=ps[pid];
    }

    // if there is an odd number of players put the last player in the weaker team
    if ((n&1)==1)
    {
      pid=plorder[i];
      teamnr=0; if (teamstr[0]>=teamstr[1]+Rand(2)) teamnr=1;
      if (bDebugLogging) { Log("AutoTeamBalance.ForceFullTeamsRebalance(): "$n$" is odd so sending last player to WEAKER team "$teamnr$"."); }
      ChangePlayerToTeam(pl[pid],teamnr,gameStartDone && !gameEndDone);
      teamstr[teamnr]+=ps[pid];
    }

  }

  // restore team changing rules
  g.MaxTeamSize=oldMaxTeamSize;
  g.bPlayersBalanceTeams=oldbPlayersBalanceTeams;
  g.bNoTeamChanges=oldbNoTeamChanges;

  // Show team strengths to all players
  if (bBroadcastStuff) { BroadcastMessageAndLog("Red team strength is " $ teamstr[0] $ ".  Blue team strength is " $ teamstr[1] $ "."); }

  // At game start, tell each player how many cookies they have
  if (!gameStartDone) {
    // (This must come after the team switching, otherwise the default start-game "xxx is on Red" will overwrite this text.)
    // TODO CONSIDER BUG: isn't it more important that the player sees which team they were moved to?!
    for (p=Level.PawnList; p!=None; p=p.NextPawn) {
      if (bFlashCookies && p.IsA('PlayerPawn') && !p.IsA('Spectator')) {
        FlashMessageToPlayer(p, p.getHumanName() $", you have "$ GetPawnStrength(p) $" cookies.");
      }
    }
  }

}

function RequestMidGameRebalance(PlayerPawn p) {
#ifdef ENABLE_MIN_REQUESTS_FOR_REBALANCE
  // TODO: we only really need to check MinRequestsForRebalance if teams are 4v4 or 4v3 - if teams are 3v5 then do it without checking
  local int i;
  local int countRequests;
  local int additionalRequiredRequests;
  // If the last request was a long time ago (>1 minute), reset the request list
  if (lastRebalanceRequestTime < Level.TimeSeconds - 60) {
    for (i=0;i<64;i++) {
      pidsRequestingRebalance[i] = 0;
    }
  }
  // Set that this player is requesting balance
  pidsRequestingRebalance[p.PlayerReplicationInfo.PlayerID] = 1;
  // Count the number of requests at this time
  countRequests = 0;
  for (i=0;i<64;i++) {
    if (pidsRequestingRebalance[i] != 0) {
      countRequests++;
    }
  }
  // Work out how many more requests are needed
  additionalRequiredRequests = MinRequestsForRebalance - countRequests;
  // if (countRequests < Int(CountHumanPlayers()*MinRequestsForRebalancePercent/100)) {
    // additionalRequiredRequests = Int(CountHumanPlayers()*MinRequestsForRebalancePercent/100) - countRequests;
  // }
  // Decide what to do
  if (additionalRequiredRequests <= 0) {
    MidGameRebalance();
    lastRebalanceRequestTime = -60; // Will force a reset the next time we are called
  } else {
    // BroadcastMessageAndLog("I require "$additionalRequiredRequests$" more requests before I will rebalance the teams.  Say \"!teams\" if you agree.");
    BroadcastMessageAndLog("Say \"!teams\" to rebalance the teams ("$additionalRequiredRequests$" more requests required).");
    lastRebalanceRequestTime = Level.TimeSeconds;
  }
#else
  MidGameRebalance();
#endif
}

function MidGameRebalance() {
  local int redTeamCount,blueTeamCount;

  if (!Level.Game.IsA('TeamGamePlus') || !Level.Game.bTeamGame)
    return;

  // Refuse to balance teams more than once every MinSecondsBeforeRebalance seconds:
  // This also fixed the bug that (I think) if the player who said "!teams" was switched, a second call to MutatorTeamMessage was made, and MidGameRebalance was getting called again.
  if (lastBalanceTime + MinSecondsBeforeRebalance > Level.TimeSeconds) {
    // if (bDebugLogging) { Log("MidGameRebalance() refusing to rebalance since lastBalanceTime="$lastBalanceTime$" is too close to current time "$Level.TimeSeconds); }
    if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance refuses to rebalance teams again so soon."); }
    return;
  }
  lastBalanceTime = Level.TimeSeconds;

  redTeamCount = GetTeamSize(0);
  blueTeamCount = GetTeamSize(1);
  // We assume bot skills are pretty much irrelevant, and the bots will auto-switch to balance teams after we move any players around.

  if (bDebugLogging) { Log("MidGameRebalance() "$redTeamCount$" v "$blueTeamCount$""); }

  // TODO: what if redTeamCount << blueTeamCount ?  e.g. it's 6v2 so we need to move two players.  we could balance in a while loop if it's guaranteed to end
  if (redTeamCount < blueTeamCount) {
    MidGameTeamBalanceSwitchOnePlayer(1,0);
  } else if (blueTeamCount < redTeamCount) {
    MidGameTeamBalanceSwitchOnePlayer(0,1);
  } else {
    MidGameTeamBalanceSwitchTwoPlayers();
  }

}

function bool MidGameTeamBalanceSwitchOnePlayer(int fromTeam, int toTeam) {
  local float fromTeamStrength, toTeamStrength, currentDifference, playerStrength;
  local Pawn p;
  local Pawn closestPlayer; // the most ideal potential player to switch
  local float newDifference; // the absolute strength difference between the two teams after the potential switch
  fromTeamStrength = GetTeamStrength(fromTeam);
  toTeamStrength = GetTeamStrength(toTeam);
  currentDifference = fromTeamStrength - toTeamStrength;
  if (currentDifference<0) {
    if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance refusing to help "$getTeamName(toTeam)$" because it is already stronger ("$Int(toTeamStrength)$">"$Int(fromTeamStrength)$")"); }
    return False;
  }
  // Find the player on fromTeam with strength closest to difference, and switch him/her
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (AllowedToBalance(p)
        && p.PlayerReplicationInfo.Team==fromTeam && p.PlayerReplicationInfo.HasFlag==None) {
      playerStrength = GetPawnStrength(p);
      if (closestPlayer == None || Abs(currentDifference-playerStrength*2) < newDifference) {
        closestPlayer = p;
        // Note we multiply playerStrength by 2 here, because switching him will cause -strength to fromTeam and +strength to toTeam.
        newDifference = Abs(currentDifference-playerStrength*2);
      }
    }
  }
  if (closestPlayer == None) {
    if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance could not find any player on "$getTeamName(fromTeam)$" to switch."); }
    return False;
  }
  if (newDifference >= currentDifference && !bForceEvenTeams) {
    if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance not switching "$closestPlayer.getHumanName()$" because that would make "$getTeamName(fromTeam)$" team too weak!"); }
    return False;
  } else {
    ChangePlayerToTeam(closestPlayer,toTeam,true);
    if (bBroadcastStuff) { BroadcastMessageAndLog("Red team strength is now "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$"."); }
    return True;
  }
}

function bool MidGameTeamBalanceSwitchTwoPlayers() {
  // initial:
  local float redTeamStrength, blueTeamStrength, difference;
  // during loop:
  local Pawn redP,blueP;
  local float redPStrength, bluePStrength;
  local float potentialNewDifference; // the strength difference between the two teams after switching these two players
  // best found:
  local Pawn redPlayerToMove,bluePlayerToMove; // the best two players found so far
  local float newdifference; // the strength difference between the two teams after switching these players

  redTeamStrength = GetTeamStrength(0);
  blueTeamStrength = GetTeamStrength(1);
  difference = blueTeamStrength - redTeamStrength; // positive implies Team 1 is stronger than Team 0
  newdifference = difference;

  // FIXED by "hashing": These repeated calls to GetPawnStrength() are going to be inefficient, possibly causing some lag while the server calculates.
  for (redP=Level.PawnList; redP!=None; redP=redP.NextPawn) {
    for (blueP=Level.PawnList; blueP!=None; blueP=blueP.NextPawn) {
      if (redP != blueP
          && redP.PlayerReplicationInfo.Team==0
          && blueP.PlayerReplicationInfo.Team==1
          && AllowedToBalance(redP)
          && AllowedToBalance(blueP)
          && redP.PlayerReplicationInfo.HasFlag == None
          && blueP.PlayerReplicationInfo.HasFlag == None
      ) {
        redPStrength = GetPawnStrength(redP);
        bluePStrength = GetPawnStrength(blueP);
        // Note we multiply playerStrength by 2 here, because switching him will cause -strength to fromTeam and +strength to toTeam.
        potentialNewDifference = blueTeamStrength + redPStrength*2 - redTeamStrength - bluePStrength*2;
        if (Abs(potentialNewDifference) < Abs(newdifference)) {
          newdifference = potentialNewDifference;
          redPlayerToMove = redP;
          bluePlayerToMove = blueP;
        }
      }
    }
  }

  // TODO: if one of the players is a bot, we should probably move him last, because bots tend to switch back to the other team, if UT.ini is configured that way.  Alternatively, we could copy Daniel's temporary-ut-balance-disable code into ChangePlayerToTeam.
  if (redPlayerToMove != None && bluePlayerToMove != None) {
    ChangePlayerToTeam(redPlayerToMove,1,true);
    ChangePlayerToTeam(bluePlayerToMove,0,true);
    if (bBroadcastStuff) { BroadcastMessageAndLog("Red team strength is now "$Int(GetTeamStrength(0))$", Blue team strength is "$Int(GetTeamStrength(1))$"."); }
    return True;
  } else {
    if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance could not find two switches to improve the teams."); }
    return False;
  }
}



// ======== Change game or message players: ======== //

function ChangePlayerToTeam(Pawn p, int teamnum, bool bInform) {
  if (teamnum == p.PlayerReplicationInfo.Team) {
    if (bDebugLogging) { Log("AutoTeamBalance.ChangePlayerToTeam("$p.getHumanName()$","$teamnum$"): doing nothing since player is already on team "$teamnum); }
    return;
  }
  if (p.IsA('Bot')) {
    Bot(p).ConsoleCommand("taunt wave");
  }
  if (bDebugLogging) { Log("AutoTeamBalance.ChangePlayerToTeam("$p.getHumanName()$"): "$p.PlayerReplicationInfo.Team$" -> "$teamnum); }
  Level.Game.ChangeTeam(p,teamnum);
  p.Died(None, '', p.Location); // Kills the player, forcing them to drop flag if they have it (before this we could get a red player holding the red flag!)
  if (bInform) {
    BroadcastMessage(p.getHumanName()$" has been moved to the "$getTeamName(teamnum)$" team.");
    FlashMessageToPlayer(p,"You have been moved to the "$getTeamName(teamnum)$" team for a fairer game.");
    p.ShakeView(2.0,2000.0,0.0);
  }
}

/* I want to Log all calls to BroadcastMessage() so that I can see without playing how much the players are getting spammed by broadcasts.
   Eventually, calls to BroadcastMessageAndLog could be turned back to just BroadcastMessage() calls. */
function BroadcastMessageAndLog(string Msg) {
  if (bDebugLogging) { Log("AutoTeamBalance Broadcasting: "$Msg); }
  BroadcastMessage(Msg);
}

function FlashMessageToPlayer(Pawn p, string Msg) {
  if (bDebugLogging) { Log("AutoTeamBalance Sending message to "$p.getHumanName()$": "$Msg); }
  // p.ClientMessage(Msg); // goes to chat and console
  // p.ClientMessage(Msg, 'Event', True); // TESTING (sends only to chat, or only to chat+console?)
  // p.ClientMessage(Msg, 'CriticalEvent', True); // goes to HUD and console
  p.ClientMessage(Msg, 'CriticalEvent', False); // goes to HUD and console, no beep
  p.PlaySound(sound'Beep', SLOT_Interface, 2.5, False, 32, 32); // we play our own sound
}



// ======== Library functions which do not change any state: ======== //

function bool ShouldBalance(GameInfo game) {

  // Never balance in tournament mode
  if (DeathMatchPlus(Level.Game).bTournament)
    return False;
  // We can't balance if it's not a teamgame
  if (!Level.Game.GameReplicationInfo.bTeamGame)
    return False;

  if (String(Level.Game.Class) == "Botpack.CTFGame")
    return bAutoBalanceTeamsForCTF;
  if (String(Level.Game.Class) == "Botpack.TeamGamePlus")
    return bAutoBalanceTeamsForTDM;
  if (String(Level.Game.Class) == "Botpack.Assault") {
    // Do not balance AS game if we're in the second half of the game
    if (Assault(Level.Game).Part != 1)
      return False;
    else
      return bAutoBalanceTeamsForAS;
  }

  // OK so it's an unknown teamgame
  return bAutoBalanceTeamsForOtherTeamGames;
}

function bool ShouldUpdateStats(GameInfo game) {
  if (String(Level.Game.Class) == "Botpack.CTFGame")
    return bUpdatePlayerStatsForCTF;
  if (String(Level.Game.Class) == "Botpack.TeamGamePlus")
    return bUpdatePlayerStatsForTDM;
  if (String(Level.Game.Class) == "Botpack.Assault")
    return bUpdatePlayerStatsForAS;
  // OK so it's not CTF or TDM or AS, but is it another type of team game?
  if (Level.Game.GameReplicationInfo.bTeamGame)
    return bUpdatePlayerStatsForOtherTeamGames;
  return bUpdatePlayerStatsForNonTeamGames;
}

function bool AllowedToBalance(Pawn b) {
  if (b.IsA('Bot'))
    return bBalanceBots;
  else
    return b.IsA('PlayerPawn') && !b.IsA('Spectator');
}

// Checks that the player is a human, or a bot when bRankBots is set.  Does not check whether the human player is a spectator.
function bool AllowedToRank(Pawn b) {
  if (b.IsA('Bot'))
    return bRankBots;
  else
    return b.IsA('PlayerPawn');
}

// This is used for checking and performing mid-game teambalance.  It counts bots if bBalanceBots is set to True.
function int GetTeamSize(int team) {
  local int count;
  local Pawn p;
  count = 0;
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (AllowedToBalance(p) && p.PlayerReplicationInfo.Team == team) count++;
  }
  return count;
}

function int CountHumanPlayers() {
  local Pawn p;
  local int countHumanPlayers;
  countHumanPlayers = 0;
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (p.bIsPlayer && !p.IsA('Spectator') && !p.IsA('Bot') && p.IsA('PlayerPawn') && p.bIsHuman) { // maybe the last 2 are not needed
      countHumanPlayers++;
    }
  }
  return countHumanPlayers;
}

function String getTeamName(int teamNum) {
  return TeamGamePlus(Level.Game).Teams[teamNum].TeamName;
}

// Team strength is the sum of all player and bot strengths on that team, plus caps*FlagStrength (or other teamscore).
function float GetTeamStrength(int teamNum) {
  local Pawn p;
  local float strength;
  strength = 0;
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (p.bIsPlayer && !p.IsA('Spectator') && p.PlayerReplicationInfo.Team == teamNum) {
      strength += GetPawnStrength(p);
    }
  }
  // Add flagstrength:
  strength += TournamentGameReplicationInfo(Level.Game.GameReplicationInfo).Teams[teamNum].Score*GetFlagStrength();
  return strength;
}

// Scale FlagStrength, so it is appropriate for non-CTF gametypes:
// Some common GoalTeamScores are: CTF 7 | (DM 30) | TDM 100 | DOM 100 | Siege 20/30
function float GetFlagStrength() {
  if (String(Level.Game.Class) == "Botpack.CTFGame")
    return FlagStrength;
  if (String(Level.Game.Class) == "Botpack.TeamGamePlus") // TDM
    return Float(FlagStrength)/14.0;
  if (String(Level.Game.Class) == "Botpack.Domination")
    return Float(FlagStrength)/14.0;
  if (String(Level.Game.Class) == "Botpack.Assault")
    return 0;
  if (StrAfter(String(Level.Game.Class),".") == "SiegeGI")
    return Float(FlagStrength)/4.0;
  // Unknown gametype; assume GoalTeamScore 150
  return Float(FlagStrength)/21.0;
}

// Returns the strength of a player or a bot
// Bots can be included in ranking and balancing by setting bRankBots.  Without it, BotStrength is used for all bots.
function int GetPawnStrength(Pawn p) {
  if (AllowedToRank(p) || AllowedToBalance(p)) {
    return GetPlayerStrength(p);
  } else {
    return BotStrength;
  }
}

// Returns the strength of a player
function int GetPlayerStrength(Pawn p) {
  local int found;
  if (bUseOnlyInGameScoresForRebalance && gameStartDone && !gameEndDone) {
    return p.PlayerReplicationInfo.Score;
  }
  found = FindPlayerRecord(p);
  if (found == -1) {
    // TODO: if gameStartDone and/or gametime>1minute then guess the player's strength from their current score
    return UnknownStrength; // unknown player or player is too weak for list
  } else {
    return avg_score[found]; // player's recorded strength
  }
}

// Find player by name, or partial name
function Pawn FindPlayerNamed(String name) {
  local Pawn p;
  local Pawn found;
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (p.IsA('PlayerPawn') || p.IsA('Bot')) {
      if (p.getHumanName() ~= name) { // exact case insensitive match, return player
        return p;
      }
      if (Instr(Caps(p.getHumanName()),Caps(name))>=0) { // partial match, remember it but keep searching for exact match
        found = p;
      }
    }
  }
  return found; // return partial match, or None
}



// ======== Player database: ======== //

// Copies from playerData[] to ip[],nick[],avg_score[],... (should be done at the start)
function CopyConfigIntoArrays() {
  local int field;
  local int i;
  local String data;
  local String args[256];

  CopyConfigDone=True;

  if (bDebugLogging) { Log("AutoTeamBalance.CopyConfigIntoArrays() running"); }
  for (i=0; i<MaxPlayerData; i++) {

    if (playerData[i] == "") continue;
    SplitString(playerData[i]," ",args);
    ip[i] = args[0];
    nick[i] = args[1];
    avg_score[i] = Float(args[2]);
    hours_played[i] = Float(args[3]);

  }
  if (bDebugLogging) { Log("AutoTeamBalance.CopyConfigIntoArrays() done"); }
}

// Copies from ip[],nick[],avg_score[],... to playerData[] (should be done before SaveConfig())
function CopyArraysIntoConfig() {
  local int i;
  if (bDebugLogging) { Log("AutoTeamBalance.CopyArraysIntoConfig() running"); }
  for (i=0; i<MaxPlayerData; i++) {
     if (ip[i] != "") {
       playerData[i] = ip[i] $ " " $ nick[i] $ " " $ avg_score[i] $ " " $ hours_played[i];
    }
  }
  if (bDebugLogging) { Log("AutoTeamBalance.CopyArraysIntoConfig() done"); }
}

#ifndef ENABLE_USEISPNOTFULLIP
#define getISP(X) X
#endif
function String getIP(Pawn p) {
	if (p.IsA('PlayerPawn')) {
		return getISP(stripPort(PlayerPawn(p).GetPlayerNetworkAddress()));
	} else {
		return getISP("0.0.0.0");
	}
}

#ifdef ENABLE_USEISPNOTFULLIP
function String getISP(String ip) {
	local int i;
	if (bUseISPNotFullIP) {
		return StrAfter(StrAfter(ip,"."),".");
	} else {
		return ip;
	}
}
#endif
// The big disadvantage os using bUseISPNotFullIP, if that if a player changes nick, they may get matched to the record of another player on the same ISP, not their old record!
// But if they have changed nick *and* part-ip, without bUseISPNotFullIP, they won't get any matches.  :P

#ifdef ENABLE_MUTATOR_SIGNATURE
// Returns player name, with gametype and/or mutator signature appended
// e.g.: nogginBasher@CTFGame:NR+WPM+IA (NoRedeemer,WhoPushedMe,InstagibArena)
function String GetDBName(Pawn p) {
  local String str;
  local String tmpstr;
  local int i;
  local int c;
  local Mutator m;
  str = p.getHumanName();
  if (bSeparateStatsByGamemode) {
    str = str $ "@" $ StrAfter(String(Level.Game.Class),".");
  }
  if (bSeparateStatsByMutators) {
    str = str $ ":";
    m = Level.Game.BaseMutator;
    while (m != None) {
      // Build signature of mutator:

      // OLD METHOD: Select first char of package and first char of the class name: e.g. Botpack.Noredeemer => BN
      // str = str $ Left(String(m.Class),1) $ Left(StrAfter(String(m.Class),"."),1);

      // NEW METHOD: Select only capitalised parts of the class name: e.g. WhoPushedMe.WhoPushedMe => WPM
      // Possible BUG: People *may* write mutators that are not capitalised, in which case those mutators will generate no signature.
      //               However, we can't change the signature now, without breaking the nicks for admins upgrading from earlier versions of ATB (although some player strengths might be retained via ip-matching)
      tmpstr = StrAfter(String(m.Class),".");
      for (i=0;i<Len(tmpstr);i++) {
        c = Asc(Mid(tmpstr,i,1));
        if (c>=Asc("A") && c<=Asc("Z")) {
          str = str $ Chr(c);
        }
      }
      m = m.NextMutator;
      if (m != None) {
        str = str $ "+";
      }

    }
  }
  return str;
}
#else
#define GetDBName(p) p.getHumanName()
#endif

// Will always return a valid exact record index, creating a new record if neccessary.
function int FindPlayerRecord(Pawn p) {
  local int i;
  local int found;
  local string tmp_player_nick, tmp_player_ip;
  local float tmp_avg_score, tmp_hours_played;

  i = p.PlayerReplicationInfo.PlayerID % MaxPlayerData;

  // Is the player's record already at i?
  if (GetDBName(p) == nick[i] && getIP(p) == ip[i]) {
    return i;
  }

  // Is there an exact or partial match for this player in the database?
  found = FindPlayerRecordNoFastHash(p);

  // If an exact record for the player was found, move it to index i for the rest of this game (by swapping it with whichever record is there).  This will make lookups more efficient during the rest of the game.
  if (found != -1 && GetDBName(p) == nick[found] && getIP(p) == ip[found]) {
    if (bDebugLogging) { Log("AutoTeamBalance.FindPlayerRecord(): Optimising lookup ("$i$"<->"$found$") for "$GetDBName(p)$" @ "$getIP(p)$"."); }
    tmp_player_nick = nick[i];
    tmp_player_ip = ip[i];
    tmp_avg_score = avg_score[i];
    tmp_hours_played = hours_played[i];
    nick[i] = nick[found];
    ip[i] = ip[found];
    avg_score[i] = avg_score[found];
    hours_played[i] = hours_played[found];
    nick[found] = tmp_player_nick;
    ip[found] = tmp_player_ip;
    avg_score[found] = tmp_avg_score;
    hours_played[found] = tmp_hours_played;
    return i;
  }

  // No exact record for the player was found; we have performed a full search of the database :|
  if (bDebugLogging) { Log("AutoTeamBalance.FindPlayerRecord(): FAILED lookup for "$GetDBName(p)$" @ "$getIP(p)$"."); }

  // Let's create a new record for this player+ip, to avoid doing that again.
  i = CreateNewPlayerRecord(p); // i=unknown, but the new record will be optimally indexed the next time FindPlayerRecord() is called.

  if (found > -1) {
    // Copy over strength from the partial-match player, but partially reset their time, to make their old strength last for max MaxHoursWhenCopyingOldRecord hours.
    avg_score[i] = avg_score[found]; // Copy score from partial match record
    hours_played[i] = Min(MaxHoursWhenCopyingOldRecord,hours_played[found]);
    // SO: changing nick or IP will NOT reset your avg_score immediately, but after two hours of play your old record will only count for 50%.  This helps to protect players who were matched incorrectly.  (Different members of a family playing from the same IP, or different players using the same nick.)

    // Optionally log/broadcast the fakenicker, now only if IP was matched but nick is different.
    if (!(GetDBName(p) ~= nick[i])) {
      if (bLogFakenickers) { Log("AutoTeamBalance: Fakenicker "$p.getHumanName()$" (ip "$getIP(p)$") was previously "$nick[found]$" (ip "$ip[found]$")"); }
      if (bBroadcastFakenickers) { BroadcastMessage(p.getHumanName()$" (ip "$getIP(p)$") was previously "$nick[found]$" (ip "$ip[found]$")"); }
    }
  }

  return i; // if we didn't copy any stats over, he will have UnknownStrength, the same as when we returned -1

}

// If an exact match for the player exists, return the index
// If not, return the index of a record with matching nick, or (preferably) matching ip
// If not, return -1
function int FindPlayerRecordNoFastHash(Pawn p) {
  local int found;
  local int i;
  local string player_nick;
  local string player_ip;

  player_nick = GetDBName(p);
  player_ip = getIP(p);

  found = -1;
  for (i=0;i<MaxPlayerData;i++) {
    // Exact match! return the index immediately
    if (player_nick == nick[i] && player_ip == ip[i]) {
      found = i;
      if (bDebugLogging) { Log("AutoTeamBalance.FindPlayerRecordNoFastHash(p) EXACT match for " $player_nick$","$player_ip$": ["$found$"] ("$avg_score[found]$","$hours_played[found]$")"); }
      return found;
    } else if (player_ip == ip[i]) {
      found = i; // matching ip
      if (bDebugLogging) { Log("AutoTeamBalance.FindPlayerRecordNoFastHash(p) IP match for "$player_nick$","$player_ip$": ["$found$"] "$nick[i]$" ("$avg_score[i]$")"); }
    } else if (player_nick == nick[i] && found == -1) {
      found = i; // if not yet matching an ip, match the same nick on any ip
      if (bDebugLogging) { Log("AutoTeamBalance.FindPlayerRecordNoFastHash(p) NICK match for "$player_nick$","$player_ip$": ["$found$"] "$ip[found]$" ("$avg_score[found]$","$hours_played[found]$")"); }
    }
    // TODO: if an uneven match, choose a match with more experience (hours_played)
    // TODO: even better, average the strengths of all partial-matches (maybe the same nick many times on different IPs, or the same IP with many different nicks), weighted by hours_played
    // TODO (elsewhere): if we have little experience (<10mins) of a player, return UnknownStrength anyway?
  }

  if (bDebugLogging && found == -1) { Log("AutoTeamBalance.FindPlayerRecordNoFastHash("$p$") failed to return a record."); }
  return found;
}

function int CreateNewPlayerRecord(Pawn p) {
  local int pos;
  // Find an empty slot:
  for (pos=0;pos<MaxPlayerData;pos++) {
    if (ip[pos] == "" && nick[pos] == "") {
      break;
    }
  }

  if (pos == MaxPlayerData) { // all records were full
    // DONE: find the record with lowest hours_played and replace that one
    // TODO: better, find the oldest record and replace it (we need last_date_played for that)
    pos = FindShortestPlayerRecord();
  }

  ip[pos] = getIP(p);
  nick[pos] = GetDBName(p);
  avg_score[pos] = UnknownStrength;
  hours_played[pos] = 0; // UnknownMinutes/60; // TODO CONSIDER: using some UnknownMinutes might be better, for players who play only for a short time and get an unrepresentative strength for the next game - with UnknownMinutes their strength will be closer to the average, hence balancing will concentrate more on players we know about.
  if (bDebugLogging) { Log("AutoTeamBalance.CreateNewPlayerRecord("$p$") ["$pos$"] "$ nick[pos] $" "$ ip[pos] $" "$ avg_score[pos] $" "$ hours_played[pos] $"."); }
  // if (bBroadcastCookies) { BroadcastMessageAndLog("Welcome "$ nick[pos] $"!  You have "$ avg_score[pos] $" cookies."); }
  return pos;
}

// Finds an old player record which we can replace.  Actually since we don't have a last_date_played field, we look for the record with least hours_played.  (Player didn't spend long on server; their stats don't mean a lot)
// TODO: One problem, this new player will probably be the next record to be replaced!  To keep his record in the database, the new player will have to play for longer than the now "shortest" record before another new record is created.
function int FindShortestPlayerRecord() {
  local int i,found;
  found = 0;
  for (i=1;i<MaxPlayerData;i++) {
    if (hours_played[i] < hours_played[found]) {
      found = i;
    }
  }
  return found;
}



// =========== Updating Stats on player database: =========== //

function UpdateStatsAtEndOfGame() {
  local Pawn p;
  local int i;

  // Do not update stats for games with <MinHumansForStats human players.
  if (CountHumanPlayers() < MinHumansForStats) {
    if (bDebugLogging) { Log("AutoTeamBalance.UpdateStatsAtEndOfGame(): not updating stats since CountHumanPlayers "$CountHumanPlayers()$" < "$MinHumansForStats$"."); }
    return;
  }

  if (WinningTeamBonus != 0 && !DeathMatchPlus(Level.Game).bTournament) {
    GiveBonusToWinningTeamPlayers();
  }

  // Update stats for all players in game
  if (bDebugLogging) { Log("AutoTeamBalance.UpdateStatsAtEndOfGame(): Updating player stats."); }
  if (bBroadcastStuff) { BroadcastMessageAndLog("AutoTeamBalance is updating player stats."); }
  // TEST considered when stats were being updated mid-game: make lag here on purpose and see how bad we can get it / how we can fix it.
  if (bLogExtraStats) { Log("AutoTeamBalance.LogEndStats: Team Name IP Ping PktLoss Rank Hours Score Frags Deaths Items Spree Secret Time"); }
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (!p.IsA('Spectator') && AllowedToRank(p)) {
      i = UpdateStatsForPlayer(p);
      if (bLogExtraStats) { Log("AutoTeamBalance.LogEndStats: "$p.PlayerReplicationInfo.Team$" "$p.getHumanName()$" "$getIP(p)$" "$p.PlayerReplicationInfo.Ping$" "$p.PlayerReplicationInfo.PacketLoss$" "$avg_score[i]$" "$hours_played[i]$" "$p.PlayerReplicationInfo.Score$" "$p.KillCount$" "$p.PlayerReplicationInfo.Deaths$" "$p.ItemCount$" "$p.Spree$" "$p.SecretCount$" "$(Level.TimeSeconds - p.PlayerReplicationInfo.StartTime)$""); }
    }
  }

  Log("AutoTeamBalance.UpdateStatsAtEndOfGame(): done");

}

function GiveBonusToWinningTeamPlayers() {
  local TeamInfo WinningTeam;
  local int i;
  local Pawn p;
  local TeamGamePlus thisTeamGame;

  // We can't find a winning team if it's not a teamgame!
  if (!Level.Game.GameReplicationInfo.bTeamGame) return;

  thisTeamGame = TeamGamePlus(Level.Game);

  // Which team won?

  // Copied from CTFGame.SetEndCams(), and looks functionally identical to the method in TeamGamePlus.
  for ( i=0; i<thisTeamGame.MaxTeams; i++ )
    if ( (WinningTeam == None) || (thisTeamGame.Teams[i].Score > WinningTeam.Score) )
      WinningTeam = thisTeamGame.Teams[i];
  // Check for tie:
  for ( i=0; i<thisTeamGame.MaxTeams; i++ ) {
    if ( (WinningTeam.TeamIndex != i) && (WinningTeam.Score == thisTeamGame.Teams[i].Score) ) {
      WinningTeam = None;
      break;
    }
  }

  if (WinningTeam == None) return; // game ended in a tie

  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (!p.IsA('Spectator') && AllowedToRank(p)) {
      if (p.PlayerReplicationInfo.Team == WinningTeam.TeamIndex) {
        if (bDebugLogging) { Log("AutoTeamBalance.GiveBonusToWinningTeamPlayers(): giving bonus to "$p.getHumanName()$"."); }
        p.PlayerReplicationInfo.Score += WinningTeamBonus;
        p.ClientMessage("You got "$WinningTeamBonus$" bonus points for finishing on the winning team.",'Pickup',False);
      }
    }
  }

}

// Returns the multiplier required to increase this player's score to what it might have been if he had played for the whole game.
function float ScaleToFullTime(Pawn p) {
  if (bScalePlayerScoreToFullTime) {
    return (Level.TimeSeconds - timeGameStarted) / (Level.TimeSeconds - p.PlayerReplicationInfo.StartTime);
  } else {
    return 1.0;
  }
}

// For ScoringMethod 3.  Returns a value between 0 and 100, depending on the player's position in the overall scoreboard.
function float GetRankingPoints(Pawn other) {
  local Pawn p;
  local int playersAbove;
  local int playersBelow;
  playersAbove = 0;
  playersBelow = 0;
  // Find the position of this player in the overall scoreboard:
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (p!=other && !p.IsA('Spectator') && AllowedToRank(p)) {
      // i switched the > to >= so if you tie with another player, you lose out!
      if ( (ScaleToFullTime(p)*p.PlayerReplicationInfo.Score) >= (ScaleToFullTime(other)*other.PlayerReplicationInfo.Score) ) {
        playersAbove++;
      } else {
        playersBelow++;
      }
    }
  }
  return 100 * playersBelow / (playersBelow + playersAbove);
}

// Returns the score the player will be awarded for this game, depending on the scoring method, and scaled up to full game time.  Note that score normalisation is done elsewhere.
function float GetScoreForPlayer(Pawn p) {
  local float award_score;
  if (ScoringMethod == 0) {
    award_score = p.PlayerReplicationInfo.Score * ScaleToFullTime(p);
  } else if (ScoringMethod == 1) {
    award_score = p.KillCount * ScaleToFullTime(p);
  } else if (ScoringMethod == 2) {
    award_score = ScaleToFullTime(p) * (p.KillCount + p.PlayerReplicationInfo.Score) / 2.0;
  } else if (ScoringMethod == 3 || ScoringMethod > 3) {
    award_score = GetRankingPoints(p); // Note that for this method, scaling score to full time is done *inside* GetRankingPoints()
  }
  return award_score;
}

function int UpdateStatsForPlayer(Pawn p) {
  local int i,j;
  local float current_score;
  local float old_hours_played;
  local float new_hours_played;
  local float hours_played_this_game;
  local int previousPolls;
  local int gameDuration;
  local int timeInGame;
  local float weightScore;
  local float previous_average;

  i = FindPlayerRecord(p); // guaranteed to return a record.

  gameDuration = Level.TimeSeconds - timeGameStarted;
  timeInGame = Level.TimeSeconds - p.PlayerReplicationInfo.StartTime;
  if (timeInGame>gameDuration)
    timeInGame = gameDuration;
  if (timeInGame < 60) { // The player has been in the game for less than 1 minute.
    if (bDebugLogging) { Log("AutoTeamBalance.UpdateStatsForPlayer("$p$") Not updating this player since his timeInGame "$timeInGame$" < 60s."); }
    return i;
  }
  hours_played_this_game = Float(timeInGame)/60.0/60.0;

  current_score = GetScoreForPlayer(p);

  // Normalisation, or not:
  // ScoringMethod 3 requires no normalisation.
  if (ScoringMethod==0 || ScoringMethod==1 || ScoringMethod==2) {
    if (bNormaliseScores) {
      current_score = NormaliseScore(current_score); // to get an average score of 50 (different now that we use bRelativeNormalisation)
    } else {
      // Since we are not normalising the scores relative to other players, we are just recording end-game scores.
      // But if this was a short game, scores will probably be lower, so we
      // scale the scores up to what they might have been if the game had gone the full (assumed) 20 minutes.
      current_score = current_score * (1.0/3.0) / hours_played_this_game;
    }
  }

  old_hours_played = hours_played[i];
  if (old_hours_played > HoursBeforeRecyclingStrength) {
    old_hours_played = HoursBeforeRecyclingStrength;
  }
  new_hours_played = old_hours_played + hours_played_this_game;

  previous_average = avg_score[i];

  if (bDebugLogging) { Log("AutoTeamBalance.UpdateStatsForPlayer(p) ["$i$"] "$p.getHumanName()$" avg_score = ( ("$avg_score[i]$" * "$old_hours_played$") + "$current_score$"*"$hours_played_this_game$") / "$(new_hours_played)); }
  avg_score[i] = ( (avg_score[i] * old_hours_played) + current_score*hours_played_this_game) / new_hours_played;

  hours_played[i] += hours_played_this_game;

  if (avg_score[i]>previous_average+1) {
    if (bBroadcastCookies) { BroadcastMessageAndLog(""$ p.getHumanName() $" has earned "$ Int(avg_score[i]-previous_average) $" cookies!"); }
    if (bFlashCookies) { FlashMessageToPlayer(p,"You earned "$ Int(avg_score[i]-previous_average) $" cookies this game."); } // BUG: unfortunately hidden by scoreboard, but still appears in console
  }
  else if (previous_average>avg_score[i]+1) {
    if (bBroadcastCookies) { BroadcastMessageAndLog(""$ p.getHumanName() $" has lost "$ Int(previous_average-avg_score[i]) $" cookies."); }
    if (bFlashCookies) { FlashMessageToPlayer(p,"You lost "$ Int(previous_average-avg_score[i]) $" cookies this game."); } // BUG: unfortunately hidden by scoreboard, but still appears in console
  }
  return i;
}

// Normalises a player's score so that the average output score will be 50 (or with bRelativeNormalisation, the average strength of current players on the server).
// This is to fix the problem that some games (e.g. 2v2 w00t or PureAction or iG) have much higher scores than others, which will confuse the stats.
function float NormaliseScore(float score) {
  local Pawn p;
  local int playerCount;
  local float averageGameScore;
  local float averagePlayerStrengthThisGame;

  averageGameScore = 0.0;
  averagePlayerStrengthThisGame = 0.0;
  for (p=Level.PawnList; p!=None; p=p.NextPawn) {
    if (!p.IsA('Spectator') && AllowedToRank(p)) {
      averageGameScore += GetScoreForPlayer(p);
      averagePlayerStrengthThisGame += GetPawnStrength(p);
      playerCount++;
    }
  }
  averageGameScore = averageGameScore / Float(playerCount);
  averagePlayerStrengthThisGame = averagePlayerStrengthThisGame / Float(playerCount);

  // Avoid division-by-zero error here.  You guys got average <2 frags?  Screw you I'm not scaling that up to NormalisedStrength!
  if (averageGameScore < 2.0) {
    averageGameScore = NormalisedStrength; // CONSIDER: maybe just better not to update
  } // BT games will tend to have a lot of -ve scores.

  if (bDebugLogging) { Log("AutoTeamBalance.NormaliseScore("$score$"): Average game score was "$averageGameScore$", average player strength was "$averagePlayerStrengthThisGame$""); }

  if (bRelativeNormalisation) {
    return score * averagePlayerStrengthThisGame / averageGameScore;
  } else {
    return score * NormalisedStrength / averageGameScore;
  }

}

// Takes everything before the first ":" - used when getting the IP from PlayerPawn.GetPlayerNetworkAddress(); since the client's port number changes frequently.
function string stripPort(string ip_and_port) {
  if ((""$ip_and_port)=="None" || ip_and_port=="") {
    if (bDebugLogging) { Log("stripPort(); ip_and_port="$ip_and_port); }
    return "0.0.0.0";
  }
  return Left(ip_and_port,InStr(ip_and_port,":"));
}



// Include my library of common UnrealScript functions:

#include "../../JLib/jlib.uc.jpp"

