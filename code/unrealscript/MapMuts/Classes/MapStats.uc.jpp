// vim: tabstop=2 shiftwidth=2 noexpandtab filetype=uc

#define MaxData 3000

class MapStats expands Mutator config(MapStats);

#define MapScale 400
#define NumberOfSpawnPointsScaled (NumberOfSpawnPoints*0.6)
#define FallbackValue (NumberOfSpawnPointsScaled*MapScale)

// I thought this was needed for immediate switch to work 100%, but I'm not 100% sure.
// #define CATCH_LEVEL_SWITCH

var config bool bLogging;
var config bool bDebugLogging;
var config bool bCollectMapStats;
var config bool bEstimatePreferredPlayers;
var config bool bEndGameSwitchMap;
var config int EndGameSwitchSeconds;
var config bool bEmptyServerSwitchMap;
var config int EmptyServerSwitchSeconds;
var config bool bAllowMutateSwitch;
var config bool bSetMaxPlayers;
var config bool bAutoExpandMaxPlayers;
var config int ServerMinPlayers;
var config int ServerMaxPlayers;
var config bool bDoMapScan;

struct MapInfo {
	var bool bOnDisk;
	var bool bCrashes;
	var String MapName;
	var float PreferredPlayers;
	var String PreferredPlayersSource;
	var int TotalGamesStarted;
	var int TotalGamesEnded;
	var int TotalDeaths;
	var float TotalHoursPlayed;
	var float TotalDamageDone;
	var float DateLastPlayed;
	var float AverageFlow;
	var float AverageNumPlayers;
	// var int NumberOfSpawnPoints;
	// var int NumberOfWeaponPickups;
	// var int NumberOfPathNodes;
	// var float ActorDistance;
};

var config MapInfo MapStats[MaxData];

var String mapName; // Current map's name, generated at start.
var int mapI; // Current map's index, generated at start.
var float NumberOfSpawnPoints; // Globalised for FallbackValue

var float StartTime;
var int PlayerCountAtStart;
var bool bMapScanDone;
var bool bDoneGameEnd;
var bool bCanChooseUnsizedMaps;
var String ConsideredMaps;
var bool bInterceptTravel;
var String NextMap;

defaultproperties {
bLogging=True
bDebugLogging=False
bCollectMapStats=True
bEstimatePreferredPlayers=True
bEndGameSwitchMap=False
EndGameSwitchSeconds=30
bEmptyServerSwitchMap=False
EmptyServerSwitchSeconds=120
bAllowMutateSwitch=True
bSetMaxPlayers=False
bAutoExpandMaxPlayers=False
ServerMinPlayers=6
ServerMaxPlayers=24
bDoMapScan=True
}

// #define DebugLog(Y); 
#define DebugLog(Y); if (bDebugLogging) { Log("(MapStats)." $ Y); }
// #define NormalLog(Y); 
#define NormalLog(Y); if (bLogging) { Super.Log("[MapStats] " $ Y); }
// Fails: // function NormalLog(String Y) { if (bLogging) { Super.Log(Y); } }
// Fails: // #define Log(Y); NormalLog(Y);

#define BroadcastAndLog(Y); BroadcastMessage(Y); if (bLogging) { Log("[MapStats] Broadcasted: " $ Y); }

#define CountPlayers() ( CountActors(class'PlayerPawn') - CountActors(class'Spectator') )

// #define MaxActorDistance() MaxActorDistanceType(class'PlayerStart')

#define currentMap MapStats[mapI]

#define MapRecord(X) MapStats[MapIndex(X)]

function PostBeginPlay() {

	//// Pushing out new default configs during a temporary release:
	// EmptyServerSwitchSeconds=300;
	// bDebugLogging=True;

	mapName = StrBeforeFirst(""$Self,".");
	mapI = MapIndex(mapName);

	Level.Game.RegisterDamageMutator(Self);

	// TODO:
	// If we were not added as a mutator, but run in some other way (e.g. as a ServerActor), then we need to register as a mutator:
   // Level.Game.BaseMutator.AddMutator(Self);

	// Register to receive spoken messages in MutatorTeamMessage() below:
	// Level.Game.RegisterMessageMutator(Self);

	DoStart();

	SetTimer(5.0,True);

}

function DoStart() {
	// This is actually done when the map is loaded.
	// The game starts when a player joins - see ModifyPlayer().
	local String idealPlayerCount,gotNum,restStr;
	local int count;
	local float avg,num;
	local bool bMustSave;
	// local float NumberOfSpawnPoints;
	local float ActorDistance;

	// ScanMaps();

	num = (DaysSince1970() - currentMap.DateLastPlayed);
	if (num<2.0) {
		NormalLog(mapName$" was last played "$ Int(24*num+0.5) $" hours ago.");
	} else {
		NormalLog(mapName$" was last played "$ Int(num+0.5) $" days ago.");
	}

	if (bCollectMapStats) {
		NormalLog("Collecting stats ...");
		// if (currentMap.bCrashes) { NormalLog("Map "$ currentMap.MapName$" was previously crashing, but now works!"); } // duh this is often set to true inaccurately by DoLevelSwitch :P
		// currentMap.ActorDistance = (MaxActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode')) / 3.0;
		NumberOfSpawnPoints = CountActors(class'PlayerStart');
		// currentMap.NumberOfWeaponPickups = CountActors(class'Weapon');
		// currentMap.NumberOfPathNodes = CountActors(class'PathNode');
	}

	if (bEstimatePreferredPlayers) {

		// Should we regenerate the map's PreferredPlayers estimate with the latest algorithm?
		if (
			currentMap.PreferredPlayers == 0
			|| StrStartsWith(currentMap.PreferredPlayersSource,"Estimate")
			|| StrStartsWith(currentMap.PreferredPlayersSource,"Generated")
			// || StrStartsWith(currentMap.PreferredPlayersSource,"Calculated")
			/* legacy: || StrStartsWith(currentMap.PreferredPlayersSource,"Ideal") || StrStartsWith(currentMap.PreferredPlayersSource,"Level.Ideal") */
		) {
			// We are allowed to modify the PreferredPlayers count for this map, and should now do our best

			NormalLog("Re-calculating PreferredPlayers, old value = "$ currentMap.PreferredPlayers);

			// DebugLog("Collecting ActorDistance for "$mapName$"...");
			ActorDistance = ( MaxActorDistanceType(class'FlagBase') + MaxActorDistanceType(class'Weapon') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode') ) / 4.0 / Float(MapScale);
			if (ActorDistance < 2)
				ActorDistance = 2;
			if (ActorDistance > 32)
				ActorDistance = 32;

			// Get map author's suggested IdealPlayerCount:
			idealPlayerCount = Level.IdealPlayerCount;
			// DebugLog("Getting map author's IdealPlayerCount from \""$idealPlayerCount$"\"...");
			restStr = idealPlayerCount;
			avg = 0.0;
			count = 0;
			do {
				gotNum = StrFilterNum(restStr,restStr);
				if (gotNum!="") {
					num = Float(gotNum);
					// DebugLog("MapStats: Got "$num$" from \""$gotNum$"\" with rest="$restStr);
					if (num>0) {
						// avg = (count*avg + num) / (count+1);
						avg += num;
						count++;
					}
					if (StrStartsWith(restStr,"-"))
						restStr = Mid(restStr,1);
				}
			} until (gotNum == "");
			if (count>0) avg = avg / count;

			// Build estimated PreferredPlayers from avg, NumberOfSpawnPoints and ActorDistance:
			if ( count>0 ) {
				// DebugLog(mapName$" Got IdealPlayerCount "$avg$" from \""$idealPlayerCount$"\".");
				if (avg>20) avg=20;
				currentMap.PreferredPlayers = avg;
				// Mix it with NumberOfSpawnPoints and ActorDistance:
				currentMap.PreferredPlayers = 0.4*avg + 0.3*NumberOfSpawnPointsScaled + 0.3*ActorDistance;
				currentMap.PreferredPlayersSource = "Estimate from Ideal("$ idealPlayerCount $"=>"$avg$") and PlayerStarts("$ NumberOfSpawnPointsScaled $") and ActorDistance("$ ActorDistance $")";
			} else {
				// Mix just NumberOfSpawnPoints and ActorDistance:
				currentMap.PreferredPlayers = 0.5*NumberOfSpawnPointsScaled + 0.5*ActorDistance;
				currentMap.PreferredPlayersSource = "Estimate from PlayerStarts("$ NumberOfSpawnPointsScaled $") and ActorDistance("$ ActorDistance $")";
			}
			NormalLog(""$ currentMap.PreferredPlayersSource $"");
			NormalLog("PreferredPlayers = "$ currentMap.PreferredPlayers);
		}

	}

	// If it was marked as crashed or not on-disk, We MUST mark this map as working!
	if (currentMap.bCrashes || !currentMap.bOnDisk) bMustSave=True;
	currentMap.TotalGamesStarted++;
	currentMap.DateLastPlayed = DaysSince1970();
	currentMap.bCrashes = False;
	currentMap.bOnDisk = True;

	#define bSaveEarly False
	if (bSaveEarly && (bCollectMapStats || bEstimatePreferredPlayers)) bMustSave=True;
	if ( bMustSave ) {
		DebugLog("DoStart(): Calling SaveConfig()");
		SaveConfig();
	}

	if (bSetMaxPlayers && currentMap.PreferredPlayers>0) {
		Level.Game.MaxPlayers = 2*Int( (currentMap.PreferredPlayers+1.0)/2.0 );
		if (Level.Game.MaxPlayers < ServerMinPlayers)
			Level.Game.MaxPlayers = ServerMinPlayers;
		if (Level.Game.MaxPlayers > ServerMaxPlayers)
			Level.Game.MaxPlayers = ServerMaxPlayers;
		NormalLog("bSetMaxPlayers: MaxPlayers set to "$ Level.Game.MaxPlayers);
	}

}

function ModifyPlayer(Pawn Other) {
	// if (PlayerPawn(Other) != None) {
	if (Other!=None && Other.PlayerReplicationInfo != None) {
		if (/*PlayerPawn(Other)!=None &&*/ Other.PlayerReplicationInfo.Deaths == 0) {
			// Latest player join!
			currentMap.DateLastPlayed = DaysSince1970(); // hope that a SaveConfig happens later (should happen in DoEnd())
			if (StartTime == 0) {
				// First ever spawn
				// StartTime = Level.TimeSeconds;
				// PlayerCountAtStart = CountPlayers();
				// DebugLog("ModifyPlayer("$Other$"): setting StartTime="$Level.TimeSeconds$" and PlayerCountAtStart="$ CountPlayers() );
			}
		} else {
			// A frag / someone/thing died
			currentMap.TotalDeaths++;
			if (StartTime == 0) {
				// First ever frag
				StartTime = Level.TimeSeconds;
				PlayerCountAtStart = CountPlayers();
				DebugLog("ModifyPlayer("$Other$"): setting StartTime="$Level.TimeSeconds$" and PlayerCountAtStart="$ CountPlayers() );
			}
		}
	}
	Super.ModifyPlayer(Other);
}

event Timer() {

	// Mid-game checks:
	if (bEmptyServerSwitchMap && CountPlayers()==0 /* CountActors(class'PlayerPawn')==CountActors(class'UTServerAdminSpectator') */ && Level.TimeSeconds>EmptyServerSwitchSeconds && FRand() < 0.2) {
		Log("[MapStats] Timer(): Level is empty and bEmptyServerSwitchMap=True - auto switching.");
		// Level.Game.bGameEnded = True;
		// bDoneGameEnd = True; // This prevents DoEnd() from being called, which is good since it's an idle server switch, not a real end-game.
		bCanChooseUnsizedMaps = True;
		DoLevelSwitch();
	}
	if (bAutoExpandMaxPlayers) {
		if (CountPlayers()+1 > Level.Game.MaxPlayers && Level.Game.MaxPlayers < ServerMaxPlayers) {
			Level.Game.MaxPlayers += 2;
			NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers increased to "$ Level.Game.MaxPlayers);
		}
		if (CountPlayers() < ServerMinPlayers && Level.Game.MaxPlayers > ServerMinPlayers && FRand()<0.01) {
			Level.Game.MaxPlayers -= 2;
			NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers reduced to "$ Level.Game.MaxPlayers);
		}
		// Level.Game.MaxPlayers = 2*Int( (CountActors(class'PlayerPawn')+1.0)/2.0 );
	}

	// Check if game has just ended:
	if (Level.Game.bGameEnded && !bDoneGameEnd) {
		DoEnd();
		bDoneGameEnd = True;
		if (bEndGameSwitchMap) {
			BroadcastAndLog("Map will not be: "$ ConsideredMaps);
			BroadcastAndLog("Map may switch to "$ ChooseNextMap() $" in "$EndGameSwitchSeconds$" seconds.");
			// We do the switch in the if clause below, when Timer is next called.
			SetTimer(EndGameSwitchSeconds,False);
		} else {
			NormalLog("bEndGameSwitchMap=False, but chosen map would have been: "$ChooseNextMap());
		}
		return;
	}

	// Check if game is well over:
	if (Level.Game.bGameEnded && bDoneGameEnd && bEndGameSwitchMap) {
		DoLevelSwitch();
	}

}

function DoLevelSwitch() {
	NextMap = ChooseNextMap();

	// MapRecord(NextMap).DateLastPlayed = DaysSince1970();
	MapRecord(NextMap).bCrashes = True;
	// In case server crashes, this stops it from being chosen again!  (Combined with bCrashes or DateLastPlayed.)
	// NO OLD: It's also desirable to mark maps which we found weren't on the disk, so we don't have to scan them again.
	// BUG TODO: If Tick intercepts the switch, it will see the bCrashes==True, and choose another map!
	DebugLog("DoLevelSwitch() calling SaveConfig()");
	SaveConfig();

	BroadcastAndLog("Considered maps: "$ ConsideredMaps);
	BroadcastAndLog("Switching to "$ NextMap $" now.");
	#ifdef CATCH_LEVEL_SWITCH
	bInterceptTravel = True;
	Enable('Tick');
	#endif
	if (!StrEndsWith(Caps(NextMap),".UNR"))
		NextMap = NextMap $ ".unr";
	// UTServerAdmin(GetAny(class'UTServerAdmin')).ConsoleCommand("admin servertravel "$ ChooseNextMap() );
	Level.NextURL = NextMap;
	Level.Game.ProcessServerTravel(NextMap,false);
	// bDoneGameEnd = False;
	SetTimer(0,False); // repeat calls should (may) be cancelled already
}

function DoEnd() {
	local float playerChangeThisMap,averageNumPlayersThisMap;
	local float totalHours,deltaHours,newTotalHours;

	if (bCollectMapStats) {

		currentMap.TotalGamesEnded++;
		// currentMap.DateLastPlayed = DaysSince1970();

		totalHours = currentMap.TotalHoursPlayed;
		deltaHours = (Level.TimeSeconds - StartTime) / 60.0 / 60.0;
		newTotalHours = currentMap.TotalHoursPlayed + deltaHours;

		playerChangeThisMap = CountPlayers() - PlayerCountAtStart;
		currentMap.AverageFlow = (totalHours*currentMap.AverageFlow + deltaHours*playerChangeThisMap) / newTotalHours;

		averageNumPlayersThisMap = (CountPlayers() + PlayerCountAtStart) / 2.0;
		currentMap.AverageNumPlayers = (totalHours*currentMap.AverageNumPlayers + deltaHours*averageNumPlayersThisMap) / newTotalHours;

		currentMap.TotalHoursPlayed = newTotalHours;

	}

	DebugLog("DoEnd() calling SaveConfig()");
	SaveConfig();

}

function int HashStr(String str, optional int max) {
	local int hash;
	local int ch;
	local int i;
	if (max == 0) max = MaxData;
	for (i=0;i<Len(str);i++) {
		ch = Asc(Mid(str,i,1));
		hash += ch;
		while (hash > max) {
			hash -= max;
		}
		while (hash < 0) {
			hash += max;
		}
	}
	return hash;
}

function int MapIndex(String mapName) {
	local int i;
	i = HashStr(mapName,MaxData);
	while (true) {
		if (MapStats[i].MapName == "") { // empty
			MapStats[i].MapName = mapName;
			return i;
		}
		if (MapStats[i].MapName == mapName) { // hit
			return i;
		}
		// collision, try next slot
		if (bDebugLogging && FRand()<0.01) { DebugLog("MapIndex("$mapName$"): collision "$ mapName $" with "$MapStats[i].MapName$" at "$i); }
		i++;
		if (i>=MaxData) {
			Log("[MapStats] Warning! MapIndex(\"" $ mapName $ "\") hash + collision offset = " $ i $ " >= MaxData - we are either unlucky, or the map database is full; forcing overwrite of hash.");
			// i = FRand()*MaxData;
			i = HashStr(mapName,MaxData);
			MapStats[i].MapName = mapName;
			return i;
		}
	}
	// never reached: return 0;
}

function float AverageActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local float totalDistance;
	local int totalCount,realTotalCount;
	local float distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	realTotalCount=0;
	totalDistance=0;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) {
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) {
					distance = VSize(A.Location-B.Location);
					totalDistance += distance;
					// totalDistance += distance*distance;
					realTotalCount++;
				}
			}
		}
	}
	if (realTotalCount < 2)
		return FallbackValue;
	totalDistance = totalDistance / realTotalCount;
	// NormalLog("Average distance of " $ realTotalCount $ " " $ type $ " actors = " $ totalDistance);
	NormalLog("Average distance of " $ realTotalCount $ " x " $ type $ " = " $ totalDistance);
	return totalDistance;
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float MaxActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local int totalCount;
	local float bestDistance,distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	if (totalCount < 2)
		return FallbackValue;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) {
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) {
					distance = VSize(A.Location-B.Location);
					if (distance > bestDistance)
						bestDistance = distance;
				}
			}
		}
	}
	// NormalLog("Max distance between " $ totalCount $ " " $ type $ " actors = " $ bestDistance);
	NormalLog("Max distance between " $ totalCount $ " x " $ type $ " = " $ bestDistance);
	return bestDistance; // this is actually average squared-distance, we should square-root it.
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float DaysSince1970() {
	return (Level.Year-1970.0)*365.25 + Level.Month*30.0 + Level.Day + Level.Hour/24.0 + Level.Minute/24.0/60.0 + Level.Second/24.0/60.0/60.0;
}

function String FloatToString(float f) {
	local String s;
	local int i;
	s = String(f);
	i = InStr(s,".");
	if (i>4) return StrBeforeLast(s,".");
	s = StrBeforeFirst(s,".") $ "." $ Left( StrAfterFirst(s,"."), 6-i ); // may not be accurate enough for 0.000001
	return s;
}

function float ScoreForNextMap(int nextI, int currentNumPlayers) {
	local float ageInDays, playerDiff, result;
	// if (MapStats[nextI].DateLastPlayed>719540) MapStats[nextI].DateLastPlayed = MapStats[nextI].DateLastPlayed - 719540; // legacy: when i changed my date calculation :P
	ageInDays = DaysSince1970() - MapStats[nextI].DateLastPlayed;
	// if (ageInDays>719050) ageInDays = ageInDays - 719050; // legacy: when i changed my date calculation :P
	// if (ageInDays<0) ageInDays = -ageInDays; // legacy: when i changed my date calculation :P
	playerDiff = Abs(currentNumPlayers + 0.5 - MapStats[nextI].PreferredPlayers);
	playerDiff += 2.0;
	// if (currentNumPlayers==0) playerDiff = 12.0; // When the server is empty, all maps have the same weighting in terms of player count
	ageInDays += 0.01;
	#define flowTweak (MapStats[nextI].AverageFlow*0.125)
	#define playerTweak (MapStats[nextI].AverageNumPlayers*0.05)
	// if (currentNumPlayers==0 && MapStats[nextI].PreferredPlayers==0) // When the server is empty
		// ageInDays += 5.0; // boost the score of maps whose size is unknown
	result = 384.0 * ( ageInDays + flowTweak + playerTweak ) / playerDiff;
	if (bDebugLogging && FRand()<0.01) {
		DebugLog("Score for "$ MapStats[nextI].MapName $" [pp="$ MapStats[nextI].PreferredPlayers $"] is: "$ result);
		DebugLog(" age "$ ageInDays $" + tweaks "$ flowTweak $" + "$ playerTweak $" ) / playerDiff "$ playerDiff);
	}
	return result;
}

// function bool ExistsOnDisk(String mapName) {
	// return ScanMaps(mapName);
// }

function String ChooseNextMap() {
	local String bestMap;
	local float bestScore;
	local int i,currentNumPlayers;
	local float mapScore;
	// DebugLog("CountActors(UTServerAdmin) = "$CountActors(class'UTServerAdmin'));
	// DebugLog("CountActors(PlayerPawn) = "$CountActors(class'PlayerPawn'));
	if (!bMapScanDone) {
		if (bDoMapScan) {
			DebugLog("ChooseNextMap(): Scanning maps for "$Level.Game.Default.MapPrefix$" ...");
			ScanMaps();
			bDoMapScan=False;
			SaveConfig(); // I guess this could be optional, but it would slow down any subsequent boot if we haven't saved :P
		} else {
			DebugLog("NOT scanning maps until you set MapMuts.MapStats bDoMapScan True");
		}
		bMapScanDone = True;
	}
	if (CountPlayers() == 0)
		bCanChooseUnsizedMaps = True;
	ConsideredMaps="";
	currentNumPlayers = CountPlayers();
	if (currentNumPlayers==0) currentNumPlayers = (ServerMaxPlayers+1)*FRand();
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].PreferredPlayers > 0 || (bCanChooseUnsizedMaps && MapStats[i].MapName!="")) {
			mapScore = ScoreForNextMap(i,currentNumPlayers);
			if (bestMap == "" || mapScore > bestScore) {
				if (!MapStats[i].bOnDisk) {
					if (bDebugLogging && FRand()<0.01) {
						DebugLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because server no longer has it!");
					}
					// MapStats[i].bCrashes = True;
					continue;
				}
				if (MapStats[i].bCrashes) {
					#define bRetryCrashedMaps True
					if (bRetryCrashedMaps && FRand()<0.01) {
						NormalLog("ChooseNextMap(): "$ MapStats[i].MapName $" crashes but letting it through to see if it has been fixed.");
					} else {
						// Too frequent here, but get reported occasionally above: NormalLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because it crashes!");
						continue;
					}
				}
				if (bestMap!="" && FRand()>0.6) {
					ConsideredMaps = ConsideredMaps $ bestMap $"("$Left(String(mapScore),4)$")"$ " ";
					NormalLog("Best  "$MapStats[i].MapName$" (score "$mapScore$", age "$ (DaysSince1970() - MapStats[i].DateLastPlayed) $")");
					NormalLog("beats "$bestMap$" (score "$bestScore$", age "$ (DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $")");
				}
				bestMap = MapStats[i].MapName;
				bestScore = mapScore;
			}
		}
	}
	NormalLog("Best map was "$ bestMap $" with score "$ bestScore $" (age "$ (DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $")");
	NormalLog("Current players = "$ currentNumPlayers $", map's PreferredPlayers = "$ MapRecord(bestMap).PreferredPlayers $".  Other considered maps were: "$ ConsideredMaps);
	return bestMap;
}

/*
function Actor GetAny(class<Actor> type) {
	local Actor A;
	foreach AllActors(type, A) {
		return A;
	}
	return None;
}
*/

function int CountActors(class<Actor> type) {
	local Actor A;
	// local Actor lA;
	local int c;
	foreach AllActors(type, A) {
		c++;
		// lA=A;
	}
	// DebugLog("CountActors("$type$") = "$c$" [first="$GetAny(type)$" last="$lA$"]");
	if (bDebugLogging && type != class'PlayerPawn' && type != class'Spectator') { DebugLog("CountActors("$type$") = "$c); }
	return c;
}

function Mutate(String str, PlayerPawn Sender) {
	if (bAllowMutateSwitch) {
		if (str~="suggest") {
			ChooseNextMap();
			Sender.ClientMessage("Recommended map: "$ ChooseNextMap() $" last played "$ (DaysSince1970() - MapRecord(ChooseNextMap()).DateLastPlayed) $" days ago [Beaten: "$ConsideredMaps$"]");
		}
		if (
			(str~="nextmap" && (Sender.bAdmin || CountPlayers()==1))
			|| str ~= "nextmap..."
			// || str ~= "nextmap "$Level.Game.AdminPassword
		) {
			if (Level.Game.bGameEnded) {
				DoLevelSwitch();
			}
			Level.Game.bGameEnded = (FRand()<0.3);
			Sender.ClientMessage("Repeat call to switch map to "$ ChooseNextMap() $" (state= "$ Level.Game.bGameEnded $")");
		}
		if (
			(str~="scanmaps" && (Sender.bAdmin || CountPlayers()==1))
			|| str ~= "scanmaps..."
		) {
			bDoMapScan=True;
			bMapScanDone=False;
			ScanMaps();
		}
	}
	// CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

#ifdef CATCH_LEVEL_SWITCH
event Tick(float DeltaTime) {

	if (!bInterceptTravel) return;

	// bInterceptTravel = False;

	// check for levelchange
	if (Level.NextURL != "") {
		// NextMap = left(Level.NextURL, instr(Level.NextURL,"."));
		// if (NextMap == "") return;  // maybe a ?restart, Serverpackages remain
		NormalLog("Tick() intercepted LevelChange to: "$ Level.NextURL);
		// NextMap = ChooseNextMap(); // Should be already chosen!
		if (NextMap == "")
			NextMap = ChooseNextMap();
		NormalLog("Tick() is attempting to force: "$NextMap);
		Level.NextURL = NextMap;
		// TODO CONSIDER: Level.ProcessServerTravel(...);
		bInterceptTravel = False;
	}
}
#endif

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
	if (Victim!=None && Victim.PlayerReplicationInfo!=None && InstigatedBy!=None && InstigatedBy.PlayerReplicationInfo!=None && (Victim.PlayerReplicationInfo.Team != InstigatedBy.PlayerReplicationInfo.Team || TeamGame(Level.Game)==None)) {
		currentMap.TotalDamageDone += ActualDamage;
	}
}

function bool ScanMaps(optional String search) {
	local string FirstMap, NextMap, TestMap, MapName;
	local int availableCount,crashCount,missingCount,unknownCount;
	local int count,i;
	local String prefix;
	// prefix = Botmatch.Parent.Default.MapPrefix;
	// prefix = Botpack.CTFGame.Default.MapPrefix;
	// DebugLog("ScanMaps(): Starting new scan...");
	NormalLog("Iterate maps running...");

	count = 0;
	// Reset bOnDisk info, because we are about to regenerate it:
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "") {
			if (MapStats[i].bOnDisk == False) {
				missingCount++;
			}
			MapStats[i].bOnDisk = False;
			count++;
		}
	}
	NormalLog("Total maps in database: "$count);

	prefix = Level.Game.Default.MapPrefix;
	FirstMap = GetMapName(prefix, "", 0);
	NextMap = FirstMap;
	count = 0;
	while (!(FirstMap ~= TestMap)) {
		if( ! ( Left(NextMap,Len(NextMap)-4) ~= (prefix$"-tutorial") ) ) {
			// Add the map.

			// DebugLog("ScanMaps(): "$NextMap);
			count++; // maybe don't count if crashed?
			if (StrEndsWith(NextMap,".unr")) {
				MapName = StrBeforeLast(NextMap,".unr");
			} else {
				MapName = NextMap;
			}

			// Ensure a record exists for the map:
			// MapIndex(MapName);
			// MapStats[MapIndex(MapName)].bOnDisk = True;
			MapRecord(MapName).bOnDisk = True;

			if (MapRecord(MapName).bCrashes) {
				crashCount++;
			} else {
				availableCount++;
				if (MapRecord(MapName).PreferredPlayers==0)
					unknownCount++;
			}

			if (search != "") {
				if (MapName ~= search) {
					return True;
				}
			}

		}
		// Get the map.
		NextMap = GetMapName(prefix, NextMap, 1);
		// Text to see if this is the last.
		TestMap = NextMap;
	}
	// Broadcast because: it should never happen during play, so if it does, we want to know about it!
	BroadcastMessage("MapStats found "$ availableCount $" available "$ prefix $" maps.");
	NormalLog("ScanMaps() Found "$ availableCount $" available "$ prefix $" maps out of "$ count $" known, where "$ crashCount $" crash, "$ missingCount $" are missing, and "$ unknownCount $" have unknown size.");
	return False;
}

/*
// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	local bool hideMessage;
	hideMessage = False;
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrStartsWith(Msg,"!")) {
			hideMessage = CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage || !bSwallowSpokenCommands);
}

// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local Actor A;
	local String result;
	local int i,j;
	local String squishedName;
	local String url;
	local String rebuilt_string; // CONSIDER: instead of rebuilding the string, we could just use StrAfter(line," ") one or more times.
	local String command;
	// local PlayerSettings ps;
	local String stateStr;

	if (bOnlyAdmin && !Sender.bAdmin) {
		return False;
	}

	// ps = GetPlayerSettingsFor(Sender);
	#define ps GetPlayerSettingsFor(Sender)

	// NormalLog("ActorEditor.CheckMessage() ("$Sender$"): "$Msg$"");
	argcount = SplitString(line," ",args);

	command = args[0];

	if (command ~= "flash") {
		ps.bFlash = !ps.bFlash;
		stateStr = "off";
		if (ps.bFlash)
			stateStr = "on";
		// if (ps.bFlash)
		FlashMessageToPlayer(Sender,"damage flash = "$stateStr,InfoColor,0,2,true);
		// else Sender.ClearProgressMessages();
		Sender.ClientMessage("Your damage flash is "$stateStr);
		return True;
	}

	if (command ~= "damage") {
		ps.bSeeDamageGiven = !ps.bSeeDamageGiven;
		stateStr = "off";
		if (ps.bSeeDamageGiven)
			stateStr = "on";
		Sender.ClientMessage("Your showdamage is "$stateStr);
		// if (ps.bFlash) 
		FlashMessageToPlayer(Sender,"show damage = "$stateStr,SentPainColor,1,2,True);
		return True;
	}

	if (command ~= "pain" || command ~="mydamage") {
		ps.bSeeDamageReceived = !ps.bSeeDamageReceived;
		stateStr = "off";
		if (ps.bSeeDamageReceived)
			stateStr = "on";
		Sender.ClientMessage("Your show pain is "$stateStr);
		FlashMessageToPlayer(Sender,"show pain = "$stateStr,ReceivedPainColor,7,2,True);
		return True;
	}

	if (command ~= "alldamage") {
		ps.bSeeAllDamage = !ps.bSeeAllDamage;
		stateStr = "off";
		if (ps.bSeeAllDamage)
			stateStr = "on";
		Sender.ClientMessage("show alldamage = "$stateStr);
		FlashMessageToPlayer(Sender,"Your show all damage is "$stateStr,InfoColor,3,2,True);
		return True;
	}

	if (command ~= "HELP") {
		Sender.ClientMessage("TrackDamage commands: flash damage pain alldamage");
		return True;
	}

	return False;

}

function FlashMessageToPlayer(PlayerPawn p, string Msg, Color msgColor, optional int linenum, optional int duration, optional bool bAdditional, optional bool bBeep) {
	if (linenum == 0)
		linenum = 4;
	if (duration == 0)
		duration = 2;
	if (!bAdditional)
		p.ClearProgressMessages();
	p.SetProgressTime(duration);
	p.SetProgressColor(msgColor,linenum);
	p.SetProgressMessage(Msg,linenum);
	if (bBeep)
		p.PlaySound(sound'Beep', SLOT_Interface, 2.5, False, 32, 32);
}
*/

// #include "../../JLib/findactor.uc.jpp"

#include "../../JLib/jlib.uc.jpp"

