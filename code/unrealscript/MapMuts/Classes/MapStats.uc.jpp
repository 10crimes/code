// vim: tabstop=2 shiftwidth=2 noexpandtab filetype=uc

// TODO: if the map does not exist, the log shows "Failed to load"... but MapStats does not retry with another map.  How can we fix this?  Maybe Tick() can catch it...

// TODO: Should we avoid updating "play" stats when no players are around? e.g. TotalDamage,FragCount,HoursPlayed.

// TODO: bDetectCrashingMaps - the crashed map detection might sometimes automatically mark a map as crashed innaccurately (e.g. if this mod switches the map, but the server is restarted before it actually loads).  Also, auto recovery attempt for fixed crashed maps might be undesirable, if there is a risk of crashing the server.  Therefore until one of these features is perfect, the admin might prefer to disable them.  See bRetryCrashedMaps.

// TODO NASTY BUG: it tried to switch to a previously crashed map which was no longer on disk - we got Failed to load 'CTF-Lucius-EBTC125': Can't find file 'CTF-Lucius-EBTC125' but the map didn't switch and there was no retry by the Timer.  When I tried to join the server, my UT went blank, and the log repeated: RPC bunch overflowed
//      maybe tick can catch nasty situations like this and switch to a different map

// TODO: Instead of players vetoing maps with "no" we could give them a list of 3,4,5 need-to-be-played maps and let them pick one.

// TODO: Allow automatically add muts to certain maps.  (e.g. instagib for the no weapon ctf maps)

// All XOL's info is stored in Fate.BestFitMapList

// DONE: mutate search <part_of_mapname>   so we can see what maps are installed even if they aren't in mapvote
// DONE: add "good map" "bad map" detection (copy it from ATB!)

// Is it bad HCI to call it "good map"/"bad map" when the actual effect is to "see the map more/less often"?

// CONSIDER: on the one hand, people voting a map means it's a good map
//           on the other hand, we want to offer maps people don't play much, until it is rated

#define TESTING

// Do not change this once you already have data.  It will change the hashing algorithm and all your data will be missed/lost/stuck.
#define MaxData 3000

class MapStats expands Mutator config(MapStats);

// MapScale is an estimate of the universal constant for ideal player count estimation wrt actor distance.  (Higher values bring actors closer together, making it think maps are smaller, so it will make us play larger maps?)
#define MapScale 400
#define NumberOfSpawnPointsScaled (NumberOfSpawnPoints*0.6)
#define FallbackValue (NumberOfSpawnPointsScaled*MapScale)

// I thought this was needed for immediate switch to work 100%, but I'm not 100% sure.
// With or without this, *sometimes* it didn't change to NextMap at all, but to the next map in UT's cycle I think (Gauntlet/Command/...).  OK I think I fixed that.
// #define CATCH_LEVEL_SWITCH
// CATCH_LEVEL_SWITCH works!  But it changes the map we had chosen.  Well we did set NextMap="" (for other reasons).
#define MAP_RATING
#define MAP_TAGS
// PLAYERS_CAN_VETO affects bEndGameSwitchMap
#define PLAYERS_CAN_VETO
#define LIST_RECENTLY_PLAYED
#define MinimumNosForVeto 1

var config bool bShowLevelEnterText;
var config bool bEndGameSwitchMap;
var config int EndGameSwitchSeconds;
var config bool bAllowMutateSwitch;
var config bool bEmptyServerSwitchMap;
var config int EmptyServerSwitchSeconds;
var config bool bStickWithCurrentMode; // turn it on to keep server playable (no CTF on DM maps etc.!) - turn it off to scan all map-sizes
var config bool bSetMaxPlayers;
var config bool bAutoExpandMaxPlayers;
var config int ServerMinPlayers;
var config int ServerMaxPlayers;
var config bool bLogging;
var config bool bDebugLogging;
var config bool bLogStats;
var config bool bCollectDamage;
var config bool bDoMapScan;
var config bool bEstimatePreferredPlayers;
var config bool bDetectCrashingMaps;
// TODO: determine required level switch gametype from prefix or from map itself, thus allowing switching to other gametypes
#ifdef LIST_RECENTLY_PLAYED
var config bool bListRecentlyPlayed;
#endif
#ifdef LIST_RECENTLY_PLAYED
var config String RecentlyPlayedMaps;
#endif
var config String KnownGameTypes;

struct MapInfo {
	var String MapName;
	var float PreferredPlayers;
	var float DateLastPlayed;
	var bool bOnDisk;
	var bool bCrashes;
	var bool bDisabled;
	var int GamesStarted;
	var int GamesEnded;
	var float HoursPlayed;
	var float AveragePlayerFlow;
	var float AveragePlayerCount;
	var int FragCount;
	var float TotalDamage;
	// var int NumberOfSpawnPoints;
	// var int NumberOfWeaponPickups;
	// var int NumberOfPathNodes;
	// var float ActorDistance;
	#ifdef MAP_RATING
	var int GoodVotes;
	var int BadVotes;
	var String RatedUpBy;
	var String RatedDownBy;
	#endif
	#ifdef MAP_TAGS
	var String Tags; // Comma separated list.  If user inputs commas then they are inputting multiple tags.
	#endif
};

var config MapInfo MapStats[MaxData];

var String mapName; // Current map's name, generated at start.
var int mapI; // Current map's index, generated at start.
#define currentMap MapStats[mapI]
var float NumberOfSpawnPoints; // Globalised for FallbackValue

var float StartTime;
var int PlayerCountAtStart;
var bool bMapScanDone;
var bool bDoneGameEnd;
var String ConsideredMaps;
var bool bInterceptTravel;
var String NextMap;
var String RejectedMaps;
#ifdef PLAYERS_CAN_VETO
var int NoCount;
var String VetoersList;
#endif
#ifdef MAP_RATING
#endif

defaultproperties {
bLogging=True
bDebugLogging=False
bDetectCrashingMaps=True
bLogStats=False
bCollectDamage=False
bEstimatePreferredPlayers=True
bEndGameSwitchMap=False
EndGameSwitchSeconds=30
bEmptyServerSwitchMap=False
EmptyServerSwitchSeconds=120
bAllowMutateSwitch=True
bSetMaxPlayers=False
bAutoExpandMaxPlayers=False
ServerMinPlayers=6
ServerMaxPlayers=24
bDoMapScan=True
bShowLevelEnterText=False
bStickWithCurrentMode=True
#ifdef LIST_RECENTLY_PLAYED
bListRecentlyPlayed=False
#endif
KnownGameTypes="CTF:botpack.CTFGame|DM:botpack.DeathMatchPlus:botpack.TeamGamePlus:botpack.LastManStanding|AS:botpack.Assault|BT:BunnyTrack2.BunnyTrackGame"
}

#define MapRecord(X) MapStats[MapIndex(X)]

#define CountPlayers() ( CountActors(class'PlayerPawn') - CountActors(class'Spectator') )

// #define DebugLog(Y); 
#define DebugLog(Y); if (bDebugLogging) { Log("-MapStats- " $ Y); }
// #define NormalLog(Y); 
#define NormalLog(Y); if (bLogging) { Super.Log("[MapStats] " $ Y); }
// Fails: // function NormalLog(String Y) { if (bLogging) { Super.Log(Y); } }
// Fails: // #define Log(Y); NormalLog(Y);

#define BroadcastAndLog(Y); BroadcastMessage(Y); if (bLogging) { Log("[MapStats] Broadcasted: " $ Y); }

#define NiceFloat FloatToString
function String FloatToString(float f) {
	local String s;
	local int i;
	s = String(f);
	i = InStr(s,".");
	if (i>=3) return StrBeforeLast(s,".");
	s = StrBeforeFirst(s,".") $ "." $ Left( StrAfterFirst(s,"."), 3-i ); // may not be accurate enough for 0.000001
	return s;
}
// #define NiceAge(X) Int(((X)+0.5)*24)$"h"
function String NiceAge(float days) {
	local float hours;
	hours = days * 24.0;
	if (hours<1.5) {
		return String(Int(hours*60.0)) $" minutes";
	}
	if (hours>48.0) {
		return String(Int(hours/24.0+0.5)) $" days";
	}
	return String(Int(hours+0.5)) $" hours";
}

function PostBeginPlay() {

	//// Pushing out new default configs during a temporary release:
	// EmptyServerSwitchSeconds=5*60; // XOL is still learning about the maps
	// EmptyServerSwitchSeconds=60*60;
	// bDebugLogging=True;
	// if (FRand()<0.01)
		// bDoMapScan=True;

	mapName = StrBeforeFirst(""$Self,".");
	mapI = MapIndex(mapName);
	NumberOfSpawnPoints = CountActors(class'PlayerStart');

	if (bCollectDamage)
		Level.Game.RegisterDamageMutator(Self);

	// TODO:
	// If we were not added as a mutator, but run in some other way (e.g. as a ServerActor), then we need to register as a mutator:
   // Level.Game.BaseMutator.AddMutator(Self);

	// Register to receive spoken messages in MutatorTeamMessage() below:
	Level.Game.RegisterMessageMutator(Self);

	DoStart();

	SetTimer(5.0,True);

}

function DoStart() {
	// This is actually done when the map is loaded.
	// The game starts when a player joins - see ModifyPlayer().
	local String idealPlayerCount,gotNum,restStr;
	local int count;
	local float avg,num;
	local bool bMustSave;
	// local float NumberOfSpawnPoints;
	local float ActorDistance;

	// ScanMaps();

	NormalLog(mapName $" Last played "$ NiceAge(DaysSince1970() - currentMap.DateLastPlayed) $" ago.");
	if (bLogStats) {
		NormalLog(mapName $" NumberOfSpawnPoints = "$ CountActors(class'PlayerStart'));
		NormalLog(mapName $" NumberOfWeaponPickups = "$ CountActors(class'Weapon'));
		NormalLog(mapName $" NumberOfPathNodes = "$ CountActors(class'PathNode'));
	}

	// Should we regenerate the map's PreferredPlayers estimate with the latest algorithm?
	// DONE: set this False for final release.  If admin really wants them regenerated, he can set them to 0.
	#ifdef TESTING
	#define bRegeneratePreferredPlayers True
	#else
	#define bRegeneratePreferredPlayers False
	#endif
	if (currentMap.PreferredPlayers == 0 || bRegeneratePreferredPlayers) {
		// We are allowed to modify the PreferredPlayers count for this map, and should now do our best

		// DebugLog("Collecting ActorDistance for "$mapName$"...");
		ActorDistance = ( MaxActorDistanceType(class'FlagBase') + MaxActorDistanceType(class'Weapon') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode') ) / 4.0 / Float(MapScale);
		if (bLogStats) {
			NormalLog(mapName $" ActorDistance = "$ ActorDistance);
		}
		if (ActorDistance < 2)
			ActorDistance = 2;
		if (ActorDistance > 32)
			ActorDistance = 32;

		// Get map author's suggested IdealPlayerCount:
		idealPlayerCount = Level.IdealPlayerCount;
		// DebugLog("Getting map author's IdealPlayerCount from \""$idealPlayerCount$"\"...");
		restStr = idealPlayerCount;
		avg = 0.0;
		count = 0;
		do {
			gotNum = StrFilterNum(restStr,true,restStr);
			if (gotNum!="") {
				num = Float(gotNum);
				// DebugLog("MapStats: Got "$num$" from \""$gotNum$"\" with rest="$restStr);
				if (num>0) {
					// avg = (count*avg + num) / (count+1);
					avg += num;
					count++;
				}
				if (StrStartsWith(restStr,"-"))
					restStr = Mid(restStr,1);
			}
		} until (gotNum == "");
		if (count>0) avg = avg / count;

		NormalLog(mapName $" Previous PreferredPlayers = "$ currentMap.PreferredPlayers);

		// Did we get any numbers from IdealPlayerCount?
		if ( count>0 ) {
			// Build estimated PreferredPlayers from avg, NumberOfSpawnPoints and ActorDistance:
			// DebugLog(mapName$" Got IdealPlayerCount "$avg$" from \""$idealPlayerCount$"\".");
			if (avg>20) avg=20;
			currentMap.PreferredPlayers = avg;
			// Mix it with NumberOfSpawnPoints and ActorDistance:
			currentMap.PreferredPlayers = 0.4*avg + 0.3*NumberOfSpawnPointsScaled + 0.3*ActorDistance;
			NormalLog(mapName$" Estimating from Ideal=\""$ idealPlayerCount $"\"("$ NiceFloat(avg) $") PlayerStarts="$ NiceFloat(NumberOfSpawnPointsScaled) $" and ActorDistance="$ NiceFloat(ActorDistance) $"");
		} else {
			// Mix just NumberOfSpawnPoints and ActorDistance:
			currentMap.PreferredPlayers = 0.5*NumberOfSpawnPointsScaled + 0.5*ActorDistance;
			NormalLog(mapName$" Estimating from PlayerStarts="$ NiceFloat(NumberOfSpawnPointsScaled) $" and ActorDistance="$ NiceFloat(ActorDistance) $"");
		}
		bMustSave = True;

	}

	NormalLog(mapName$" PreferredPlayers = "$ NiceFloat(currentMap.PreferredPlayers));

	// If it was marked as crashed or not on-disk, We MUST mark this map as working!
	if (currentMap.bCrashes || !currentMap.bOnDisk) bMustSave=True;
	// Update some stats:
	currentMap.GamesStarted++;
	// #ifdef TESTING
	// currentMap.DateLastPlayed = DaysSince1970(); // We need this to stop empty-switching to the same map every time.  But if we only want to record when a player actually plays the map, remove this line.
	// #else
	currentMap.DateLastPlayed = (currentMap.DateLastPlayed + DaysSince1970()) / 2.0; // Compromise: we mix the two values (it becomes half as old).
	// #endif
	// if (currentMap.bCrashes) { NormalLog("FIXED! Map "$ mapName $" was previously crashing, but now works!"); } // Can't do, this is usually set to true by DoLevelSwitch :P
	currentMap.bCrashes = False; // Was most likely set just before the server switched to this map.  We reset it here, to prove this is a non-crashing map.
	currentMap.bOnDisk = True; // Also proved here (but should be already known from ScanMaps()).

	// #define bSaveEarly False
	// if (bSaveEarly && (bCollectMapStats || bEstimatePreferredPlayers)) bMustSave=True;
	if ( bMustSave ) {
		DebugLog("DoStart(): Calling SaveConfig()");
		SaveConfig();
		bMustSave = False;
	}

	if (bSetMaxPlayers && currentMap.PreferredPlayers>0) {
		Level.Game.MaxPlayers = 2*Int( (currentMap.PreferredPlayers+1.0)/2.0 );
		if (Level.Game.MaxPlayers < ServerMinPlayers)
			Level.Game.MaxPlayers = ServerMinPlayers;
		if (Level.Game.MaxPlayers > ServerMaxPlayers)
			Level.Game.MaxPlayers = ServerMaxPlayers;
		NormalLog("bSetMaxPlayers: MaxPlayers set to "$ Level.Game.MaxPlayers);
	}

}

function ModifyPlayer(Pawn Other) {
	// if (PlayerPawn(Other) != None) {
	if (Other!=None && Other.PlayerReplicationInfo != None) {
		// DebugLog("ModifyPlayer("$ Other.getHumanName() $") was called.");
		// TODO CONSIDER: Is this method innacurate, if ATB moves the player, they might have 1 Death before they even spawn!
		if (/*PlayerPawn(Other)!=None && Spectator(Other)==None &&*/ Other.PlayerReplicationInfo.Deaths == 0) {
			// Latest player/bot join/first-spawn!
			DebugLog("ModifyPlayer("$ Other$"): "$ Other.getHumanName() $" joined at "$ Level.TimeSeconds);

			if (StartTime == 0 && PlayerPawn(Other)!=None) {
				// First player to spawn this game!

				NormalLog("Detected start of game (first player spawn) at "$ Level.TimeSeconds);
				StartTime = Level.TimeSeconds;
				// We don't want to set PlayerCountAtStart at the moment the first player spawns, in case more are downloading.
				// We wait until 30 seconds into the map (actually the next frag).  See below.

				// Update some stats for this map:
				currentMap.DateLastPlayed = DaysSince1970();
				#ifdef LIST_RECENTLY_PLAYED
				RecentlyPlayedMaps = StrReplace(RecentlyPlayedMaps,mapName$" ","") $ mapName $ " ";
				if (Len(RecentlyPlayedMaps)>60) {
					RecentlyPlayedMaps = StrAfterFirst(RecentlyPlayedMaps," ");
				}
				#endif
				// bMustSave = True;
				SaveConfig(); // In case mapswitch is forced by admin or mapvote or another mod.

			}
			// currentMap.DateLastPlayed = DaysSince1970(); // hope that a SaveConfig happens later (should happen in DoEnd())

			if (PlayerPawn(Other)!=None && Other.PlayerReplicationInfo.Deaths == 0 && bShowLevelEnterText && Level.LevelEnterText != "") {
				PlayerPawn(Other).ClientMessage(Level.Title $ " : " $ Level.LevelEnterText);
			}

		} else {

			// A frag / someone/thing died
			currentMap.FragCount++;
			if (StartTime == 0) { // should no longer be possible
				// First ever frag!
				// StartTime = Level.TimeSeconds;
				// DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting StartTime="$Level.TimeSeconds);
			}
			if (PlayerCountAtStart == 0 && Level.TimeSeconds>=30) { // give them 30 seconds to download the map / join the server
				PlayerCountAtStart = CountPlayers();
				DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting PlayerCountAtStart="$ CountPlayers() $" at "$ Level.TimeSeconds);
			}

		}
	}
	Super.ModifyPlayer(Other);
}

event Timer() {

	// Mid-game checks:
	if (bEmptyServerSwitchMap && CountPlayers()==0 /* CountActors(class'PlayerPawn')==CountActors(class'UTServerAdminSpectator') */ && Level.TimeSeconds>EmptyServerSwitchSeconds && FRand() < 0.2) {
		NormalLog("Timer(): bEmptyServerSwitchMap=True - auto switching at "$Level.TimeSeconds$"");
		// Level.Game.bGameEnded = True;
		// bDoneGameEnd = True; // This prevents DoEnd() from being called, which is good since it's an idle server switch, not a real end-game.
		// redundant: bCanChooseUnsizedMaps = True;
		DoLevelSwitch();
	}

	#define bIgnoreMapSizeWhenChangingServerMax False
	if (bAutoExpandMaxPlayers) {
		// Need to expand?
		if (CountPlayers()+1 > Level.Game.MaxPlayers && Level.Game.MaxPlayers+2 <= ServerMaxPlayers) {
			if (bIgnoreMapSizeWhenChangingServerMax || Level.Game.MaxPlayers < currentMap.PreferredPlayers*2) {
				Level.Game.MaxPlayers += 2;
				NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers increased to "$ Level.Game.MaxPlayers);
			}
		}
		// Need to shrink?
		if (CountPlayers() < ServerMinPlayers && Level.Game.MaxPlayers-2 >= ServerMinPlayers && FRand()<0.01) {
			if (bIgnoreMapSizeWhenChangingServerMax || Level.Game.MaxPlayers > currentMap.PreferredPlayers) {
				Level.Game.MaxPlayers -= 2;
				NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers reduced to "$ Level.Game.MaxPlayers);
			}
		}
		// Level.Game.MaxPlayers = 2*Int( (CountActors(class'PlayerPawn')+1.0)/2.0 );
	}

	// Check if game has just ended:
	if (Level.Game.bGameEnded && !bDoneGameEnd) {
		DoEnd();
		bDoneGameEnd = True;
		if (bEndGameSwitchMap) {
			NextMap = ChooseNextMap();
			// BroadcastAndLog("Map will change to "$ NextMap $" in "$EndGameSwitchSeconds$" seconds.");
			// #ifdef PLAYERS_CAN_VETO
			// BroadcastAndLog("Next map will be "$ NextMap $"... say no to reject.");
			// #else
			// BroadcastAndLog("Next map will be "$ NextMap $".");
			// #endif
			// BroadcastAndLog("(Other maps: "$ ConsideredMaps $")");
			BroadcastAndLog("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
			// We do the switch in the if clause below, when Timer is next called.
			SetTimer(EndGameSwitchSeconds,False);
		} else {
			NormalLog("bEndGameSwitchMap=False, but chosen map would have been: "$ChooseNextMap());
		}
		return;
	}

	// Check if game is well over:
	if (Level.Game.bGameEnded && bDoneGameEnd && bEndGameSwitchMap) {
		DoLevelSwitch();
	}

}

function DoEnd() {
	local float playerChangeThisGame,averagePlayerCountThisGame;
	local float totalHours,deltaHours,newTotalHours;

	totalHours = currentMap.HoursPlayed;
	deltaHours = (Level.TimeSeconds - StartTime) / 60.0 / 60.0;

	// if ( (PlayerCountAtStart == 0 && CountPlayers() == 0)
		// || (deltaHours>0.5 && (PlayerCountAtStart == 0 || CountPlayers() == 0))
	// ) {
		// DebugLog("Not updating any stats for this game on "$mapName$", since it took "$(deltaHours*60)$" minutes, and either started or ended with only bots.");
		// // return;
		// // Maybe we should do currentMap.GamesStarted--;  Chances are that stat has already been saved.
		// currentMap.GamesStarted--;
		// // Problem: map's TotalDamage and Deaths have increased, and we can't recover the old values!
	// }

	currentMap.GamesEnded++;
	// currentMap.DateLastPlayed = DaysSince1970();

	newTotalHours = currentMap.HoursPlayed + deltaHours;

	playerChangeThisGame = CountPlayers() - PlayerCountAtStart;
	currentMap.AveragePlayerFlow = (totalHours*currentMap.AveragePlayerFlow + deltaHours*playerChangeThisGame) / newTotalHours;

	averagePlayerCountThisGame = (CountPlayers() + PlayerCountAtStart) / 2.0; // approx ^^
	currentMap.AveragePlayerCount = (totalHours*currentMap.AveragePlayerCount + deltaHours*averagePlayerCountThisGame) / newTotalHours;

	currentMap.HoursPlayed = newTotalHours;

	if (bLogStats) {
		NormalLog(mapName $" Updated for "$ deltaHours $" hours of play.");
		NormalLog(mapName $" GamesStarted = "$ currentMap.GamesStarted);
		NormalLog(mapName $" GamesEnded = "$ currentMap.GamesEnded);
		NormalLog(mapName $" TotalHours = "$ currentMap.HoursPlayed);
		if (bCollectDamage)
		NormalLog(mapName $" FragCount = "$ currentMap.FragCount);
		NormalLog(mapName $" TotalDamage = "$ currentMap.TotalDamage);
		NormalLog(mapName $" Damage/sec = "$ (currentMap.TotalDamage / currentMap.HoursPlayed / 60.0 / 60.0));
		NormalLog(mapName $" AveragePlayerCount = "$ currentMap.AveragePlayerCount);
		NormalLog(mapName $" AveragePlayerFlow = "$ currentMap.AveragePlayerFlow);
	}

	DebugLog("DoEnd() calling SaveConfig()");
	SaveConfig();

}

function DoLevelSwitch() {
	local float num;
	local PlayerPawn p;
	local String gametype,url;

	if (NextMap == "") {
		NextMap = ChooseNextMap();
	}

	// MapRecord(NextMap).DateLastPlayed = DaysSince1970(); // If we are auto-switching maps, we will keep cycling through the same set, if we don't update the date somehow.  (Might be nicer to set date = 1 day ago, unless a player joins and makes it more recent.  But that's still not ideal.  What is?)  OK moved to DoStart(), where we move the time half-way.
	if (bDetectCrashingMaps) {
		// We mark the map as crashed - it will be unmarked if it loads successfully.
		MapRecord(NextMap).bCrashes = True;
	}
	DebugLog("DoLevelSwitch() calling SaveConfig()");

	// CONSIDER TODO: Shouldn't we do DoEnd() here?  Well it should be already done, provided we only get here by activation after the end of a game.
	SaveConfig();

	BroadcastAndLog("Considered maps: "$ ConsideredMaps);
	// BroadcastAndLog("Switching to "$ NextMap $" now.");

	num = (DaysSince1970() - MapRecord(NextMap).DateLastPlayed);
	if (num<2.0) {
		// NormalLog(mapName$" was last played "$ Int(24*num+0.5) $" hours ago.");
		BroadcastAndLog("Switching to "$ NextMap $", last played "$ Int(24.0*num+0.5) $" hours ago.");
	} else {
		// NormalLog(mapName$" was last played "$ Int(num+0.5) $" days ago.");
		BroadcastAndLog("Switching to "$ NextMap $", last played "$ Int(num+0.5) $" days ago.");
	}

	#ifdef CATCH_LEVEL_SWITCH
	bInterceptTravel = True;
	Enable('Tick');
	#endif
	// if (!StrEndsWith(Caps(NextMap),".UNR"))
		// NextMap = NextMap $ ".unr";
	// UTServerAdmin(GetAny(class'UTServerAdmin')).ConsoleCommand("admin servertravel "$ NextMap );
	// Log("MapStats.DoLevelSwitch() Switching to map: "$ NextMap);

	// New method, call anyAdminPlayer.ConsoleCommand().  This solves the problems with Level.ServerTravel() "kicking" players out and Level.Game.ProcessServerTravel() changing to the wrong map.
	foreach AllActors(class'PlayerPawn',p) {
		// break; // Get the last one - The first one is useless!
		P.PreClientTravel(); // Maybe doing this makes it ok to use Level.ServerTravel later :o
	}
	url = NextMap;
	gametype = GetGameTypeFromPrefix(NextMap);
	if (gametype == "") {
		NormalLog("DoLevelSwitch() Warning! Unrecognised gametype "$ StrBeforeFirst(NextMap,"-") $" - please update KnownGameTypes.");
		// TODO CONSIDER: Would it be better to do "game=" here, rather than leaving the server on the current mode - it may use the gametype in the map's LevelProperties.
	} else {
		url = url $"?game="$ gametype;
	}
	// url = url $"?mutator=...";
	if (p != None) {
		p.bAdmin = True;
		NormalLog("DoLevelSwitch() Calling "$p.getHumanName()$".ConsoleCommand(\"admin servertravel "$url$"\")");
		p.ConsoleCommand("admin servertravel "$url);
		p.bAdmin = False;
	} else {
		//// Fallback method.
		NormalLog("DoLevelSwitch() No pawn available for consolecommand, trying Level.ServerTravel(\""$ url $"\",false)");
		// Did not work:
		// Level.NextURL = NextMap;
		Level.ServerTravel(url,false); // This works for the server.  I think it might cause trouble for joined clients though.
		// Level.Game.ProcessServerTravel(NextMap,false); // This did not work
	}

	// bDoneGameEnd = False;
	// SetTimer(0,False); // repeat calls should (may) be cancelled already

	// We can recover from "Failed to load 'CTF-MazonSieged-006': Can't find file 'CTF-MazonSieged-006'" with:
	NextMap = "";
	SetTimer(5,False);
	// However (TODO) this may break bInterceptTravel.
}

function String GetGameTypeFromPrefix(String map) {
	local String prefix;
	local String s;
	prefix = Caps(StrBeforeFirst(map,"-"));
	s = "|"$ Caps(StrReplaceAll(KnownGameTypes," ","")) $"|";
	if ( StrContains(s, "|"$prefix$":") ) {
		s = StrAfterFirst(s, "|"$prefix$":");
		s = StrBeforeFirst(s, "|");
		s = StrBeforeFirst(s, ":"); // instead of taking the first, we could split them and take a random one
		return s;
	} else {
		return "";
	}
}

function int HashStr(String str, optional int max) {
	local int hash;
	local int ch;
	local int i;
	if (max == 0) max = MaxData;
	for (i=0;i<Len(str);i++) {
		ch = Asc(Mid(str,i,1));
		hash += ch;
		while (hash > max) {
			hash -= max;
		}
		while (hash < 0) {
			hash += max;
		}
	}
	return hash;
}

function int MapIndex(String mapName) {
	local int i;
	i = HashStr(mapName,MaxData);
	while (true) {
		if (MapStats[i].MapName == "") { // empty
			MapStats[i].MapName = mapName;
			return i;
		}
		if (MapStats[i].MapName == mapName) { // hit
			return i;
		}
		// collision, try next slot
		if (bDebugLogging && FRand()<0.01) { DebugLog("MapIndex("$mapName$"): collision "$ mapName $" with "$MapStats[i].MapName$" at "$i); }
		i++;
		if (i>=MaxData) {
			// i = FRand()*MaxData;
			i = HashStr(mapName,MaxData);
			Log("[MapStats] Warning! MapIndex(\"" $ mapName $ "\") hash + collision offset >= MaxData - we are either unlucky, or the map database is full; forcing overwrite of ["$i$"] "$MapStats[i].MapName$" !");
			MapStats[i].MapName = mapName;
			// TODO: we should also clear [i]'s stats!
			return i;
		}
	}
	// never reached: return 0;
}

function float AverageActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local float totalDistance;
	local int totalCount,realTotalCount;
	local float distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	realTotalCount=0;
	totalDistance=0;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
					distance = VSize(A.Location-B.Location);
					totalDistance += distance;
					// totalDistance += distance*distance;
					realTotalCount++;
				}
			}
		}
	}
	if (realTotalCount < 2)
		return FallbackValue;
	totalDistance = totalDistance / realTotalCount;
	DebugLog("Average distance of " $ realTotalCount $ " x " $ type $ " = " $ NiceFloat(totalDistance));
	return totalDistance;
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float MaxActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local int totalCount;
	local float bestDistance,distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	if (totalCount < 2)
		return FallbackValue;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
					distance = VSize(A.Location-B.Location);
					if (distance > bestDistance)
						bestDistance = distance;
				}
			}
		}
	}
	DebugLog("Max distance between " $ totalCount $ " x " $ type $ " = " $ NiceFloat(bestDistance));
	return bestDistance; // this is actually average squared-distance, we should square-root it.
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float DaysSince1970() {
	return (Level.Year-1970.0)*365.25 + Level.Month*30.0 + Level.Day + Level.Hour/24.0 + Level.Minute/24.0/60.0 + Level.Second/24.0/60.0/60.0;
}

function float ScoreForNextMap(int nextI, int currentNumPlayers) {
	local float ageInDays, playerDiff, result;
	// if (MapStats[nextI].DateLastPlayed>719540) MapStats[nextI].DateLastPlayed = MapStats[nextI].DateLastPlayed - 719540; // legacy: when i changed my date calculation :P
	ageInDays = DaysSince1970() - MapStats[nextI].DateLastPlayed;
	// if (ageInDays>719050) ageInDays = ageInDays - 719050; // legacy: when i changed my date calculation :P
	// if (ageInDays<0) ageInDays = -ageInDays; // legacy: when i changed my date calculation :P
	// Originally I gave +0.5 to encourage another player to join.
	// Now I give +/-0.5random in order to be fair on currentNumPlayers==Int and PreferredPlayers==Float.
	// #define deltaPlayers ( FRand() - 0.5 )
	#define deltaPlayers (FRand()*0.5)
	playerDiff = Abs(currentNumPlayers + deltaPlayers - MapStats[nextI].PreferredPlayers);
	playerDiff += 2.0; // Makes playerDiff more fuzzy, less significant, so that cycle is really more based on age of map.  This prevents us from playing the same maps repeatedly, just because the player size is "perfect".  This also avoids the possiblity of a divide-by-zero below.
	// if (currentNumPlayers==0) playerDiff = 12.0; // When the server is empty, all maps have the same weighting in terms of player count
	ageInDays += 0.01;
	// TODO: tweaks zeroed until stats are fixed:
	#define flowTweak (0.0*MapStats[nextI].AveragePlayerFlow*0.125)
	// playerTweak encourages maps with larger playercount.
	#define playerTweak (0.0*MapStats[nextI].AveragePlayerCount*0.05)
	// ratingTweak makes a map 1 hour older * number of good ratings (-bad).
	#define ratingTweak (2.0/24.0*(MapStats[nextI].GoodVotes - 2*MapStats[nextI].BadVotes))
	// TODO: anyway playerTweak should work wrt currentNumPlayers!  playerTweak tends towards slightly larger maps, in order to encourage players to join? :o
	// if (currentNumPlayers==0 && MapStats[nextI].PreferredPlayers==0) // When the server is empty
		// ageInDays += 5.0; // boost the score of maps whose size is unknown
	result = 384.0 * ( ageInDays + flowTweak + playerTweak + ratingTweak) / playerDiff;
	if (bDebugLogging && FRand()<0.05) {
		DebugLog("Score for "$ MapStats[nextI].MapName $" PreferredPlayers="$ NiceFloat(MapStats[nextI].PreferredPlayers) $"] is: "$ NiceFloat(result));
		DebugLog("  ( age "$ NiceFloat(ageInDays) $"d + tweaks "$ NiceFloat(flowTweak) $" + "$ NiceFloat(playerTweak) $" + "$ NiceFloat(ratingTweak) $" ) / playerDiff "$ NiceFloat(playerDiff));
	}
	return result;
}

// function bool ExistsOnDisk(String mapName) {
	// return ScanMaps(mapName);
// }

function String ChooseNextMap() {
	local String bestMap;
	local float bestScore;
	local int i,currentNumPlayers;
	local float mapScore;
	local bool bCanChooseUnsizedMaps;
	// DebugLog("CountActors(UTServerAdmin) = "$CountActors(class'UTServerAdmin'));
	// DebugLog("CountActors(PlayerPawn) = "$CountActors(class'PlayerPawn'));
	if (!bMapScanDone) {
		if (bDoMapScan) {
			DebugLog("ChooseNextMap(): Scanning maps for "$Level.Game.Default.MapPrefix$" ...");
			ScanMaps();
			bDoMapScan=False;
			SaveConfig(); // I guess this could be optional, but it would slow down any subsequent boot if we haven't saved :P
		} else {
			DebugLog("NOT scanning maps until you set MapMuts.MapStats bDoMapScan True");
		}
		bMapScanDone = True;
	}
	ConsideredMaps="";
	currentNumPlayers = CountPlayers();
	if (currentNumPlayers == 0) {
		bCanChooseUnsizedMaps = True;
		currentNumPlayers = (ServerMaxPlayers+1)*FRand();
	} // TODO: If MapStats is the server's only method of map switching, it may refuse to ever try a new map.  (e.g. if bEmptyServerSwitchMap is unset)
	NormalLog("Current players = "$ currentNumPlayers $", choosing...");
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].PreferredPlayers > 0 || (bCanChooseUnsizedMaps && MapStats[i].MapName!="")) {
			mapScore = ScoreForNextMap(i,currentNumPlayers);
			if (bestMap == "" || mapScore > bestScore) {
				if (MapStats[i].bDisabled) // && !bCanChooseUnsizedMaps)
					continue;
				if (StrContains(" "$RejectedMaps$" "," "$MapStats[i].MapName$" ")) {
					continue;
				}
				if (!MapStats[i].bOnDisk) {
					if (bDebugLogging && FRand()<0.01) {
						DebugLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because server no longer has it!");
					}
					// MapStats[i].bCrashes = True;
					continue;
				}
				if (MapStats[i].bCrashes) {
					#define bRetryCrashedMaps True
					if (bRetryCrashedMaps && FRand()<0.01) {
						NormalLog("ChooseNextMap(): "$ MapStats[i].MapName $" previously crashed but considering it, to see if it has been fixed.");
					} else {
						// Too frequent here, but get reported occasionally above: NormalLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because it crashes!");
						continue;
					}
				}
				if ( bStickWithCurrentMode && !( StrBefore(MapStats[i].MapName,"-") ~= StrBefore(currentMap.MapName,"-") ) ) {
					// Prefix does not match current map, rejecting.
					continue;
					// TODO: Otherwise if we do select a map with a different gametype/prefix, we should also change gametype when we switch level!
				}
				// This is our new best map!
				// if (bestMap!="" && FRand()>0.2) {

				// If it's actually better than the one before, log it:
				if (bestMap!="") {
					// ConsideredMaps = ConsideredMaps $ bestMap $"("$Left(String(mapScore),5)$")"$ " ";
					if (Level.Game.bGameEnded) {
						ConsideredMaps = ConsideredMaps $ bestMap $" ";
					} else {
						ConsideredMaps = ConsideredMaps $ bestMap $"("$ NiceAge(DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $","$ NiceFloat(MapRecord(bestMap).PreferredPlayers) $")"$ " ";
					}
					if (Len(ConsideredMaps)>60)
						ConsideredMaps = StrAfterFirst(ConsideredMaps," ");
					// NormalLog("  Dropped: "$bestMap$" (score "$ NiceFloat(bestScore) $", age "$ NiceAge(DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $")");
					NormalLog("  "$MapStats[i].MapName$" (score "$ NiceFloat(mapScore) $", age "$ NiceAge(DaysSince1970() - MapStats[i].DateLastPlayed) $", players "$ NiceFloat(MapStats[i].PreferredPlayers) $")");
				}

				bestMap = MapStats[i].MapName;
				bestScore = mapScore;
			}
		}
	}
	NormalLog("Best map was "$ bestMap $" (score "$ NiceFloat(bestScore) $", age "$ NiceAge(DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $", players "$ NiceFloat(MapRecord(bestMap).PreferredPlayers)$ ")");
	NormalLog("Other considered maps were: "$ ConsideredMaps);
	return bestMap;
}

/*
function Actor GetAny(class<Actor> type) {
	local Actor A;
	foreach AllActors(type, A) {
		return A;
	}
	return None;
}
*/

function int CountActors(class<Actor> type) {
	local Actor A;
	// local Actor lA;
	local int c;
	foreach AllActors(type, A) {
		c++;
		// lA=A;
	}
	// DebugLog("CountActors("$type$") = "$c$" [first="$GetAny(type)$" last="$lA$"]");
	if (bDebugLogging && type != class'PlayerPawn' && type != class'Spectator') { DebugLog("CountActors("$type$") = "$c); }
	return c;
}

#ifdef CATCH_LEVEL_SWITCH
event Tick(float DeltaTime) {

	if (!bInterceptTravel) return;

	// bInterceptTravel = False;

	// check for levelchange
	if (Level.NextURL != "") {
		// NextMap = left(Level.NextURL, instr(Level.NextURL,"."));
		// if (NextMap == "") return;  // maybe a ?restart, Serverpackages remain
		NormalLog("Tick() intercepted LevelChange to: "$ Level.NextURL);
		// NextMap = ChooseNextMap(); // Should be already chosen!
		if (NextMap == "")
			NextMap = ChooseNextMap(); // BUG TODO: Should be full URL in case map requires a different gametype.
		NormalLog("Tick() is attempting to force: "$NextMap);
		Level.NextURL = NextMap;
		// TODO CONSIDER: Level.ProcessServerTravel(...);
		bInterceptTravel = False;
	}
}
#endif

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCollectDamage) {
		if (TeamGame(Level.Game)==None || (Victim!=None && Victim.PlayerReplicationInfo!=None && InstigatedBy!=None && InstigatedBy.PlayerReplicationInfo!=None && (Victim.PlayerReplicationInfo.Team != InstigatedBy.PlayerReplicationInfo.Team))) {
			currentMap.TotalDamage += ActualDamage;
			// bMustSave=True;
		}
	}
	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
}

function bool ScanMaps(optional String search) {
	local string FirstMap, NextMap, TestMap, MapName;
	local int availableCount,crashCount,missingCount,unknownCount;
	local int count,i;
	local String prefix;
	// prefix = Botmatch.Parent.Default.MapPrefix;
	// prefix = Botpack.CTFGame.Default.MapPrefix;
	// NormalLog("ScanMaps(): Starting new scan...");
	// NormalLog("Iterate maps running...");
	local int blocked;

	count = 0;
	// Reset bOnDisk info, because we are about to regenerate it:
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "") {
			if (MapStats[i].bOnDisk == False) {
				missingCount++;
			}
			MapStats[i].bOnDisk = False;
			count++;
			if (i>0 && MapStats[i-1].MapName != "") {
				blocked++;
			}
		}
	}
	NormalLog("ScanMaps() Total maps in database: "$count$" with "$ 100*blocked/count $"% congestion.");

	// TODO: we only scan maps which match the current gamemode.  If it stays this way, at least document it!
	prefix = Level.Game.Default.MapPrefix;
	FirstMap = GetMapName(prefix, "", 0);
	NextMap = FirstMap;
	count = 0;
	while (!(FirstMap ~= TestMap)) {
		if( ! ( Left(NextMap,Len(NextMap)-4) ~= (prefix$"-tutorial") ) ) {
			// Add the map.

			// DebugLog("ScanMaps(): "$NextMap);
			count++; // maybe don't count if crashed?
			if (StrEndsWith(NextMap,".unr")) {
				MapName = StrBeforeLast(NextMap,".unr");
			} else {
				MapName = NextMap;
			}

			// Ensure a record exists for the map:
			// MapIndex(MapName);
			// MapStats[MapIndex(MapName)].bOnDisk = True;
			MapRecord(MapName).bOnDisk = True;

			if (MapRecord(MapName).bCrashes) {
				crashCount++;
			} else {
				availableCount++;
				if (MapRecord(MapName).PreferredPlayers==0)
					unknownCount++;
			}

			if (search != "") {
				if (MapName ~= search) {
					return True;
				}
			}

		}
		// Get the map.
		NextMap = GetMapName(prefix, NextMap, 1);
		// Text to see if this is the last.
		TestMap = NextMap;
	}
	// Broadcast because: it should never happen during play, so if it does, we want to know about it!
	BroadcastMessage("MapStats found "$ availableCount $" available "$ prefix $" maps.");
	NormalLog("ScanMaps() Found "$ availableCount $" available "$ prefix $" maps out of "$ count $" known, where "$ crashCount $" crash, "$ missingCount $" are missing, and "$ unknownCount $" have unknown size.");
	SaveConfig();
	return False;
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	#ifdef PLAYERS_CAN_VETO
	local String s;
	#endif
	local bool hideMessage; // Only actually works for the Sender.
	hideMessage = False;
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.

		#ifdef MAP_RATING
		if (Caps(Msg)=="GOOD MAP") { // CONSIDER: nice map, great map
			if (StrContains(currentMap.RatedUpBy,Sender.getHumanName()$" ")) {
				PlayerPawn(Sender).ClientMessage("You have ALREADY rated this map up!");
			} else {
				currentMap.GoodVotes++;
				PlayerPawn(Sender).ClientMessage("You have rated this map +1");
				BroadcastAndLog("Current rating for "$ currentMap.MapName $" is +"$ currentMap.GoodVotes $" up -"$ currentMap.BadVotes $" down.");
				currentMap.RatedUpBy = currentMap.RatedUpBy $ Sender.getHumanName() $ " ";
			}
			SaveConfig();
		}
		if (Caps(Msg)=="BAD MAP") { // CONSIDER: crap map, shit map
			if (StrContains(currentMap.RatedDownBy,Sender.getHumanName()$" ")) {
				PlayerPawn(Sender).ClientMessage("You have ALREADY rated this map down!");
			} else {
				currentMap.BadVotes++;
				PlayerPawn(Sender).ClientMessage("You have rated this map -1");
				BroadcastAndLog("Current rating for "$ currentMap.MapName $" is +"$ currentMap.GoodVotes $" up -"$ currentMap.BadVotes $" down.");
				currentMap.RatedDownBy = currentMap.RatedDownBy $ Sender.getHumanName() $ " ";
			}
			SaveConfig();
		}
		#endif

		#ifdef MAP_TAGS
		if (Left(Msg,8)~="!tagmap ") {
			AddTags(Right(Msg,8));
			SaveConfig();
		}
		#endif

		#ifdef PLAYERS_CAN_VETO
		// if (StrStartsWith(Msg,"!")) {
			// hideMessage = CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		// }
		// if (Level.Game.bGameEnded && bEndGameSwitchMap) {
		if (NextMap != "") {
			if (Msg ~= "NO" || Msg ~= "!NO" || Msg ~= "YES" || Msg ~= "!YES") {
				if (StrContains(VetoersList," "$Sender.getHumanName()$" ")) {
					PlayerPawn(Sender).ClientMessage("You have already voted on "$ NextMap $"!");
					hideMessage = True;
				} else {
					VetoersList = VetoersList $ " " $ Sender.getHumanName() $ " ";
					if (Msg ~= "NO" || Msg ~= "!NO")
						NoCount++;
					if (Msg ~= "YES" || Msg ~= "!YES")
						NoCount--;
					// CONSIDER TODO: saying yes/no should be equivalent to saying "good map"/"bad map" on the target map.
					if (NoCount >= MinimumNosForVeto) {
						NoCount = 0;
						VetoersList = "";
						RejectedMaps = RejectedMaps $ " " $ NextMap;
						NextMap = ChooseNextMap();
						BroadcastAndLog("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
					} else {
						s = "s" ; if ((MinimumNosForVeto-NoCount)==1) s = "";
						BroadcastAndLog( (MinimumNosForVeto-NoCount) $" more vote"$s$" needed to reject "$ NextMap);
					}
					// hideMessage = True; // Hiding it from sender might confuse him/her, if he can see other people's.
				}
			}
		}
		// }
		#endif

	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage /* || !bSwallowSpokenCommands */ );
}

// Catch mutate messages:
function Mutate(String str, PlayerPawn Sender) {
	local PlayerPawn p;
	if (bAllowMutateSwitch) {
		if (str~="suggest") {
			// Current NextMap is discarded
			// In fact, current NextMap is vetoed:
			// if (NextMap != "")
				// RejectedMaps = RejectedMaps $ " " $ NextMap;
			NextMap = ChooseNextMap();
			// Sender.ClientMessage("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
			Sender.ClientMessage("Next: "$ NextMap $" ("$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $") Beaten: "$ConsideredMaps$"");
			// BroadcastMessage("Next map will be "$NextMap);
		}
		if (
			   (str~="nextmap" && Sender.bAdmin)
			|| (str~="nextmap" && CountPlayers()==1)
			|| (str~= ("nextmap "$ ConsoleCommand("get engine.gameinfo AdminPassword") ) )
			|| str ~= "nextmap..."
			|| str ~= "next..." // TODO WARNING BUG: This little backdoor allows any player to force a mapswitch, but I am currently using it for TESTING.
		) {
			// if (Level.Game.bGameEnded) {
			if (FRand()<0.25) {
				DoLevelSwitch();
				return; // Just to avoid printing the "Repeat call" message below.
			}
			// Level.Game.bGameEnded = (FRand()<0.3);
			// if (Level.Game.bGameEnded) {
				// foreach AllActors(class'PlayerPawn',p) {
					// p.PreClientTravel(); // We need this when doing Level.ServerTravel()!  Otherwise clients get "Connection failed" when server switches map.
					// // p.ClientTravel("?reconnect", TRAVEL_Relative, False);
				// }
			// }
			if (NextMap=="")
				NextMap = ChooseNextMap();
			// Sender.ClientMessage("Repeat call to switch map to "$ NextMap $" (state= "$ Level.Game.bGameEnded $")");
			Sender.ClientMessage("Repeat call to switch map to "$ NextMap $"");
		}
		if (str~="scanmaps" && Sender.bAdmin) {
			bDoMapScan=True;
			bMapScanDone=False;
			ScanMaps();
		}
		if (StrStartsWith(Caps(str),"LIST ") || StrStartsWith(Caps(Str),"LISTMAPS")) { // aka SHOWINFO
			if (StrContains(str," ")) {
				ListMapsTo(Sender,StrAfterFirst(str," "));
			} else {
				ListMapsTo(Sender,"");
			}
		}
		#ifdef LIST_RECENTLY_PLAYED
		if (str~="LISTRECENT" || str~="LASTMAPS") {
			BroadcastAndLog("Recently played maps: "$ RecentlyPlayedMaps);
		}
		#endif
		if (str~="help") {
			Sender.ClientMessage("MapStats say commands: yes | no | good map | bad map | !tagmap <tag1,tag2,...>");
			Sender.ClientMessage("MapStats mutate commands: help | suggest | list <part_of_mapname> | listrecent");
			Sender.ClientMessage("MapStats admin mutate commands: nextmap | scanmaps");
		}
	}
	// CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

function ListMapsTo(PlayerPawn p, String str) {
	local int i;
	local bool hit;
	str = Caps(str);
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "" && StrContains(Caps(MapStats[i].MapName),str)) {
			#ifdef MAP_TAGS
			p.ClientMessage("["$i$"] "$MapStats[i].MapName$" playcount="$((MapStats[i].GamesStarted+MapStats[i].GamesEnded)/2)$" prefplayers="$Left(""$MapStats[i].PreferredPlayers,4)$" +"$MapStats[i].GoodVotes$" -"$MapStats[i].BadVotes$" tags="$MapStats[i].Tags);
			#else
			p.ClientMessage("["$i$"] "$MapStats[i].MapName$" playcount="$((MapStats[i].GamesStarted+MapStats[i].GamesEnded)/2)$" prefplayers="$Left(""$MapStats[i].PreferredPlayers,4)$" +"$MapStats[i].GoodVotes$" -"$MapStats[i].BadVotes$"");
			#endif
			hit = true;
		}
	}
	if (hit == false) {
		p.ClientMessage("I could not find any map matching "$Locs(str)$" - use mutate scanmaps to rescan at next mapswitch.");
	}
}

#ifdef MAP_TAGS
function AddTags(String tags) {
	currentMap.Tags = currentMap.Tags $ tags $ ",";
	// done outside atm: SaveConfig();
}
#endif

/*
// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local Actor A;
	local String result;
	local int i,j;
	local String squishedName;
	local String url;
	local String rebuilt_string; // CONSIDER: instead of rebuilding the string, we could just use StrAfter(line," ") one or more times.
	local String command;
	// local PlayerSettings ps;
	local String stateStr;

	if (bOnlyAdmin && !Sender.bAdmin) {
		return False;
	}

	// ps = GetPlayerSettingsFor(Sender);
	#define ps GetPlayerSettingsFor(Sender)

	// NormalLog("ActorEditor.CheckMessage() ("$Sender$"): "$Msg$"");
	argcount = SplitString(line," ",args);

	command = args[0];

	if (command ~= "flash") {
		ps.bFlash = !ps.bFlash;
		stateStr = "off";
		if (ps.bFlash)
			stateStr = "on";
		// if (ps.bFlash)
		FlashMessageToPlayer(Sender,"damage flash = "$stateStr,InfoColor,0,2,true);
		// else Sender.ClearProgressMessages();
		Sender.ClientMessage("Your damage flash is "$stateStr);
		return True;
	}

	if (command ~= "damage") {
		ps.bSeeDamageGiven = !ps.bSeeDamageGiven;
		stateStr = "off";
		if (ps.bSeeDamageGiven)
			stateStr = "on";
		Sender.ClientMessage("Your showdamage is "$stateStr);
		// if (ps.bFlash) 
		FlashMessageToPlayer(Sender,"show damage = "$stateStr,SentPainColor,1,2,True);
		return True;
	}

	if (command ~= "pain" || command ~="mydamage") {
		ps.bSeeDamageReceived = !ps.bSeeDamageReceived;
		stateStr = "off";
		if (ps.bSeeDamageReceived)
			stateStr = "on";
		Sender.ClientMessage("Your show pain is "$stateStr);
		FlashMessageToPlayer(Sender,"show pain = "$stateStr,ReceivedPainColor,7,2,True);
		return True;
	}

	if (command ~= "alldamage") {
		ps.bSeeAllDamage = !ps.bSeeAllDamage;
		stateStr = "off";
		if (ps.bSeeAllDamage)
			stateStr = "on";
		Sender.ClientMessage("show alldamage = "$stateStr);
		FlashMessageToPlayer(Sender,"Your show all damage is "$stateStr,InfoColor,3,2,True);
		return True;
	}

	if (command ~= "HELP") {
		Sender.ClientMessage("TrackDamage commands: flash damage pain alldamage");
		return True;
	}

	return False;

}

function FlashMessageToPlayer(PlayerPawn p, string Msg, Color msgColor, optional int linenum, optional int duration, optional bool bAdditional, optional bool bBeep) {
	if (linenum == 0)
		linenum = 4;
	if (duration == 0)
		duration = 2;
	if (!bAdditional)
		p.ClearProgressMessages();
	p.SetProgressTime(duration);
	p.SetProgressColor(msgColor,linenum);
	p.SetProgressMessage(Msg,linenum);
	if (bBeep)
		p.PlaySound(sound'Beep', SLOT_Interface, 2.5, False, 32, 32);
}
*/

// #include "../../JLib/findactor.uc.jpp"

#include "../../JLib/jlib.uc.jpp"

