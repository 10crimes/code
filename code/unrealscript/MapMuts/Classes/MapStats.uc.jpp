// vim: noexpandtab filetype=uc

/*

// MapStats - Collect some statistics on your maps.  Optionally, automatically
// cycle to a suitable map based on size relative to number of players on
// server, and time since it was last played.
// By nogginBasher, improvements by Rork.

// TODO: Detect end of game (e.g. by recognising a variety of mapvote messages,
// or by checking bGameEnd like other Mutators do) and if there are <10 votes
// been made for a map, spam a message asking people to rate it.
// I sometimes forget after playing a new map, to tell the system whether it
// was good or not, so I need to be prompted!

// TODO: mutate findmap | mutate switchmap <n>

// One time for some reason (level switching mid-merge weirdness) it was very slow to change map, so before it did, it tried to switch to various maps, and found itself marking them all as bCrashes and trying more.       Eventually it ran out of maps, and starting putting "".
// One solution: bCrashes only makes the score much worse, it doesn't veto the map altogether.  (Could cause rare crashes - bDetectCrashingMaps)
// Another solution: Ignore bCrashes, clear random bCrashes, do map rescan, when you detect desperation!

// TODO: On kx it was selecting a new map but only very occasionally would the server switch to it.
//       This produced a lot of falsely marked crashed maps, and we ended up running out of maps, and trying to set NextURL="".

// DONE: determine required level switch gametype from prefix or from map itself, thus allowing switching to other gametypes

// TODO: Record nice stats for the admin, such as number of spawnpoints, whether the map has weapons or not, ...

// TODO: Allow automatically add muts to certain maps.  (e.g. instagib for the no weapon ctf maps)

// TODO: if the map does not exist, the log shows "Failed to load"... but MapStats does not retry with another map.  How can we fix this?  Maybe Tick() can catch it...

// TODO: Should we avoid updating "play" stats when no players are around? e.g. TotalDamage,FragCount,HoursPlayed.

// TODO: bDetectCrashingMaps - the crashed map detection might sometimes automatically mark a map as crashed innaccurately (e.g. if this mod switches the map, but the server is restarted before it actually loads).  There is auto recovery with bRetryCrashedMaps, but that might be undesirable if causing a full server crash is hard to recover from.  Therefore until one of these features is perfect, the admin may with to disable them both.

// TODO NASTY BUG: it tried to switch to a previously crashed map which was no longer on disk - we got Failed to load 'CTF-Lucius-EBTC125': Can't find file 'CTF-Lucius-EBTC125' but the map didn't switch and there was no retry by the Timer.  When I tried to join the server, my UT went blank, and the log repeated: RPC bunch overflowed
//      maybe tick can catch nasty situations like this and switch to a different map
// I thought this was working a little while ago, but I can't get it to work now.

// TODO: Instead of players vetoing maps with "no" we could give them a list of 3,4,5 need-to-be-played maps and let them pick one.

// BUG: AnthCheck1.38 causes a segfault on Linux servers when MapStats tries to do an empty server level switch.  I think MapVoteLA does not have this problem when switching maps (but it does have the port number shifting problem).

// TODO: Got empty server mapswitch working again, but with Anth1.8 I get the "Unhooking DLO" crash if crashed map is detected and we re-switch.
//       Also sometimes getting just plain segfault *after* 2nd map comes up, if change went fine, after Ip2Country starts.
// Update: Right now I only seem to be getting the first problem.
//       The DLO actually succeeds on the first mapswitch attempt, so maybe we should prevent it from running the second time around.

// DONE: Should not act in the first of two Assault rounds.  Fortunately the timeout was high enough in my case so the map switched anyway.

// All XOL's info is stored in Fate.BestFitMapList

// DONE: mutate search <part_of_mapname>   so we can see what maps are installed even if they aren't in mapvote
// DONE: add "good map" "bad map" detection (copy it from ATB!)

// Is it bad HCI to call it "good map"/"bad map" when the actual effect is to "see the map more/less often"?

// CONSIDER: on the one hand, people voting a map means it's a good map
//           on the other hand, we want to offer maps people don't play much, until it is rated

// As an alternative fix for MapVoteLA's port switch problem, Rednas suggests: try setting bWorldLog to false.

*/

#ifndef HEAD

// #define TESTING

// Do not change this once you already have data.  It will change the hashing algorithm and all your data will be missed/lost/stuck.
#define MaxData 3000

class MapStats expands Mutator config(MapStats);

// MapScale is an estimate of the universal constant for ideal player count estimation wrt actor distance.  (Higher values bring actors closer together, making it think maps are smaller, so it will make us play larger maps?)
#define MapScale 400
#define NumberOfSpawnPointsScaled (NumberOfSpawnPoints*0.6)
#define FallbackValue (NumberOfSpawnPointsScaled*MapScale)

// I thought this was needed for immediate switch to work 100%, but I'm not 100% sure.
// With or without this, *sometimes* it didn't change to NextMap at all, but to the next map in UT's cycle I think (Gauntlet/Command/...).  OK I think I fixed that.
#define CATCH_LEVEL_SWITCH
// CATCH_LEVEL_SWITCH works!  But it changes the map we had chosen.  Well we did set NextMap="" (for other reasons).
// And now I can't get it working.  :P
#define LIST_RECENTLY_PLAYED
#define MAP_RATING
#define MAP_TAGS
// PLAYERS_CAN_VETO affects bEndGameSwitchMap
#define PLAYERS_CAN_VETO
//// I'm afraid it can't be done.  We can't compile against MapVoteLA13 (at least not under Linux/wine/ucc), and we can't access elements of MapListTemp's array using ConsoleCommands.  TEST: Can we read MapListTemp using config() ?
// #define ADJUST_MAPVOTELA_LIST
#define PLAYERS_CAN_SKIP_MAP

//// The XOL build has slightly different equations, and not all the extra (unneccessary) features.
// #define XOL_BUILD
#ifdef XOL_BUILD
	#undef MAP_TAGS
#endif

var config bool bBroadcastStuff;
var config bool bShowLevelEnterText;

var config bool bSetMaxPlayers;
var config bool bAutoExpandMaxPlayers;
var config int ServerMinPlayers;
var config int ServerMaxPlayers;

var config bool bLogging;
var config bool bDebugLogging;
var config bool bLogStats;
var config bool bCollectDamage;
var config bool bDoMapScan;

var config bool bEstimatePreferredPlayers;     // Actually it always makes an estimate if there is none.  Really means bAllowEmptyServerSwitchToUnsizedMapsToLearnPP
var config bool bRegeneratePreferredPlayers;   // Whether current non-0 values should be overwritten.  Enable this to use the latest MapStats algorithm, provided you don't mind losing any values you have set by hand.

#ifdef LIST_RECENTLY_PLAYED
var config bool bListRecentlyPlayed;
var config String RecentlyPlayedMaps;
#endif
// var config bool bDisplayInfoWhenVoting;

// Auto map-switching:
var config bool bEndGameSwitchMap;
var config int EndGameSwitchSeconds;
var config bool bAllowMutateSwitch;
var config bool bEmptyServerSwitchMap;
var config int EmptyServerSwitchSeconds;
var config bool bStickWithCurrentMode; // turn it on to keep server playable (no CTF on DM maps etc.!) - turn it off to scan all map-sizes
var config bool bDetectCrashingMaps;   // This is really bRecordCrashingMaps.  I think it only discovers crashes if MapStats is doing the map switching.
var config bool bRetryCrashedMaps;
var config String KnownGameTypes; // used to associate map prefixes with their gametypes
var config float MaxPlayerSizeDifference;   // Not actually an enforced maximum, but a recommendation.
// This is needed to pick unsized maps, otherwise we will never get around to estimating their player size!
// Deprecated: var config bool bEmptyServerRandomMap;
#define bEmptyServerRandomMap bEstimatePreferredPlayers

struct MapInfo {
	var String MapName;
	var float PreferredPlayers;
	var float DateLastPlayed;
	var bool bOnDisk;
	var bool bCrashes;
	var bool bDisabled;
	var int GamesStarted;
	var int GamesEnded;
	var float HoursPlayed;
	var float AveragePlayerFlow;
	var float AveragePlayerCount;
	var int FragCount;
	var float TotalDamage;
	// var int NumberOfSpawnPoints;
	// var int NumberOfWeaponPickups;
	// var int NumberOfPathNodes;
	// var float ActorDistance;
	#ifdef MAP_RATING
	var int GoodVotes;
	var int BadVotes;
	var String RatedUpBy;
	var String RatedDownBy;
	#endif
	#ifdef MAP_TAGS
	var String Tags; // Comma separated list.  If user inputs commas then they are inputting multiple tags.
	#endif
};

var config MapInfo MapStats[MaxData];

var String mapName; // Current map's name, generated at start.
var int mapI; // Current map's index, generated at start.
#define currentMap MapStats[mapI]
var float NumberOfSpawnPoints; // Globalised for FallbackValue

var float StartTime;
var int PlayerCountAtStart;
var bool bMapScanDone;
var bool bDoneGameEnd;
var String ConsideredMaps;
var String TryingMap;
var String NextMap;
var String RejectedMaps;
#ifdef PLAYERS_CAN_VETO
var config int MinimumNosForVeto;
var int NoCount;
var String VetoersList;
#endif
#ifdef MAP_RATING
#endif

#ifdef PLAYERS_CAN_SKIP_MAP
var config int PercentageForMapSkip;
var float WhenVotedForSkip[64];
#endif

defaultproperties {
bBroadcastStuff=True
bLogging=True
bDebugLogging=False
bDetectCrashingMaps=True
bRetryCrashedMaps=False
bLogStats=False
bCollectDamage=False
bEstimatePreferredPlayers=True
bRegeneratePreferredPlayers=False
bEndGameSwitchMap=False
EndGameSwitchSeconds=12
bEmptyServerSwitchMap=False
EmptyServerSwitchSeconds=1800
bAllowMutateSwitch=False
bSetMaxPlayers=False
bAutoExpandMaxPlayers=False
ServerMinPlayers=6
ServerMaxPlayers=16
bDoMapScan=True
bShowLevelEnterText=True
bStickWithCurrentMode=True
#ifdef LIST_RECENTLY_PLAYED
bListRecentlyPlayed=False
#endif
KnownGameTypes="CTF:botpack.CTFGame|DM:botpack.DeathMatchPlus:botpack.TeamGamePlus:botpack.LastManStanding|AS:botpack.Assault|BT:bunnytrack2.BunnyTrackGame|DOM:botpack.Domination|MH:monsterhunt.MonsterHunt"
MaxPlayerSizeDifference=5.0
#ifdef PLAYERS_CAN_VETO
MinimumNosForVeto=2
#endif
#ifdef PLAYERS_CAN_SKIP_MAP
PercentageForMapSkip=51
#endif
}

#define MapRecord(X) MapStats[MapIndex(X)]

#define CountPlayers() ( CountActors(class'PlayerPawn') - CountActors(class'Spectator') )

// #define DebugLog(Y); 
#define DebugLog(Y); if (bDebugLogging) { Log("-MapStats- " $ Y); }
// #define NormalLog(Y); 
#define NormalLog(Y); if (bLogging) { Super.Log("[MapStats] "$Int(Level.TimeSeconds)$" " $ Y); }
#define WarnLog(Y); Super.Log("Warning! [MapStats] " $ Y);
// Fails: // function NormalLog(String Y) { if (bLogging) { Super.Log(Y); } }
// Fails: // #define Log(Y); NormalLog(Y);

#define BroadcastAndLog(Y); BroadcastMessage(Y); if (bLogging) { Log("[MapStats] Broadcasted: " $ Y); }

#endif

#define NiceFloat FloatToString
function String FloatToString(float f) {
	local String s;
	local int i;
	s = String(f);
	i = InStr(s,".");
	if (i>=3) return StrBeforeLast(s,".");
	s = StrBeforeFirst(s,".") $ "." $ Left( StrAfterFirst(s,"."), 3-i ); // may not be accurate enough for 0.000001
	return s;
}
// #define NiceAge(X) Int(((X)+0.5)*24)$"h"
function String NiceAge(float days) {
	local float hours;
	hours = days * 24.0;
	if (hours<1.5) {
		return String(Int(hours*60.0)) $" minutes";
	}
	if (hours>48.0) {
		return String(Int(hours/24.0+0.5)) $" days";
	}
	return String(Int(hours+0.5)) $" hours";
}

function PostBeginPlay() {

	//// Pushing out new default configs during a temporary release:
	// EmptyServerSwitchSeconds=5*60; // XOL is still learning about the maps
	// EmptyServerSwitchSeconds=60*60;
	// bDebugLogging=True;
	// if (FRand()<0.01)
		// bDoMapScan=True;

	mapName = StrBeforeFirst(""$Self,".");
	if (StrEndsWith(Caps(mapName),".UNR")) {
		MapName = Left(mapName,Len(mapName)-4);
	}
	mapI = MapIndex(mapName);
	NumberOfSpawnPoints = CountActors(class'PlayerStart');

	if (bCollectDamage)
		Level.Game.RegisterDamageMutator(Self);

	// TODO:
	// If we were not added as a mutator, but run in some other way (e.g. as a ServerActor), then we need to register as a mutator:
   // Level.Game.BaseMutator.AddMutator(Self);

	// Register to receive spoken messages in MutatorTeamMessage() below:
	Level.Game.RegisterMessageMutator(Self);

	DoStart();

	SetTimer(5.0,True);

}

function DoStart() {
	// This is actually done when the map is loaded.
	// The game starts when a player joins - see ModifyPlayer().
	local String idealPlayerCount,gotNum,restStr;
	local int count;
	local float avg,num;
	local bool bMustSave;
	// local float NumberOfSpawnPoints;
	local float ActorDistance;

	// ScanMaps();

	NormalLog(mapName $" Last played "$ NiceAge(DaysSince1999() - currentMap.DateLastPlayed) $" ago.");
	if (bLogStats) {
		NormalLog(mapName $" NumberOfSpawnPoints = "$ CountActors(class'PlayerStart'));
		NormalLog(mapName $" NumberOfWeaponPickups = "$ CountActors(class'Weapon'));
		NormalLog(mapName $" NumberOfPathNodes = "$ CountActors(class'PathNode'));
	}

	// Should we regenerate the map's PreferredPlayers estimate with the latest algorithm?
	// DONE: set this False for final release.  If admin really wants them regenerated, he can set them to 0.
	if (currentMap.PreferredPlayers == 0 || bRegeneratePreferredPlayers) {
		// We are allowed to modify the PreferredPlayers count for this map, and should now do our best

		// DebugLog("Collecting ActorDistance for "$mapName$"...");
		ActorDistance = ( MaxActorDistanceType(class'FlagBase') + MaxActorDistanceType(class'Weapon') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode') ) / 4.0 / Float(MapScale);
		if (bLogStats) {
			NormalLog(mapName $" ActorDistance = "$ ActorDistance);
		}
		if (ActorDistance < 2)
			ActorDistance = 2;
		if (ActorDistance > 32)
			ActorDistance = 32;

		// Get map author's suggested IdealPlayerCount:
		idealPlayerCount = Level.IdealPlayerCount;
		// DebugLog("Getting map author's IdealPlayerCount from \""$idealPlayerCount$"\"...");
		restStr = idealPlayerCount;
		avg = 0.0;
		count = 0;
		do {
			gotNum = StrFilterNum(restStr,true,restStr);
			if (gotNum!="") {
				num = Float(gotNum);
				// DebugLog("MapStats: Got "$num$" from \""$gotNum$"\" with rest="$restStr);
				if (num>0) {
					// avg = (count*avg + num) / (count+1);
					avg += num;
					count++;
				}
				if (StrStartsWith(restStr,"-"))
					restStr = Mid(restStr,1);
			}
		} until (gotNum == "");
		if (count>0) avg = avg / count;

		NormalLog(mapName $" Previous PreferredPlayers = "$ currentMap.PreferredPlayers);

		// Did we get any numbers from IdealPlayerCount?
		if ( count>0 ) {
			// Build estimated PreferredPlayers from avg, NumberOfSpawnPoints and ActorDistance:
			// DebugLog(mapName$" Got IdealPlayerCount "$avg$" from \""$idealPlayerCount$"\".");
			if (avg>20) avg=20;
			currentMap.PreferredPlayers = avg;
			// Mix it with NumberOfSpawnPoints and ActorDistance:
			currentMap.PreferredPlayers = 0.4*avg + 0.3*NumberOfSpawnPointsScaled + 0.3*ActorDistance;
			NormalLog(mapName$" Estimating from Ideal=\""$ idealPlayerCount $"\"("$ NiceFloat(avg) $") PlayerStarts="$ NiceFloat(NumberOfSpawnPointsScaled) $" and ActorDistance="$ NiceFloat(ActorDistance) $"");
		} else {
			// Mix just NumberOfSpawnPoints and ActorDistance:
			currentMap.PreferredPlayers = 0.5*NumberOfSpawnPointsScaled + 0.5*ActorDistance;
			NormalLog(mapName$" Estimating from PlayerStarts="$ NiceFloat(NumberOfSpawnPointsScaled) $" and ActorDistance="$ NiceFloat(ActorDistance) $"");
		}
		bMustSave = True;

	}

	NormalLog(mapName$" PreferredPlayers = "$ NiceFloat(currentMap.PreferredPlayers));

	// If it was marked as crashed or not on-disk, We MUST mark this map as working!
	if (currentMap.bCrashes || !currentMap.bOnDisk) bMustSave=True;
	// Update some stats:
	currentMap.GamesStarted++;
	// In case no players join, we only pull the map's date forward by 30%, so
	// other maps with similar age/score will now have their chance.
	// Will be updated later if any players do join.
	currentMap.DateLastPlayed = (currentMap.DateLastPlayed*0.7 + DaysSince1999()*0.3);
	NormalLog("Brought age to " $ NiceAge(DaysSince1999() - currentMap.DateLastPlayed) $ " ago.");
	// #endif
	// if (currentMap.bCrashes) { NormalLog("FIXED! Map "$ mapName $" was previously crashing, but now works!"); } // Can't do, this is usually set to true by DoLevelSwitch :P
	currentMap.bCrashes = False; // Was most likely set just before the server switched to this map.  We reset it here, to prove this is a non-crashing map.
	currentMap.bOnDisk = True; // Also proved here (but should be already known from ScanMaps()).

	// #define bSaveEarly False
	// if (bSaveEarly && (bCollectMapStats || bEstimatePreferredPlayers)) bMustSave=True;
	if ( bMustSave ) {
		DebugLog("DoStart(): Calling SaveConfig()");
		SaveConfig();
		bMustSave = False;
	}

	if (bSetMaxPlayers && currentMap.PreferredPlayers>0) {
		Level.Game.MaxPlayers = 2*Int( (currentMap.PreferredPlayers+1.0)/2.0 );
		if (Level.Game.MaxPlayers < ServerMinPlayers)
			Level.Game.MaxPlayers = ServerMinPlayers;
		if (Level.Game.MaxPlayers > ServerMaxPlayers)
			Level.Game.MaxPlayers = ServerMaxPlayers;
		NormalLog("bSetMaxPlayers: MaxPlayers set to "$ Level.Game.MaxPlayers);
	}

}

function ModifyPlayer(Pawn Other) {
	// if (PlayerPawn(Other) != None) {
	if (Other!=None && Other.PlayerReplicationInfo != None) {
		// DebugLog("ModifyPlayer("$ Other.getHumanName() $") was called.");
		// TODO CONSIDER: Is this method innacurate, if ATB moves the player, they might have 1 Death before they even spawn!
		if (/*PlayerPawn(Other)!=None && Spectator(Other)==None &&*/ Other.PlayerReplicationInfo.Deaths == 0) {
			// Latest player/bot join/first-spawn!
			DebugLog("ModifyPlayer("$ Other$"): "$ Other.getHumanName() $" joined at "$ Level.TimeSeconds);

			if (StartTime == 0 && PlayerPawn(Other)!=None) {
				// First player to spawn this game!

				NormalLog("Detected start of game (first player spawn) at "$ Level.TimeSeconds);
				StartTime = Level.TimeSeconds;
				// We don't want to set PlayerCountAtStart at the moment the first player spawns, in case more are downloading.
				// We wait until 30 seconds into the map (actually the next frag).  See below.

				// Update some stats for this map:
				currentMap.DateLastPlayed = DaysSince1999();
				#ifdef LIST_RECENTLY_PLAYED
				RecentlyPlayedMaps = StrReplace(RecentlyPlayedMaps," "$mapName$" "," ") $" "$ mapName;
				if (Len(RecentlyPlayedMaps)>60) {
					RecentlyPlayedMaps = " "$ StrAfterFirst(StrAfterFirst(RecentlyPlayedMaps," ")," ");
				}
				#endif
				// bMustSave = True;
				// SaveConfig(); // In case mapswitch is forced by admin or mapvote or another mod.
				//// Disabled because it can cause red-disconnect-icon at game start.  :f
				//// Will be saved in DoEnd() if game is played through.

			}
			// currentMap.DateLastPlayed = DaysSince1999(); // hope that a SaveConfig happens later (should happen in DoEnd())

			if (PlayerPawn(Other)!=None && Other.PlayerReplicationInfo.Deaths==0 && bShowLevelEnterText && Level.LevelEnterText!="") {
				PlayerPawn(Other).ClientMessage(Level.Title $ " : " $ Level.LevelEnterText);
			}

		} else {

			// A frag / someone/thing died
			currentMap.FragCount++;
			if (StartTime == 0) { // should no longer be possible
				// First ever frag!
				// StartTime = Level.TimeSeconds;
				// DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting StartTime="$Level.TimeSeconds);
			}
			if (PlayerCountAtStart == 0 && Level.TimeSeconds>=30) { // give them 30 seconds to download the map / join the server
				PlayerCountAtStart = CountPlayers();
				DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting PlayerCountAtStart="$ CountPlayers() $" at "$ Level.TimeSeconds);
			}

		}
	}
	Super.ModifyPlayer(Other);
}

event Timer() {

	/*
	// This works but I doubt Tick() will fail.
	#ifdef CATCH_LEVEL_SWITCH
	if (TryingMap!="") {
		WarnLog("Timer() caught TryingMap!");
		Tick(0.05);
		return;
	}
	#endif
	*/

	#ifdef ADJUST_MAPVOTELA_LIST
	// Just for TESTING!
	AdjustMapVoteLAList();
	#endif

	// Mid-game checks:
	if (bEmptyServerSwitchMap && CountPlayers()==0 && Level.TimeSeconds>EmptyServerSwitchSeconds) {
		// We might be called once or twice after DoLevelSwitch, before the server actually switches.
		// If that is the case, then NextURL will have been set, so we do nothing.
		// Except if it happens a lot, then we assume something is stalled, and try DoLevelSwitch again.
		if (Level.NextURL != "" && FRand()<0.9) {
			DebugLog("Timer(): bEmptyServerSwitchMap=True but NextURL is already set.  Waiting...");
		} else {
			NormalLog("Timer(): bEmptyServerSwitchMap=True - auto switching at "$Level.TimeSeconds$"");
			// Level.Game.bGameEnded = True;
			// bDoneGameEnd = True; // This prevents DoEnd() from being called, which is good since it's an idle server switch, not a real end-game.
			// redundant: bCanChooseUnsizedMaps = True;
			DoLevelSwitch();
			// There is no point in progressing
			// But we leave the timer on, so we can try again later if case this doesn't work for some reason.
			return;
		}
	}

	#define bIgnoreMapSizeWhenChangingServerMax False
	if (bAutoExpandMaxPlayers) {
		// Need to expand?
		if (CountPlayers()+1 > Level.Game.MaxPlayers && Level.Game.MaxPlayers+2 <= ServerMaxPlayers) {
			if (bIgnoreMapSizeWhenChangingServerMax || Level.Game.MaxPlayers < currentMap.PreferredPlayers*2) {
				Level.Game.MaxPlayers += 2;
				NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers increased to "$ Level.Game.MaxPlayers);
			}
		}
		// Need to shrink?
		if (CountPlayers() < ServerMinPlayers && Level.Game.MaxPlayers-2 >= ServerMinPlayers && FRand()<0.01) {
			if (bIgnoreMapSizeWhenChangingServerMax || Level.Game.MaxPlayers > currentMap.PreferredPlayers) {
				Level.Game.MaxPlayers -= 2;
				NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers reduced to "$ Level.Game.MaxPlayers);
			}
		}
		// Level.Game.MaxPlayers = 2*Int( (CountActors(class'PlayerPawn')+1.0)/2.0 );
	}

	// We do not do the below checks for bEndGameSwitchMap if this is the first of two assault rounds.
	if (Assault(Level.Game)!=None && Assault(Level.Game).Part ==1) {
		return;
	}

	// Check if game has just ended:
	if (Level.Game.bGameEnded && !bDoneGameEnd) {
		DoEnd();
		bDoneGameEnd = True;
		if (bEndGameSwitchMap) {
			NextMap = ChooseNextMap();
			if (bBroadcastStuff) {
				// BroadcastAndLog("Map will change to "$ NextMap $" in "$EndGameSwitchSeconds$" seconds.");
				// #ifdef PLAYERS_CAN_VETO
				// BroadcastAndLog("Next map will be "$ NextMap $"... say no to reject.");
				// #else
				// BroadcastAndLog("Next map will be "$ NextMap $".");
				// #endif
				// BroadcastAndLog("(Other maps: "$ ConsideredMaps $")");
				// BroadcastAndLog("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1999() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
				BroadcastAndLog("Considered maps: "$ConsideredMaps);
				#ifdef PLAYERS_CAN_VETO
				BroadcastAndLog("Next map will be: "$ NextMap $", unless you type !NO to veto it.");
				#else
				BroadcastAndLog("Next map will be: "$ NextMap $" (last played "$ NiceAge(DaysSince1999() - MapRecord(NextMap).DateLastPlayed) $" ago)");
				#endif
			}
			// We do the switch in the if clause below, when Timer is next called.
			SetTimer(EndGameSwitchSeconds,False);
		} else {
			NormalLog("bEndGameSwitchMap=False, but chosen map would have been: "$ChooseNextMap());
		}
		return;
	}

	// Check if game is well over:
	if (Level.Game.bGameEnded && bDoneGameEnd && bEndGameSwitchMap) {
		DoLevelSwitch();
	}

}

function DoEnd() {
	local float playerChangeThisGame,averagePlayerCountThisGame;
	local float totalHours,deltaHours,newTotalHours;

	totalHours = currentMap.HoursPlayed;
	deltaHours = (Level.TimeSeconds - StartTime) / 60.0 / 60.0;

	// if ( (PlayerCountAtStart == 0 && CountPlayers() == 0)
		// || (deltaHours>0.5 && (PlayerCountAtStart == 0 || CountPlayers() == 0))
	// ) {
		// DebugLog("Not updating any stats for this game on "$mapName$", since it took "$(deltaHours*60)$" minutes, and either started or ended with only bots.");
		// // return;
		// // Maybe we should do currentMap.GamesStarted--;  Chances are that stat has already been saved.
		// currentMap.GamesStarted--;
		// // Problem: map's TotalDamage and Deaths have increased, and we can't recover the old values!
	// }

	currentMap.GamesEnded++;
	// currentMap.DateLastPlayed = DaysSince1999();

	newTotalHours = currentMap.HoursPlayed + deltaHours;

	playerChangeThisGame = CountPlayers() - PlayerCountAtStart;
	currentMap.AveragePlayerFlow = (totalHours*currentMap.AveragePlayerFlow + deltaHours*playerChangeThisGame) / newTotalHours;

	averagePlayerCountThisGame = (CountPlayers() + PlayerCountAtStart) / 2.0; // approx ^^
	currentMap.AveragePlayerCount = (totalHours*currentMap.AveragePlayerCount + deltaHours*averagePlayerCountThisGame) / newTotalHours;

	currentMap.HoursPlayed = newTotalHours;

	if (bLogStats) {
		NormalLog(mapName $" Updated for "$ deltaHours $" hours of play.");
		NormalLog(mapName $" GamesStarted = "$ currentMap.GamesStarted);
		NormalLog(mapName $" GamesEnded = "$ currentMap.GamesEnded);
		NormalLog(mapName $" TotalHours = "$ currentMap.HoursPlayed);
		if (bCollectDamage)
		NormalLog(mapName $" FragCount = "$ currentMap.FragCount);
		NormalLog(mapName $" TotalDamage = "$ currentMap.TotalDamage);
		NormalLog(mapName $" Damage/sec = "$ (currentMap.TotalDamage / currentMap.HoursPlayed / 60.0 / 60.0));
		NormalLog(mapName $" AveragePlayerCount = "$ currentMap.AveragePlayerCount);
		NormalLog(mapName $" AveragePlayerFlow = "$ currentMap.AveragePlayerFlow);
	}

	DebugLog("DoEnd() calling SaveConfig()");
	SaveConfig();

	#ifdef ADJUST_MAPVOTELA_LIST
		AdjustMapVoteLAList();
	#endif

}

#ifdef ADJUST_MAPVOTELA_LIST
function AdjustMapVoteLAList() {
	local Actor a,mlt;
	local float currentNumPlayers,diff;
	local String str,map;
	local int i,removed;
	currentNumPlayers = CountPlayers() - 0.5 + 1.0*FRand();
	foreach AllActors(class'Actor',a) {
		if (StrContains(Caps(String(a.class)),"MAPLISTTEMP")) {
			mlt = a;
			break;
		}
	}
	if (mlt == None) {
		NormalLog("No MapListTemp found!  Trying to spawn one...");
		mlt = Spawn( Class<actor>( DynamicLoadObject("MapVoteLA13.MapListTemp",class'Class') ) );
	}
	if (mlt == None) {
		NormalLog("Could not get a MapListTemp!  Cannot adjust mapvote's list!");
		return;
	}
	// NormalLog("Got MapListTemp "$mlt$" with M[4]="$ mlt.GetPropertyText("M(4)"));
	NormalLog("Got "$mlt.class$" with M[4]="$ mlt.ConsoleCommand("get "$mlt.class$" M(4)"));
	/*
	for (i=0;i<1024;i++) {
		// str = mlt.M[i];
		str = mlt.GetPropertyText("M("$i$")");
		map = StrBeforeFirst(str,":");
		diff = Abs(MapRecord(map).PreferredPlayers - currentNumPlayers);
		if (diff>=4) {
			mlt.SetPropertyText("M("$i$")","");
			removed++;
		}
	}
	*/
	NormalLog("AdjustMapVoteLAList() Removed "$removed$" maps.");
}
#endif

function DoLevelSwitch() {
	local float num;
	local PlayerPawn p;
	local String gametype,url;

	if (NextMap == "") {
		NextMap = ChooseNextMap();
	}

	if (NextMap == "") {
		WarnLog("Could not choose a map to switch to.");
		// I have seen the server stuck in this state, trying to switch to to another map but failing every time, eventually filling up ConsideredMaps.  I think the problem was, all the maps in the DB were missing on disk.
		// bDoMapScan = True;
		// bMapScanDone = False;
		// // SaveConfig();
		ScanMaps();
		// TODO: Clear ConsideredMaps.
		// Or maybe give up trying to switch map.  Or assert(false) after a long amount of time.
		return;
	}

	if (MapRecord(NextMap).bCrashes) {
		BroadcastAndLog("TEST! Retrying crashed map "$ NextMap);
	}

	// MapRecord(NextMap).DateLastPlayed = DaysSince1999(); // If we are auto-switching maps, we will keep cycling through the same set, if we don't update the date somehow.  (Might be nicer to set date = 1 day ago, unless a player joins and makes it more recent.  But that's still not ideal.  What is?)  OK moved to DoStart(), where we move the time half-way.
	if (bDetectCrashingMaps) {
		// We mark the map as crashed - it will be unmarked if it loads successfully.
		MapRecord(NextMap).bCrashes = True;
		// TODO: if Tick() interception is working well, DON'T mark it here, then we can trust bCrashes to be more accurate.  :)
	}
	DebugLog("DoLevelSwitch() calling SaveConfig()");

	// CONSIDER TODO: Shouldn't we do DoEnd() here?  Well it should be already done, provided we only get here by activation after the end of a game.
	SaveConfig();

	if (bBroadcastStuff) {
		// BroadcastAndLog("Considered maps: "$ ConsideredMaps);
		// BroadcastAndLog("Switching to "$ NextMap $" now.");

		num = (DaysSince1999() - MapRecord(NextMap).DateLastPlayed);
		if (num<2.0) {
			// NormalLog(mapName$" was last played "$ Int(24*num+0.5) $" hours ago.");
			BroadcastAndLog("Switching to "$ NextMap $", last played "$ Int(24.0*num+0.5) $" hours ago.");
		} else {
			// NormalLog(mapName$" was last played "$ Int(num+0.5) $" days ago.");
			BroadcastAndLog("Switching to "$ NextMap $", last played "$ Int(num+0.5) $" days ago.");
		}
	}

	// if (!StrEndsWith(Caps(NextMap),".UNR"))
		// NextMap = NextMap $ ".unr";
	// UTServerAdmin(GetAny(class'UTServerAdmin')).ConsoleCommand("admin servertravel "$ NextMap );
	// Log("MapStats.DoLevelSwitch() Switching to map: "$ NextMap);

	// New method, call anyAdminPlayer.ConsoleCommand().  This solves the problems with Level.ServerTravel() "kicking" players out and Level.Game.ProcessServerTravel() changing to the wrong map.
	foreach AllActors(class'PlayerPawn',p) {
		// break; // Get the last one - The first one is useless!
		P.PreClientTravel(); // Maybe doing this makes it ok to use Level.ServerTravel later :o
		// Is this what crashed with AnthChecker1.8?
	}
	url = NextMap;
	gametype = GetGameTypeFromPrefix(NextMap);
	if (bStickWithCurrentMode) {
		gametype = string(Level.Game.Class);
	}
	if (gametype == "") {
		WarnLog("DoLevelSwitch() Warning! Unrecognised gametype "$ StrBeforeFirst(NextMap,"-") $" - please update KnownGameTypes.");
		// TODO CONSIDER: Would it be better to do "game=" here, rather than leaving the server on the current mode - it may use the gametype in the map's LevelProperties.
	} else {
		url = url $"?game="$ gametype;
	}
	// TODO: We didn't handle mutators yet ... leaving them empty just keeps them the same as last map.
	//       This is undesirable on kx if, say, we change from eLMS mode to CTF!
	// url = url $"?mutator=...";

	// MINOR BUG: Sometimes the switch does not happen the first time.  5 seconds later the timer is called and tries again.
	// NOTE: We're using Level.ServerTravel(url,false) this will crash if we're using AnthChecker_v138 and bEnableNetFix=true
	Level.ServerTravel(url,false);
	/*
	// NOTE: redundant code to switch maps: they have issues worse then the anthchecker crash
	// TODO: We should also try Level.ConsoleCommand()!
	if (p != None) {
		p.bAdmin = True;
		NormalLog("DoLevelSwitch() Calling "$p.getHumanName()$".ConsoleCommand(\"admin servertravel "$url$"\")");
		p.ConsoleCommand("admin servertravel "$url);
		p.bAdmin = False;
		// TODO: I think client was disconnecting although the switch went ok.
	} else {
		//// Fallback methods...
		//// Not the desired method with players present, well at least one of the below caused client disconnect. =/
		NormalLog("DoLevelSwitch() No PlayerPawn available.");
		if (TRUE || TryingMap == "") {
			//// Works now, best so far:
			NormalLog("DoLevelSwitch() Doing: Level.NextURL = "$url);
			Level.NextURL = url;
			// It causes clients to disconnect, but that's ok, we don't have any!
			// Level.ServerTravel(url,false); // This works for the server.  I think it might cause trouble for joined clients though.
		} else {
			//// This was crashing with AnthChecker1.38!
			// NormalLog("DoLevelSwitch() Doing: Level.ServerTravel(\""$url$"\",false)");
			// Level.ServerTravel(url,false); // This works for the server.  I think it might cause trouble for joined clients though.
			//// Could try this instead:
			NormalLog("DoLevelSwitch() Doing: "$Self$".ConsoleCommand(\"admin servertravel "$url$"\")");
			ConsoleCommand("admin servertravel "$url); // Almost works ;p
			// NormalLog("DoLevelSwitch() Doing: Level.Game.ProcessServerTravel(\""$url$"\",false)");
			// Level.Game.ProcessServerTravel(url,false); // This did not work
		}
		//// Even if I turn all these off, it seems a level change is made anyway.  Mmm dunno maybe that was with PreClientTravel().
		//// Did not work:
		// Level.ConsoleCommand("admin servertravel "$url);
	}
	*/

	#ifdef CATCH_LEVEL_SWITCH
	TryingMap = NextMap;
	Enable('Tick');
	#endif

	// bDoneGameEnd = False; // Might cause a retry in Timer().
	// SetTimer(0,False); // repeat calls should (may) be cancelled already

	// I am trying to recover from "Failed to load 'CTF-MazonSieged-006': Can't find file 'CTF-MazonSieged-006'" with:
	NextMap = "";
	// SetTimer(5,False); // TryingMap was not working with Enable('Tick') so trying timer instead...
}

function String GetGameTypeFromPrefix(String map) {
	local String prefix;
	local String s;
	prefix = Caps(StrBeforeFirst(map,"-"));
	s = "|"$ Caps(StrReplaceAll(KnownGameTypes," ","")) $"|";
	if ( StrContains(s, "|"$prefix$":") ) {
		s = StrAfterFirst(s, "|"$prefix$":");
		s = StrBeforeFirst(s, "|");
		s = StrBeforeFirst(s, ":"); // instead of taking the first, we could split them and take a random one
		return s;
	} else {
		return "";
	}
}

/*
function int HashStr(String str, optional int max) {
	local int hash;
	local int ch;
	local int i;
	if (max == 0) max = MaxData;
	for (i=0;i<Len(str);i++) {
		ch = Asc(Mid(str,i,1));
		hash += ch;
		while (hash > max) {
			hash -= max;
		}
		while (hash < 0) {
			hash += max;
		}
	}
	return hash;
}

function int MapIndex(String mapName) {
	local int i;
	i = HashStr(mapName,MaxData);
	while (true) {
		if (MapStats[i].MapName == "") { // empty
			MapStats[i].MapName = mapName;
			return i;
		}
		if (MapStats[i].MapName == mapName) { // hit
			return i;
		}
		// collision, try next slot
		if (bDebugLogging && FRand()<0.01) { DebugLog("MapIndex("$mapName$"): collision "$ mapName $" with "$MapStats[i].MapName$" at "$i); }
		i++;
		if (i>=MaxData) {
			// i = FRand()*MaxData;
			i = HashStr(mapName,MaxData);
			WarnLog("MapIndex(\"" $ mapName $ "\") hash + collision offset >= MaxData - we are either unlucky, or the map database is full; forcing overwrite of ["$i$"] "$MapStats[i].MapName$" !");
			MapStats[i].MapName = mapName;
			// TODO: we should also clear [i]'s stats!
			return i;
		}
	}
	// never reached: return 0;
}
*/

function int MapIndex(String mapName) {
	local int i,empty;
	local MapInfo freshRecord;
	empty = -1;
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName ~= mapName) {
			return i;
		}
		if (empty==-1 && MapStats[i].MapName == "") {
			empty = i;
		}
	}
	if (empty == -1) {
		i = FRand() * MaxData;
		WarnLog("MapStats database is full!  Overwriting random record for "$ MapStats[i].MapName);
	} else {
		i = empty;
	}
	// Creating a new record - we use freshRecord to overwrite any values that were not empty.
	MapStats[i] = freshRecord;
	MapStats[i].MapName = mapName;
	MapStats[i].DateLastPlayed = DaysSince1999() - 30;
	MapStats[i].PreferredPlayers = 0;
	MapStats[i].bOnDisk = true;
	MapStats[i].bCrashes = false;
	return i;
}

function float AverageActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local float totalDistance;
	local int totalCount,realTotalCount;
	local float distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	realTotalCount=0;
	totalDistance=0;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
					distance = VSize(A.Location-B.Location);
					totalDistance += distance;
					// totalDistance += distance*distance;
					realTotalCount++;
				}
			}
		}
	}
	if (realTotalCount < 2)
		return FallbackValue;
	totalDistance = totalDistance / realTotalCount;
	DebugLog("Average distance of " $ realTotalCount $ " x " $ type $ " = " $ NiceFloat(totalDistance));
	return totalDistance;
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float MaxActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local int totalCount;
	local float bestDistance,distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	if (totalCount < 2)
		return FallbackValue;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) { // TODO: this is a bad way of choose a random 5! :P
					distance = VSize(A.Location-B.Location);
					if (distance > bestDistance)
						bestDistance = distance;
				}
			}
		}
	}
	DebugLog("Max distance between " $ totalCount $ " x " $ type $ " = " $ NiceFloat(bestDistance));
	return bestDistance; // this is actually average squared-distance, we should square-root it.
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float DaysSince1999() {
	return (Level.Year-1999.0)*372.0 + Level.Month*31.0 + Level.Day + Level.Hour/24.0 + Level.Minute/24.0/60.0 + Level.Second/24.0/60.0/60.0;
}

function float ScoreForNextMap(int nextI, int currentNumPlayers) {
	local float ageInDays, playerDiff, result, preferredCount;
	// if (MapStats[nextI].DateLastPlayed>719540) MapStats[nextI].DateLastPlayed = MapStats[nextI].DateLastPlayed - 719540; // legacy: when i changed my date calculation :P
	ageInDays = DaysSince1999() - MapStats[nextI].DateLastPlayed;
	// if (ageInDays>719050) ageInDays = ageInDays - 719050; // legacy: when i changed my date calculation :P
	// if (ageInDays<0) ageInDays = -ageInDays; // legacy: when i changed my date calculation :P
	// Originally I gave +0.5 to encourage another player to join.
	// Now I give +/-0.5random in order to be fair on currentNumPlayers==Int and PreferredPlayers==Float.
	// #define deltaPlayers ( FRand() - 0.5 )
	#define deltaPlayers (FRand()*0.5)
	preferredCount = MapStats[nextI].PreferredPlayers;
	if (preferredCount == 0) {
		// Under certain conditions we may be asked to score a map for which we do not yet know the PreferredPlayers.
		// In this case we use a useful average/estimate.
		preferredCount = 9.5;
	}
	playerDiff = Abs(currentNumPlayers + deltaPlayers - preferredCount);

	// Since we divide later, we should not start playerDiff from 0.  In that
	// case, given 6 players, a map with PP=6.1 will always beat one with PP=6.5
	// even if it is a lot older.
	// Adding 5 here (almost) means a difference of 5 players is twice as bad as a difference of 1.
	playerDiff = MaxPlayerSizeDifference + playerDiff;

	// Punish large playerDiff more than small playerDiff.  (Basically 0-4 playerdiff is acceptable, but >7 playerdiff is terrible.)
	// playerDiff = 20.0 + (playerDiff*playerDiff*playerDiff);   // plot [0:10] [0:500] 20+(x)**3
	// That was way to strong.  It's no good making it stronger than linear.  I'd even be tempted to square-root it, or raise ageInDays to a power.
	// We want age to be most relevant, but playerDiff included in consideration.
	// playerDiff += 2.0; // Makes playerDiff more fuzzy, less significant, so that cycle is really more based on age of map.  This prevents us from playing the same maps repeatedly, just because the player size is "perfect".  This also avoids the possiblity of a divide-by-zero below.
	#ifndef XOL_BUILD
		if (currentNumPlayers==0) playerDiff = 12.0; // When the server is empty, all maps have the same weighting in terms of player count
	#endif
	ageInDays += 0.01;
	// TODO: tweaks zeroed until stats are fixed:
	#define flowTweak (0.0*MapStats[nextI].AveragePlayerFlow*0.125)
	// playerTweak encourages maps with larger playercount.
	#define playerTweak (0.0*MapStats[nextI].AveragePlayerCount*0.05)
	//// ratingTweak makes a map 2 hours older * number of good ratings (-2*bad).
	// #define ratingTweak (2.0/24.0*(MapStats[nextI].GoodVotes - 2*MapStats[nextI].BadVotes))
	//// ratingMultiplierTweak scales better since GetRatingForMapI is bound 0-10.
	//// A map rated 10/10 is 4 times more likely to be chosen than a map rated 0/10.
	#define ratingMultiplierTweak (0.5 + 1.5 * GetRatingForMapI(nextI)/10.0)
	// TODO: anyway playerTweak should work wrt currentNumPlayers!  playerTweak tends towards slightly larger maps, in order to encourage players to join? :o
	// if (currentNumPlayers==0 && MapStats[nextI].PreferredPlayers==0) // When the server is empty
		// ageInDays += 5.0; // boost the score of maps whose size is unknown
	// result = 384.0 * (ageInDays + flowTweak + playerTweak + ratingTweak) / playerDiff;
	result = 384.0 * (ageInDays * ratingMultiplierTweak + flowTweak + playerTweak) / playerDiff;
	if (bDebugLogging && FRand()<0.05) {
		// DebugLog("Score for "$ MapStats[nextI].MapName $" PreferredPlayers="$ NiceFloat(MapStats[nextI].PreferredPlayers) $"] is: "$ NiceFloat(result));
		// DebugLog("  ( age "$ NiceFloat(ageInDays) $"d + tweaks "$ NiceFloat(flowTweak) $" + "$ NiceFloat(playerTweak) $" + "$ NiceFloat(ratingTweak) $" ) / playerDiff "$ NiceFloat(playerDiff));
		DebugLog("  "$ MapStats[nextI].MapName $" score="$ NiceFloat(result) $" age="$ NiceFloat(ageInDays) $" rating="$ ratingMultiplierTweak $" tweaks="$ NiceFloat(flowTweak + playerTweak) $" / playerDiff="$ NiceFloat(playerDiff) $"");
	}
	return result;
}

// function bool ExistsOnDisk(String mapName) {
	// return ScanMaps(mapName); // search no longer supported
// }

function String ChooseNextMap() {
	local String bestMap;
	local float bestScore;
	local int i,currentNumPlayers;
	local float mapScore;
	local bool bCanChooseUnsizedMaps;
	// DebugLog("CountActors(UTServerAdmin) = "$CountActors(class'UTServerAdmin'));
	// DebugLog("CountActors(PlayerPawn) = "$CountActors(class'PlayerPawn'));
	if (!bMapScanDone) {
		if (bDoMapScan) {
			DebugLog("ChooseNextMap(): Scanning maps for "$Level.Game.Default.MapPrefix$" ...");
			ScanMaps();
			bDoMapScan=False;
			SaveConfig(); // I guess this could be optional, but it would slow down any subsequent boot if we don't save later :P
		} else {
			DebugLog("NOT scanning maps until you set MapMuts.MapStats bDoMapScan True");
		}
		bMapScanDone = True;
	}
	ConsideredMaps="";
	currentNumPlayers = CountPlayers();
	if (currentNumPlayers == 0 && bEmptyServerRandomMap) {
		bCanChooseUnsizedMaps = True;   // A chance to estimate player size for maps we have not yet processed
		currentNumPlayers = ServerMinPlayers + FRand() * (ServerMaxPlayers - ServerMinPlayers + 1);
		BroadcastMessage("Using random number of players "$ currentNumPlayers $" for choice.");
		NormalLog("Seeking map for "$ currentNumPlayers $" players.");
	} // TODO: If MapStats is the server's only method of map switching, it may refuse to ever try a new map.  (e.g. if bEmptyServerRandomMap is unset)
	NormalLog("Current players is "$ currentNumPlayers $", choosing...");
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].PreferredPlayers > 0 || (bCanChooseUnsizedMaps && MapStats[i].MapName!="")) {
			mapScore = ScoreForNextMap(i,currentNumPlayers);
			if (bestMap == "" || mapScore > bestScore) {
				if (MapStats[i].bDisabled) // && !bCanChooseUnsizedMaps)
					continue;
				if (StrContains(" "$RejectedMaps$" "," "$MapStats[i].MapName$" ")) {
					continue;
				}
				if (!MapStats[i].bOnDisk) {
					if (bDebugLogging && FRand()<0.01) {
						DebugLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because server no longer has it!");
					}
					// MapStats[i].bCrashes = True;
					continue;
				}
				if (MapStats[i].bCrashes) {
					if (bRetryCrashedMaps && FRand()<0.01) {
						NormalLog("ChooseNextMap(): "$ MapStats[i].MapName $" previously crashed but considering it, to see if it has been fixed.");
					} else {
						// Too frequent here, but get reported occasionally above: NormalLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because it crashes!");
						continue;
					}
				}
				if ( bStickWithCurrentMode && !( StrBefore(MapStats[i].MapName,"-") ~= StrBefore(currentMap.MapName,"-") ) ) {
					// Prefix does not match current map, rejecting.
					continue;
					// TODO: Otherwise if we do select a map with a different gametype/prefix, we should also change gametype when we switch level!
				}

				// This is our new best map!
				// if (bestMap!="" && FRand()>0.2) {

				// If it's actually better than the one before, log it:
				if (bestMap!="") {
					// ConsideredMaps = ConsideredMaps $ bestMap $"("$Left(String(mapScore),5)$")"$ " ";
					if (Level.Game.bGameEnded) {
						ConsideredMaps = ConsideredMaps $ bestMap $" ";
					} else {
						ConsideredMaps = ConsideredMaps $ bestMap $"("$ StrReplaceAll(NiceAge(DaysSince1999() - MapRecord(bestMap).DateLastPlayed)," ","_") $","$ NiceFloat(MapRecord(bestMap).PreferredPlayers) $")"$ " ";
					}
					if (Len(ConsideredMaps)>60)
						ConsideredMaps = StrAfterFirst(ConsideredMaps," ");
					NormalLog("  - "$MapStats[i].MapName$" (score "$ NiceFloat(mapScore) $", age "$ NiceAge(DaysSince1999() - MapStats[i].DateLastPlayed) $", players "$ NiceFloat(MapStats[i].PreferredPlayers) $")");
				}

				bestMap = MapStats[i].MapName;
				bestScore = mapScore;
			}
		}
	}
	NormalLog("Best map for " $ currentNumPlayers $ " was "$ bestMap $" (score "$ NiceFloat(bestScore) $", age "$ NiceAge(DaysSince1999() - MapRecord(bestMap).DateLastPlayed) $", players "$ NiceFloat(MapRecord(bestMap).PreferredPlayers)$ ")" /* );
	NormalLog( */ $"  "$ "Other considered maps were: "$ ConsideredMaps);
	return bestMap;
}

/*
function Actor GetAny(class<Actor> type) {
	local Actor A;
	foreach AllActors(type, A) {
		return A;
	}
	return None;
}
*/

function int CountActors(class<Actor> type) {
	local Actor A;
	// local Actor lA;
	local int c;
	foreach AllActors(type, A) {
		c++;
		// lA=A;
	}
	// DebugLog("CountActors("$type$") = "$c$" [first="$GetAny(type)$" last="$lA$"]");
	// if (bDebugLogging && type != class'PlayerPawn' && type != class'Spectator') { DebugLog("CountActors("$type$") = "$c); }
	return c;
}

#ifdef CATCH_LEVEL_SWITCH
event Tick(float DeltaTime) {
	if (TryingMap!="" && FRand()<0.0005) {
		// We have tried to switch map, but here we are still running.
		// Most likely the log is saying something like: Failed to load 'Level None.MyLevel': Can't find file 'CTF-Audacity'
		// We will try again, switching to a different map.
		NormalLog("CRASHED MAP: "$TryingMap);
		MapRecord(TryingMap).bCrashes = False; // TESTING TODO REMOVE: I was testing servertravel methods and falsely marking maps as crashed when actually it was the travel method
		SaveConfig();
		// We should have already saved the map marked as crashed in the last DoLevelSwitch().
		// MapRecord(TryingMap).bCrashes = True;
		// SaveConfig();
		NextMap = "";
		DoLevelSwitch();
	}
}
#endif

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCollectDamage) {
		if (TeamGamePlus(Level.Game)==None || (Victim!=None && Victim.PlayerReplicationInfo!=None && InstigatedBy!=None && InstigatedBy.PlayerReplicationInfo!=None && (Victim.PlayerReplicationInfo.Team != InstigatedBy.PlayerReplicationInfo.Team))) {
			currentMap.TotalDamage += ActualDamage;
			// bMustSave=True;
		}
	}
	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
}

function bool ScanForMapsWithPrefix(String prefix, String search) {
	local string FirstMap, NextMap, TestMap, MapName;
	local int availableCount,crashCount,unknownCount;
	local int count,i;
	local bool found;

	FirstMap = GetMapName(prefix, "", 0);
	NextMap = FirstMap;
	count = 0;
	while (!(FirstMap ~= TestMap)) {
		if ( ! ( Left(NextMap,Len(NextMap)-4) ~= (prefix$"-tutorial") ) ) {
			// Add the map.

			// DebugLog("ScanForMapsWithPrefix("$prefix$"): "$NextMap);
			count++; // maybe don't count if crashed?
			if (StrEndsWith(NextMap,".unr")) {
				MapName = StrBeforeLast(NextMap,".unr");
			} else {
				MapName = NextMap;
			}

			// Ensure a record exists for the map:
			// MapIndex(MapName);
			// MapStats[MapIndex(MapName)].bOnDisk = True;
			MapRecord(MapName).bOnDisk = True;

			if (MapRecord(MapName).bCrashes) {
				crashCount++;
			} else {
				availableCount++;
				if (MapRecord(MapName).PreferredPlayers==0)
					unknownCount++;
			}

			if (search != "") {
				if (MapName ~= search) {
					found = true;
					// return True; // we must continue, to refill the bOnDisks we cleared earlier
				}
			}

		}
		// Get the map.
		NextMap = GetMapName(prefix, NextMap, 1);
		// Test to see if this is the last.
		TestMap = NextMap;
	}

	// Always broadcast because it should never happen during play, so if it does, we want to know about it!
	BroadcastMessage("MapStats found "$ availableCount $" working "$ prefix $" maps.");
	NormalLog("ScanForMapsWithPrefix("$prefix$") Found "$ availableCount $" working "$ prefix $" maps out of "$ count $" scanned, where "$ crashCount $" crash and "$ unknownCount $" have unknown size.");

	return found;
}

function bool ScanMaps(optional String search, optional String prefix) {
	local int count,i;
	local int missingCount,blockedCount;
	local bool found;

	// prefix = Botmatch.Parent.Default.MapPrefix;
	// prefix = Botpack.CTFGame.Default.MapPrefix;

	if (prefix == "")
		prefix = Level.Game.Default.MapPrefix;

	count = 0;
	// Reset bOnDisk info, because we are about to regenerate it:
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "") {
			if (MapStats[i].bOnDisk == False) {
				missingCount++;
			}
			MapStats[i].bOnDisk = False;
			count++;
			if (i>0 && MapStats[i-1].MapName != "") {
				blockedCount++;
			}
		}
	}
	NormalLog("ScanMaps() Previous maps in database: "$count$" with "$ 100*blockedCount/count $"% congestion and "$ missingCount $" missing.");

	found = false;
	found = ScanForMapsWithPrefix(prefix,search) || found;
	// TODO: Use SplitString to parse KnownGameTypes
	found = ScanForMapsWithPrefix("CTF",search)  || found;
	found = ScanForMapsWithPrefix("DM",search)   || found;
	found = ScanForMapsWithPrefix("AS",search)   || found;
	found = ScanForMapsWithPrefix("BT",search)   || found;
	found = ScanForMapsWithPrefix("DOM",search)  || found;
	found = ScanForMapsWithPrefix("MH",search)   || found;

	SaveConfig();

	return found;
}

// Returns a rating for the map in the range 0.0-10.0
function float GetRatingForMapI(int i) {
	local float pUnknown,pGood,pBad;
	local int TotalVotes;
	pGood = MapStats[i].GoodVotes / 20.0;
	pBad = MapStats[i].BadVotes / 10.0;
	TotalVotes = MapStats[i].GoodVotes + MapStats[i].BadVotes;
	pUnknown = 0.5 / (TotalVotes + 1);
	return (pGood*10 + pBad*0 + pUnknown*5) / (pGood+pBad+pUnknown);
}

function BroadcastMapRating() {
	// BroadcastAndLog("Current rating for "$ currentMap.MapName $" is +"$ currentMap.GoodVotes $" up -"$ currentMap.BadVotes $" down.");
	BroadcastAndLog("Current rating for "$ currentMap.MapName $" is "$ Left(String(GetRatingForMapI(mapI)),3) $" (+"$ currentMap.GoodVotes $" -"$ currentMap.BadVotes $").");
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	#ifdef PLAYERS_CAN_VETO
	local String s;
	#endif
	local bool hideMessage; // Only actually works for the Sender.
	hideMessage = False;

	// We don't want anyone to see the voting messages.
	if (Msg ~= "!NO" || Msg ~= "!YES") {
		hideMessage = True;
	}

	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.

		#ifdef MAP_RATING
		if (Caps(Msg)=="GOOD MAP") { // CONSIDER: nice map, great map
			if (StrContains(currentMap.RatedUpBy,Sender.getHumanName()$" ")) {
				PlayerPawn(Sender).ClientMessage("You have ALREADY rated this map up!");
			} else {
				currentMap.GoodVotes++;
				PlayerPawn(Sender).ClientMessage("You have rated this map +1");
				currentMap.RatedUpBy = currentMap.RatedUpBy $ Sender.getHumanName() $ " ";
				BroadcastMapRating();
			}
			SaveConfig();
		}
		if (Caps(Msg)=="BAD MAP") { // CONSIDER: crap map, shit map
			if (StrContains(currentMap.RatedDownBy,Sender.getHumanName()$" ")) {
				PlayerPawn(Sender).ClientMessage("You have ALREADY rated this map down!");
			} else {
				currentMap.BadVotes++;
				PlayerPawn(Sender).ClientMessage("You have rated this map -1");
				currentMap.RatedDownBy = currentMap.RatedDownBy $ Sender.getHumanName() $ " ";
				BroadcastMapRating();
			}
			SaveConfig();
		}
		#endif

		#ifdef MAP_TAGS
		if (Left(Msg,5)~="!tag " || Left(Msg,8)~="!tagmap ") {
			AddTags(StrAfterFirst(Msg," "));
			ListMapsTo(PlayerPawn(Sender),mapName);
			SaveConfig();
		}
		#endif

		#ifdef PLAYERS_CAN_VETO
		// if (StrStartsWith(Msg,"!")) {
			// hideMessage = CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		// }
		// if (Level.Game.bGameEnded && bEndGameSwitchMap) {
		if (NextMap != "") {
			if (Msg ~= "!NO" || Msg ~= "!YES") {
				if (StrContains(VetoersList," "$Sender.getHumanName()$" ")) {
					PlayerPawn(Sender).ClientMessage("You have already voted on "$ NextMap $"!");
					hideMessage = True;
				} else {
					VetoersList = VetoersList $ " " $ Sender.getHumanName() $ " ";
					if (Msg ~= "!NO")
						NoCount++;
					if (Msg ~= "!YES")
						NoCount--;
					hideMessage = True;
					// CONSIDER TODO: saying yes/no should be equivalent to saying "good map"/"bad map" on the target map.
					if (NoCount >= MinimumNosForVeto) {
						NoCount = 0;
						VetoersList = "";
						RejectedMaps = RejectedMaps $ " " $ NextMap;
						#ifdef MAP_RATING
							// I want this to count only a little while testing, but it's an integer, so:
							if (FRand() < 0.2) {
								MapRecord(NextMap).BadVotes++;
								if (!StrContains(MapRecord(NextMap).RatedDownBy,"and vetoes ")) {
									MapRecord(NextMap).RatedDownBy = MapRecord(NextMap).RatedDownBy $ "and vetoes ";
								}
							}
						#endif
						NextMap = ChooseNextMap();
						// BroadcastAndLog("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1999() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
						BroadcastAndLog("Next map will be: "$ NextMap $" (last played "$ NiceAge(DaysSince1999() - MapRecord(NextMap).DateLastPlayed) $" ago)");
					} else {
						s = "s" ; if ((MinimumNosForVeto-NoCount)==1) s = "";
						BroadcastAndLog( (MinimumNosForVeto-NoCount) $" more vote"$s$" needed to reject "$ NextMap);
					}
					// hideMessage = True; // Hiding it from sender might confuse him/her, if he can see other people's.
				}
			}
		}
		// }
		#endif

		#ifdef PLAYERS_CAN_SKIP_MAP
		if (Msg ~= "!SKIP") {
			CountSkip(PlayerPawn(Sender));
		}
		#endif

		// if (bDisplayInfoWhenVoting) {
			// TODO: We want to catch messages such as: The_Master voted for xLMS-Gothic
			// And then display its size to the players (and maybe its ratings too).
		// }

	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage /* || !bSwallowSpokenCommands */ );
}

// Catch mutate messages:
function Mutate(String str, PlayerPawn Sender) {
	local PlayerPawn p;
	if (bAllowMutateSwitch) {
		if (str~="suggest") {
			// If we want to veto the currentNextMap:
			// if (NextMap != "")
				// RejectedMaps = RejectedMaps $ " " $ NextMap;
			NextMap = ChooseNextMap();
			// Sender.ClientMessage("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1999() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
			Sender.ClientMessage("Next: "$ NextMap $" ("$ NiceAge(DaysSince1999() - MapRecord(NextMap).DateLastPlayed) $") Beaten: "$ConsideredMaps$"");
			// BroadcastMessage("Next map will be "$NextMap);
		}
		if (
			   (str~="nextmap" && Sender.bAdmin)
			|| (str~="nextmap" && CountPlayers()==1)
			|| (str~= ("nextmap "$ ConsoleCommand("get engine.gameinfo AdminPassword") ) )
			// || str ~= "nextmap..."
			// || str ~= "next..." // FIXED (WARNING BUG): This little backdoor allows any player to force a mapswitch, but I am currently using it for TESTING.
		) {
			// if (Level.Game.bGameEnded) {
			if (FRand()<0.25) {
				DoLevelSwitch();
				return; // Just to avoid printing the "Repeat call" message below.
			}
			// Level.Game.bGameEnded = (FRand()<0.3);
			// if (Level.Game.bGameEnded) {
				// foreach AllActors(class'PlayerPawn',p) {
					// p.PreClientTravel(); // We need this when doing Level.ServerTravel()!  Otherwise clients get "Connection failed" when server switches map.
					// // p.ClientTravel("?reconnect", TRAVEL_Relative, False);
				// }
			// }
			if (NextMap=="")
				NextMap = ChooseNextMap();
			// Sender.ClientMessage("Repeat call to switch map to "$ NextMap $" (state= "$ Level.Game.bGameEnded $")");
			Sender.ClientMessage("Repeat call to switch map to "$ NextMap $"");
		}
		if (str~="scanmaps" && Sender.bAdmin) {
			bDoMapScan=True;
			bMapScanDone=False;
			ScanMaps(,"AS");
			ScanMaps(,"BT");
			ScanMaps(,"CTF");
			ScanMaps(,"DM");
			ScanMaps(,"DOM");
			ScanMaps(,"RA");
		}
		if (StrStartsWith(Caps(str),"LIST ") || StrStartsWith(Caps(Str),"LISTMAPS")) { // aka SHOWINFO
			if (StrContains(str," ")) {
				ListMapsTo(Sender,StrAfterFirst(str," "));
			} else {
				ListMapsTo(Sender,"");
			}
		}
		#ifdef LIST_RECENTLY_PLAYED
		if (str~="LISTRECENT" || str~="LASTMAPS") {
			Sender.ClientMessage("Recently played maps: "$ RecentlyPlayedMaps);
		}
		#endif
		if (str~="help") {
			Sender.ClientMessage("MapStats say commands: !yes | !no | good map | bad map | !tag <tag1,tag2,...>");
			Sender.ClientMessage("MapStats mutate commands: help | suggest | list <part_of_mapname> | listrecent");
			Sender.ClientMessage("MapStats admin mutate commands: nextmap | scanmaps");
		}
	}
	// CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

function ListMapsTo(PlayerPawn p, String searchStr) {
	local int i;
	local bool hit;
	local String outStr;
	searchStr = Caps(searchStr);
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "" && StrContains(Caps(MapStats[i].MapName),searchStr)) {
			outStr = "["$i$"]";
			if (MapStats[i].bCrashes) outStr = outStr $ " CRASHES";
			if (!MapStats[i].bOnDisk) outStr = outStr $ " MISSING";
			if (MapStats[i].bDisabled) outStr = outStr $ " DISABLED";
			#ifdef MAP_RATING
				if (MapStats[i].GoodVotes+MapStats[i].BadVotes > 0) {
					outStr = outStr $ " rating="$ Left(String(GetRatingForMapI(i)),3);
					outStr = outStr $" (+"$ MapStats[i].GoodVotes $" -"$ MapStats[i].BadVotes $")";
				}
			#endif
			outStr = outStr $ " #="$Left(""$MapStats[i].PreferredPlayers,4);
			outStr = outStr $ " "$ MapStats[i].MapName;
			outStr = outStr $ " games="$(MapStats[i].GamesStarted+MapStats[i].GamesEnded)/2;
			outStr = outStr $ " flow="$Left(String(MapStats[i].AveragePlayerFlow),3);
			#ifdef MAP_TAGS
				outStr = outStr $ " tags="$MapStats[i].Tags;
			#endif
			p.ClientMessage(outStr);
			hit = true;
		}
	}

	if (MapStats[i].MapName != "") { // TODO: bAdmin ?
		NextMap = MapStats[i].MapName;
		p.ClientMessage("Next map will be "$NextMap);
	}

	if (hit == false) {
		p.ClientMessage("I could not find any map matching "$Locs(searchStr)$" - try \"mutate scanmaps\" to rescan at next mapswitch.");
	}
}

#ifdef MAP_TAGS
function AddTags(String tags) {
	currentMap.Tags = currentMap.Tags $ tags $ ",";
	// done outside atm: SaveConfig();
}
#endif

#ifdef PLAYERS_CAN_SKIP_MAP
function CountSkip(PlayerPawn Sender) {
	local int countedPlayers, countedVotes;
	local Pawn p;
	local int votesNeeded;
	WhenVotedForSkip[Sender.PlayerReplicationInfo.PlayerID % 64] = Level.TimeSeconds;
	countedVotes = 0;
	for (p=Level.PawnList; p!=None; p=p.NextPawn) {
		if (p.IsA('PlayerPawn') && !p.IsA('Spectator')) {
			countedPlayers++;
			// Votes only count for 1 minute, then they are forgotten.  (UT is a fast game, remember.)
			if (WhenVotedForSkip[p.PlayerReplicationInfo.PlayerID % 64] > 0 && Level.TimeSeconds - WhenVotedForSkip[p.PlayerReplicationInfo.PlayerID % 64] < 60) {
				countedVotes++;
			}
		}
	}
	votesNeeded = countedPlayers * PercentageForMapSkip / 100 + 1;
	if (countedVotes >= votesNeeded) {
		// BroadcastAndLog("Skipping map as requested by " $ countedVotes $ " players.");
		BroadcastAndLog("Skipping map as requested.");
		DoLevelSwitch();
	} else {
		BroadcastAndLog((votesNeeded-countedVotes) $ " more votes needed to skip map.");
	}
}
#endif

// #include "../../JLib/findactor.uc.jpp"

#include "../../JLib/jlib.uc.jpp"

