// vim: tabstop=2 shiftwidth=2 noexpandtab filetype=uc

// TODO: Instead of players vetoing maps with "no" we could give them a list of 3,4,5 need-to-be-played maps and let them pick one.

// TODO: Allow automatically add muts to certain maps.  (e.g. instagib for the no weapon ctf maps)

// All XOL's info is stored in Fate.BestFitMapList

// DONE: mutate search <part_of_mapname>   so we can see what maps are installed even if they aren't in mapvote
// DONE: add "good map" "bad map" detection (copy it from ATB!)

// Is it bad HCI to call it "good map"/"bad map" when the actual effect is to "see the map more/less often"?

// CONSIDER: on the one hand, people voting a map means it's a good map
//           on the other hand, we want to offer maps people don't play much, until it is rated

#define MaxData 3000

class MapStats expands Mutator config(MapStats);

// MapScale is an estimate of the universal constant for ideal player count estimation wrt actor distance.  (Higher values bring actors closer together, making it think maps are smaller, so it will make us play larger maps?)
#define MapScale 400
#define NumberOfSpawnPointsScaled (NumberOfSpawnPoints*0.6)
#define FallbackValue (NumberOfSpawnPointsScaled*MapScale)

// I thought this was needed for immediate switch to work 100%, but I'm not 100% sure.
// With or without this, *sometimes* it didn't change to NextMap at all, but to the next map in UT's cycle I think (Gauntlet/Command/...).
// #define CATCH_LEVEL_SWITCH
#define MAP_RATING
#define MAP_TAGS
// PLAYERS_CAN_VETO affects bEndGameSwitchMap
#define PLAYERS_CAN_VETO
#define LIST_RECENTLY_PLAYED
#define MinimumNosForVeto 1

var config bool bLogging;
var config bool bDebugLogging;
var config bool bCollectMapStats;
var config bool bCollectDamage;
var config bool bEstimatePreferredPlayers;
var config bool bEndGameSwitchMap;
var config int EndGameSwitchSeconds;
var config bool bEmptyServerSwitchMap;
var config int EmptyServerSwitchSeconds;
var config bool bAllowMutateSwitch;
var config bool bSetMaxPlayers;
var config bool bAutoExpandMaxPlayers;
var config int ServerMinPlayers;
var config int ServerMaxPlayers;
var config bool bDoMapScan;
var config bool bShowLevelEnterText;
var config bool bStickWithCurrentMode; // turn it on to keep server playable (no CTF on DM maps etc.!) - turn it off to scan all map-sizes
// TODO: determine required level switch gametype from prefix or from map itself, thus allowing switching to other gametypes
#ifdef LIST_RECENTLY_PLAYED
var config bool bListRecentlyPlayed;
#endif

struct MapInfo {
	var String MapName;
	var float PreferredPlayers;
	var float DateLastPlayed;
	var bool bOnDisk;
	var bool bCrashes;
	var bool bDisabled;
	var int GamesStarted;
	var int GamesEnded;
	var float HoursPlayed;
	var float AverageFlow;
	var float AverageNumPlayers;
	var int Deaths;
	var float Damage;
	// var int NumberOfSpawnPoints;
	// var int NumberOfWeaponPickups;
	// var int NumberOfPathNodes;
	// var float ActorDistance;
	#ifdef MAP_RATING
	var int GoodVotes;
	var int BadVotes;
	var String RatedUpBy;
	var String RatedDownBy;
	#endif
	#ifdef MAP_TAGS
	var String Tags; // Comma separated list.  If user inputs commas then they are inputting multiple tags.
	#endif
};

var config MapInfo MapStats[MaxData];

var String mapName; // Current map's name, generated at start.
var int mapI; // Current map's index, generated at start.
#define currentMap MapStats[mapI]
var float NumberOfSpawnPoints; // Globalised for FallbackValue

var float StartTime;
var int PlayerCountAtStart;
var bool bMapScanDone;
var bool bDoneGameEnd;
var bool bCanChooseUnsizedMaps;
var String ConsideredMaps;
var bool bInterceptTravel;
var String NextMap;
var String RejectedMaps;
#ifdef PLAYERS_CAN_VETO
var int NoCount;
#endif
#ifdef MAP_RATING
#endif
#ifdef LIST_RECENTLY_PLAYED
var String RecentlyPlayedMaps;
#endif

defaultproperties {
bLogging=True
bDebugLogging=False
bCollectMapStats=True
bCollectDamage=False
bEstimatePreferredPlayers=True
bEndGameSwitchMap=False
EndGameSwitchSeconds=30
bEmptyServerSwitchMap=False
EmptyServerSwitchSeconds=120
bAllowMutateSwitch=True
bSetMaxPlayers=False
bAutoExpandMaxPlayers=False
ServerMinPlayers=6
ServerMaxPlayers=24
bDoMapScan=True
bShowLevelEnterText=True
bStickWithCurrentMode=True
#ifdef LIST_RECENTLY_PLAYED
bListRecentlyPlayed=True
#endif
}

#define MapRecord(X) MapStats[MapIndex(X)]

#define CountPlayers() ( CountActors(class'PlayerPawn') - CountActors(class'Spectator') )

// #define DebugLog(Y); 
#define DebugLog(Y); if (bDebugLogging) { Log("-MapStats- " $ Y); }
// #define NormalLog(Y); 
#define NormalLog(Y); if (bLogging) { Super.Log("[MapStats] " $ Y); }
// Fails: // function NormalLog(String Y) { if (bLogging) { Super.Log(Y); } }
// Fails: // #define Log(Y); NormalLog(Y);

#define BroadcastAndLog(Y); BroadcastMessage(Y); if (bLogging) { Log("[MapStats] Broadcasted: " $ Y); }

#define NiceAge(X) Int((X)*24)$"h"
#define NiceFloat FloatToString
function String FloatToString(float f) {
	local String s;
	local int i;
	s = String(f);
	i = InStr(s,".");
	if (i>=4) return StrBeforeLast(s,".");
	s = StrBeforeFirst(s,".") $ "." $ Left( StrAfterFirst(s,"."), 4-i ); // may not be accurate enough for 0.000001
	return s;
}

function PostBeginPlay() {

	//// Pushing out new default configs during a temporary release:
	// EmptyServerSwitchSeconds=5*60; // XOL is still learning about the maps
	// EmptyServerSwitchSeconds=60*60;
	// bDebugLogging=True;
	// if (FRand()<0.01)
		// bDoMapScan=True;

	mapName = StrBeforeFirst(""$Self,".");
	mapI = MapIndex(mapName);
	NumberOfSpawnPoints = CountActors(class'PlayerStart');

	if (bCollectDamage)
		Level.Game.RegisterDamageMutator(Self);

	// TODO:
	// If we were not added as a mutator, but run in some other way (e.g. as a ServerActor), then we need to register as a mutator:
   // Level.Game.BaseMutator.AddMutator(Self);

	// Register to receive spoken messages in MutatorTeamMessage() below:
	Level.Game.RegisterMessageMutator(Self);

	DoStart();

	SetTimer(5.0,True);

}

function DoStart() {
	// This is actually done when the map is loaded.
	// The game starts when a player joins - see ModifyPlayer().
	local String idealPlayerCount,gotNum,restStr;
	local int count;
	local float avg,num;
	local bool bMustSave;
	// local float NumberOfSpawnPoints;
	local float ActorDistance;

	// ScanMaps();

	#ifdef LIST_RECENTLY_PLAYED
	RecentlyPlayedMaps = StrReplace(RecentlyPlayedMaps,mapName$" ","") $ mapName $ " ";
	if (Len(RecentlyPlayedMaps)>40) {
		RecentlyPlayedMaps = StrAfterFirst(RecentlyPlayedMaps," ");
	}
	bMustSave = True;
	#endif

	if (bCollectMapStats) {
		// NormalLog("Collecting stats ...");
		if (currentMap.bCrashes) { NormalLog("FIXED! Map "$ mapName $" was previously crashing, but now works!"); } // duh this is often set to true inaccurately by DoLevelSwitch :P
		// currentMap.ActorDistance = (MaxActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode')) / 3.0;
		// currentMap.NumberOfSpawnPoints = CountActors(class'PlayerStart');
		// currentMap.NumberOfWeaponPickups = CountActors(class'Weapon');
		// currentMap.NumberOfPathNodes = CountActors(class'PathNode');
		// bMustSave = True;
		NormalLog(mapName $" NumberOfSpawnPoints = "$ CountActors(class'PlayerStart'));
		NormalLog(mapName $" NumberOfWeaponPickups = "$ CountActors(class'Weapon'));
		NormalLog(mapName $" NumberOfPathNodes = "$ CountActors(class'PathNode'));
		NormalLog(mapName $" ActorDistance = "$ (MaxActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode')) / 3.0);
	}

	if (bEstimatePreferredPlayers) {

		// Should we regenerate the map's PreferredPlayers estimate with the latest algorithm?
		#define bRegeratePreferredPlayers True
		if (
			currentMap.PreferredPlayers == 0 || bRegeratePreferredPlayers
		) {
			// We are allowed to modify the PreferredPlayers count for this map, and should now do our best

			DebugLog("Re-calculating PreferredPlayers, old value = "$ NiceFloat(currentMap.PreferredPlayers));

			// DebugLog("Collecting ActorDistance for "$mapName$"...");
			ActorDistance = ( MaxActorDistanceType(class'FlagBase') + MaxActorDistanceType(class'Weapon') + AverageActorDistanceType(class'PlayerStart') + AverageActorDistanceType(class'PathNode') ) / 4.0 / Float(MapScale);
			if (ActorDistance < 2)
				ActorDistance = 2;
			if (ActorDistance > 32)
				ActorDistance = 32;

			// Get map author's suggested IdealPlayerCount:
			idealPlayerCount = Level.IdealPlayerCount;
			// DebugLog("Getting map author's IdealPlayerCount from \""$idealPlayerCount$"\"...");
			NormalLog(mapName $" previous PreferredPlayers = "$ currentMap.PreferredPlayers);
			restStr = idealPlayerCount;
			avg = 0.0;
			count = 0;
			do {
				gotNum = StrFilterNum(restStr,true,restStr);
				if (gotNum!="") {
					num = Float(gotNum);
					// DebugLog("MapStats: Got "$num$" from \""$gotNum$"\" with rest="$restStr);
					if (num>0) {
						// avg = (count*avg + num) / (count+1);
						avg += num;
						count++;
					}
					if (StrStartsWith(restStr,"-"))
						restStr = Mid(restStr,1);
				}
			} until (gotNum == "");
			if (count>0) avg = avg / count;

			// Build estimated PreferredPlayers from avg, NumberOfSpawnPoints and ActorDistance:
			if ( count>0 ) {
				// DebugLog(mapName$" Got IdealPlayerCount "$avg$" from \""$idealPlayerCount$"\".");
				if (avg>20) avg=20;
				currentMap.PreferredPlayers = avg;
				// Mix it with NumberOfSpawnPoints and ActorDistance:
				currentMap.PreferredPlayers = 0.4*avg + 0.3*NumberOfSpawnPointsScaled + 0.3*ActorDistance;
				NormalLog(mapName$" Estimate from Ideal("$ idealPlayerCount $"=>"$ NiceFloat(avg) $") and PlayerStarts("$ NiceFloat(NumberOfSpawnPointsScaled) $") and ActorDistance("$ NiceFloat(ActorDistance) $")");
			} else {
				// Mix just NumberOfSpawnPoints and ActorDistance:
				currentMap.PreferredPlayers = 0.5*NumberOfSpawnPointsScaled + 0.5*ActorDistance;
				NormalLog(mapName$" Estimate from PlayerStarts("$ NiceFloat(NumberOfSpawnPointsScaled) $") and ActorDistance("$ NiceFloat(ActorDistance) $")");
			}
			NormalLog(mapName$" PreferredPlayers = "$ NiceFloat(currentMap.PreferredPlayers));

			bMustSave = True;

		}

	} else {

		NormalLog(mapName$" PreferredPlayers = "$ NiceFloat(currentMap.PreferredPlayers));

	}

	// If it was marked as crashed or not on-disk, We MUST mark this map as working!
	if (currentMap.bCrashes || !currentMap.bOnDisk) bMustSave=True;
	currentMap.GamesStarted++;
	// currentMap.DateLastPlayed = DaysSince1970(); // We need this to stop empty-switching to the same map every time.  But if we only want to record when a player actually plays the map, remove this line.
	currentMap.DateLastPlayed = (currentMap.DateLastPlayed + DaysSince1970()) / 2.0; // Compromise: we mix the two values (it becomes half as old).
	currentMap.bCrashes = False; // Was most likely set just before the server switched to this map.  We prove non-crash here.
	currentMap.bOnDisk = True; // Also proved here (but should be already known from ScanMaps()).

	// #define bSaveEarly False
	// if (bSaveEarly && (bCollectMapStats || bEstimatePreferredPlayers)) bMustSave=True;
	if ( bMustSave ) {
		DebugLog("DoStart(): Calling SaveConfig()");
		SaveConfig();
		bMustSave = False;
	}

	if (bSetMaxPlayers && currentMap.PreferredPlayers>0) {
		Level.Game.MaxPlayers = 2*Int( (currentMap.PreferredPlayers+1.0)/2.0 );
		if (Level.Game.MaxPlayers < ServerMinPlayers)
			Level.Game.MaxPlayers = ServerMinPlayers;
		if (Level.Game.MaxPlayers > ServerMaxPlayers)
			Level.Game.MaxPlayers = ServerMaxPlayers;
		NormalLog("bSetMaxPlayers: MaxPlayers set to "$ Level.Game.MaxPlayers);
	}

}

function ModifyPlayer(Pawn Other) {
	// if (PlayerPawn(Other) != None) {
	if (Other!=None && Other.PlayerReplicationInfo != None) {
		// DebugLog("ModifyPlayer("$ Other.getHumanName() $") was called.");
		if (/*PlayerPawn(Other)!=None && Spectator(Other)==None &&*/ Other.PlayerReplicationInfo.Deaths == 0) {
			DebugLog("ModifyPlayer("$ Other$"): "$ Other.getHumanName() $" joined at "$ Level.TimeSeconds);

			// Latest player join!
			if (StartTime == 0) {
				// First ever spawn!
				// StartTime = Level.TimeSeconds;
				// PlayerCountAtStart = CountPlayers();
				// DebugLog("ModifyPlayer("$Other$"): setting StartTime="$Level.TimeSeconds$" and PlayerCountAtStart="$ CountPlayers() );
				StartTime = Level.TimeSeconds;
				DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting StartTime="$Level.TimeSeconds);
				currentMap.DateLastPlayed = DaysSince1970(); // yeah we really want the last date a human played, although this might mess with ChooseNextMap() if no humans are around.  otoh that now has random stuff built in :)
				// We can't set the PlayerCountAtStart here, because other players might join later this second.
				// Although we can detect the last of them, if bots start joining too.  But bots may not always be around.
				// Instead we wait for the first frag below, before grabbing PlayerCountAtStart.
			}
			// currentMap.DateLastPlayed = DaysSince1970(); // hope that a SaveConfig happens later (should happen in DoEnd())
		} else {
			// A frag / someone/thing died
			currentMap.Deaths++;
			if (StartTime == 0) {
				// First ever frag!
				// StartTime = Level.TimeSeconds;
				// DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting StartTime="$Level.TimeSeconds);
			}
			if (PlayerCountAtStart == 0 && Level.TimeSeconds>=30) { // give them 30 seconds to download the map / join the server
				PlayerCountAtStart = CountPlayers();
				DebugLog("ModifyPlayer("$Other.getHumanName()$"): setting PlayerCountAtStart="$ CountPlayers() $" at "$ Level.TimeSeconds);
			}
		}

		if (Other.PlayerReplicationInfo.Deaths == 0 && bShowLevelEnterText && Level.LevelEnterText != "") {
			PlayerPawn(Other).ClientMessage(Level.Title $ " : " $ Level.LevelEnterText);
		}

	}
	Super.ModifyPlayer(Other);
}

event Timer() {

	// Mid-game checks:
	if (bEmptyServerSwitchMap && CountPlayers()==0 /* CountActors(class'PlayerPawn')==CountActors(class'UTServerAdminSpectator') */ && Level.TimeSeconds>EmptyServerSwitchSeconds && FRand() < 0.2) {
		NormalLog("Timer(): bEmptyServerSwitchMap=True - auto switching at "$Level.TimeSeconds$"");
		// Level.Game.bGameEnded = True;
		// bDoneGameEnd = True; // This prevents DoEnd() from being called, which is good since it's an idle server switch, not a real end-game.
		bCanChooseUnsizedMaps = True;
		DoLevelSwitch();
	}

	#define bIgnoreMapSizeWhenChangingServerMax False
	if (bAutoExpandMaxPlayers) {
		// Need to expand?
		if (CountPlayers()+1 > Level.Game.MaxPlayers && Level.Game.MaxPlayers+2 <= ServerMaxPlayers) {
			if (bIgnoreMapSizeWhenChangingServerMax || Level.Game.MaxPlayers < currentMap.PreferredPlayers*2) {
				Level.Game.MaxPlayers += 2;
				NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers increased to "$ Level.Game.MaxPlayers);
			}
		}
		// Need to shrink?
		if (CountPlayers() < ServerMinPlayers && Level.Game.MaxPlayers-2 >= ServerMinPlayers && FRand()<0.01) {
			if (bIgnoreMapSizeWhenChangingServerMax || Level.Game.MaxPlayers > currentMap.PreferredPlayers) {
				Level.Game.MaxPlayers -= 2;
				NormalLog("bAutoExpandMaxPlayers: "$ CountPlayers() $" players => MaxPlayers reduced to "$ Level.Game.MaxPlayers);
			}
		}
		// Level.Game.MaxPlayers = 2*Int( (CountActors(class'PlayerPawn')+1.0)/2.0 );
	}

	// Check if game has just ended:
	if (Level.Game.bGameEnded && !bDoneGameEnd) {
		DoEnd();
		bDoneGameEnd = True;
		if (bEndGameSwitchMap) {
			NextMap = ChooseNextMap();
			// BroadcastAndLog("Map will change to "$ NextMap $" in "$EndGameSwitchSeconds$" seconds.");
			// #ifdef PLAYERS_CAN_VETO
			// BroadcastAndLog("Next map will be "$ NextMap $"... say no to reject.");
			// #else
			// BroadcastAndLog("Next map will be "$ NextMap $".");
			// #endif
			// BroadcastAndLog("(Other maps: "$ ConsideredMaps $")");
			BroadcastAndLog("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
			// We do the switch in the if clause below, when Timer is next called.
			SetTimer(EndGameSwitchSeconds,False);
		} else {
			NormalLog("bEndGameSwitchMap=False, but chosen map would have been: "$ChooseNextMap());
		}
		return;
	}

	// Check if game is well over:
	if (Level.Game.bGameEnded && bDoneGameEnd && bEndGameSwitchMap) {
		DoLevelSwitch();
	}

}

function DoLevelSwitch() {
	local float num;
	local PlayerPawn p;

	if (NextMap == "") {
		NextMap = ChooseNextMap();
	}

	// MapRecord(NextMap).DateLastPlayed = DaysSince1970(); // If we are auto-switching maps, we will keep cycling through the same set, if we don't update the date somehow.  (Might be nicer to set date = 1 day ago, unless a player joins and makes it more recent.  But that's still not ideal.  What is?)  OK moved to DoStart(), where we move the time half-way.
	MapRecord(NextMap).bCrashes = True;
	// In case server crashes, this stops it from being chosen again!  (Combined with bCrashes or DateLastPlayed.)
	// NO OLD: It's also desirable to mark maps which we found weren't on the disk, so we don't have to scan them again.
	// BUG TODO: If Tick intercepts the switch, it will see the bCrashes==True, and choose another map!
	DebugLog("DoLevelSwitch() calling SaveConfig()");
	SaveConfig();

	BroadcastAndLog("Considered maps: "$ ConsideredMaps);
	// BroadcastAndLog("Switching to "$ NextMap $" now.");

	num = (DaysSince1970() - MapRecord(NextMap).DateLastPlayed);
	if (num<2.0) {
		// NormalLog(mapName$" was last played "$ Int(24*num+0.5) $" hours ago.");
		BroadcastAndLog("Switching to "$ NextMap $", last played "$ Int(24.0*num+0.5) $" hours ago.");
	} else {
		// NormalLog(mapName$" was last played "$ Int(num+0.5) $" days ago.");
		BroadcastAndLog("Switching to "$ NextMap $", last played "$ Int(num+0.5) $" days ago.");
	}

	#ifdef CATCH_LEVEL_SWITCH
	bInterceptTravel = True;
	Enable('Tick');
	#endif
	// if (!StrEndsWith(Caps(NextMap),".UNR"))
		// NextMap = NextMap $ ".unr";
	// UTServerAdmin(GetAny(class'UTServerAdmin')).ConsoleCommand("admin servertravel "$ NextMap );
	// Log("MapStats.DoLevelSwitch() Switching to map: "$ NextMap);

	// New method, call anyAdminPlayer.ConsoleCommand().  This solves the problems with Level.ServerTravel() "kicking" players out and Level.Game.ProcessServerTravel() changing to the wrong map.
	foreach AllActors(class'PlayerPawn',p) {
		// break; // Get the last one - The first one is useless!
	}
	if (p != None) {
		p.bAdmin = True;
		NormalLog("DoLevelSwitch() Calling "$p.getHumanName()$".ConsoleCommand(\"admin servertravel "$NextMap$"\")");
		p.ConsoleCommand("admin servertravel "$NextMap);
		p.bAdmin = False;
	} else {
		//// Fallback method.
		NormalLog("DoLevelSwitch() No pawn available for consolecommand, trying Level.ServerTravel(\""$ NextMap $"\")");
		// Did not work:
		// Level.NextURL = NextMap;
		Level.ServerTravel(NextMap,false); // This works for the server.  I think it might cause trouble for joined clients though.
		// Level.Game.ProcessServerTravel(NextMap,false); // This did not work
	}

	// bDoneGameEnd = False;
	SetTimer(0,False); // repeat calls should (may) be cancelled already
}

function DoEnd() {
	local float playerChangeThisMap,averageNumPlayersThisMap;
	local float totalHours,deltaHours,newTotalHours;

	if (bCollectMapStats) {

		totalHours = currentMap.HoursPlayed;
		deltaHours = (Level.TimeSeconds - StartTime) / 60.0 / 60.0;

		// if ( (PlayerCountAtStart == 0 && CountPlayers() == 0)
			// || (deltaHours>0.5 && (PlayerCountAtStart == 0 || CountPlayers() == 0))
		// ) {
			// DebugLog("Not updating any stats for this game on "$mapName$", since it took "$(deltaHours*60)$" minutes, and either started or ended with only bots.");
			// // return;
			// // Maybe we should do currentMap.GamesStarted--;  Chances are that stat has already been saved.
			// currentMap.GamesStarted--;
			// // Problem: map's Damage and Deaths have increased, and we can't recover the old values!
		// } else {

			currentMap.GamesEnded++;
			// currentMap.DateLastPlayed = DaysSince1970();

			newTotalHours = currentMap.HoursPlayed + deltaHours;

			playerChangeThisMap = CountPlayers() - PlayerCountAtStart;
			currentMap.AverageFlow = (totalHours*currentMap.AverageFlow + deltaHours*playerChangeThisMap) / newTotalHours;

			averageNumPlayersThisMap = (CountPlayers() + PlayerCountAtStart) / 2.0;
			currentMap.AverageNumPlayers = (totalHours*currentMap.AverageNumPlayers + deltaHours*averageNumPlayersThisMap) / newTotalHours;

			currentMap.HoursPlayed = newTotalHours;

		// }

	}

	DebugLog("DoEnd() calling SaveConfig()");
	SaveConfig();

}

function int HashStr(String str, optional int max) {
	local int hash;
	local int ch;
	local int i;
	if (max == 0) max = MaxData;
	for (i=0;i<Len(str);i++) {
		ch = Asc(Mid(str,i,1));
		hash += ch;
		while (hash > max) {
			hash -= max;
		}
		while (hash < 0) {
			hash += max;
		}
	}
	return hash;
}

function int MapIndex(String mapName) {
	local int i;
	i = HashStr(mapName,MaxData);
	while (true) {
		if (MapStats[i].MapName == "") { // empty
			MapStats[i].MapName = mapName;
			return i;
		}
		if (MapStats[i].MapName == mapName) { // hit
			return i;
		}
		// collision, try next slot
		if (bDebugLogging && FRand()<0.01) { DebugLog("MapIndex("$mapName$"): collision "$ mapName $" with "$MapStats[i].MapName$" at "$i); }
		i++;
		if (i>=MaxData) {
			// i = FRand()*MaxData;
			i = HashStr(mapName,MaxData);
			Log("[MapStats] Warning! MapIndex(\"" $ mapName $ "\") hash + collision offset >= MaxData - we are either unlucky, or the map database is full; forcing overwrite of ["$i$"] "$MapStats[i].MapName$" !");
			MapStats[i].MapName = mapName;
			// TODO: we should also clear [i]'s stats!
			return i;
		}
	}
	// never reached: return 0;
}

function float AverageActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local float totalDistance;
	local int totalCount,realTotalCount;
	local float distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	realTotalCount=0;
	totalDistance=0;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) {
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) {
					distance = VSize(A.Location-B.Location);
					totalDistance += distance;
					// totalDistance += distance*distance;
					realTotalCount++;
				}
			}
		}
	}
	if (realTotalCount < 2)
		return FallbackValue;
	totalDistance = totalDistance / realTotalCount;
	DebugLog("Average distance of " $ realTotalCount $ " x " $ type $ " = " $ NiceFloat(totalDistance));
	return totalDistance;
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float MaxActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local int totalCount;
	local float bestDistance,distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	if (totalCount < 2)
		return FallbackValue;
	foreach AllActors(type, A) {
		if (FRand()<5.0/totalCount) {
			foreach AllActors(type, B) {
				if (A==B) continue;
				if (FRand()<5.0/totalCount) {
					distance = VSize(A.Location-B.Location);
					if (distance > bestDistance)
						bestDistance = distance;
				}
			}
		}
	}
	DebugLog("Max distance between " $ totalCount $ " x " $ type $ " = " $ NiceFloat(bestDistance));
	return bestDistance; // this is actually average squared-distance, we should square-root it.
	// return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function float DaysSince1970() {
	return (Level.Year-1970.0)*365.25 + Level.Month*30.0 + Level.Day + Level.Hour/24.0 + Level.Minute/24.0/60.0 + Level.Second/24.0/60.0/60.0;
}

function float ScoreForNextMap(int nextI, int currentNumPlayers) {
	local float ageInDays, playerDiff, result;
	// if (MapStats[nextI].DateLastPlayed>719540) MapStats[nextI].DateLastPlayed = MapStats[nextI].DateLastPlayed - 719540; // legacy: when i changed my date calculation :P
	ageInDays = DaysSince1970() - MapStats[nextI].DateLastPlayed;
	// if (ageInDays>719050) ageInDays = ageInDays - 719050; // legacy: when i changed my date calculation :P
	// if (ageInDays<0) ageInDays = -ageInDays; // legacy: when i changed my date calculation :P
	// Originally I gave +0.5 to encourage another player to join.
	// Now I give +/-0.5random in order to be fair on currentNumPlayers==Int and PreferredPlayers==Float.
	// #define deltaPlayers ( FRand() - 0.5 )
	#define deltaPlayers (FRand()*0.5)
	playerDiff = Abs(currentNumPlayers + deltaPlayers - MapStats[nextI].PreferredPlayers);
	playerDiff += 2.0; // Makes playerDiff more fuzzy, less significant, so that cycle is really more based on age of map.  This prevents us from playing the same maps repeatedly, just because the player size is "perfect".  This also avoids the possiblity of a divide-by-zero below.
	// if (currentNumPlayers==0) playerDiff = 12.0; // When the server is empty, all maps have the same weighting in terms of player count
	ageInDays += 0.01;
	// TODO: tweaks zeroed until stats are fixed:
	#define flowTweak (0.0*MapStats[nextI].AverageFlow*0.125)
	// playerTweak encourages maps with larger playercount.
	#define playerTweak (0.0*MapStats[nextI].AverageNumPlayers*0.05)
	// ratingTweak makes a map 1 hour older * number of good ratings (-bad).
	#define ratingTweak (2.0/24.0*(MapStats[nextI].GoodVotes - 2*MapStats[nextI].BadVotes))
	// TODO: anyway playerTweak should work wrt currentNumPlayers!  playerTweak tends towards slightly larger maps, in order to encourage players to join? :o
	// if (currentNumPlayers==0 && MapStats[nextI].PreferredPlayers==0) // When the server is empty
		// ageInDays += 5.0; // boost the score of maps whose size is unknown
	result = 384.0 * ( ageInDays + flowTweak + playerTweak + ratingTweak) / playerDiff;
	if (bDebugLogging && FRand()<0.05) {
		DebugLog("Score for "$ MapStats[nextI].MapName $" PreferredPlayers="$ NiceFloat(MapStats[nextI].PreferredPlayers) $"] is: "$ NiceFloat(result));
		DebugLog("  ( age "$ NiceFloat(ageInDays) $"d + tweaks "$ NiceFloat(flowTweak) $" + "$ NiceFloat(playerTweak) $" + "$ NiceFloat(ratingTweak) $" ) / playerDiff "$ NiceFloat(playerDiff));
	}
	return result;
}

// function bool ExistsOnDisk(String mapName) {
	// return ScanMaps(mapName);
// }

function String ChooseNextMap() {
	local String bestMap;
	local float bestScore;
	local int i,currentNumPlayers;
	local float mapScore;
	// DebugLog("CountActors(UTServerAdmin) = "$CountActors(class'UTServerAdmin'));
	// DebugLog("CountActors(PlayerPawn) = "$CountActors(class'PlayerPawn'));
	if (!bMapScanDone) {
		if (bDoMapScan) {
			DebugLog("ChooseNextMap(): Scanning maps for "$Level.Game.Default.MapPrefix$" ...");
			ScanMaps();
			bDoMapScan=False;
			SaveConfig(); // I guess this could be optional, but it would slow down any subsequent boot if we haven't saved :P
		} else {
			DebugLog("NOT scanning maps until you set MapMuts.MapStats bDoMapScan True");
		}
		bMapScanDone = True;
	}
	ConsideredMaps="";
	currentNumPlayers = CountPlayers();
	if (currentNumPlayers == 0) {
		bCanChooseUnsizedMaps = True;
		currentNumPlayers = (ServerMaxPlayers+1)*FRand();
	}
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].PreferredPlayers > 0 || (bCanChooseUnsizedMaps && MapStats[i].MapName!="")) {
			mapScore = ScoreForNextMap(i,currentNumPlayers);
			if (bestMap == "" || mapScore > bestScore) {
				if (MapStats[i].bDisabled) // && !bCanChooseUnsizedMaps)
					continue;
				if (StrContains(" "$RejectedMaps$" "," "$MapStats[i].MapName$" ")) {
					continue;
				}
				if (!MapStats[i].bOnDisk) {
					if (bDebugLogging && FRand()<0.01) {
						DebugLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because server no longer has it!");
					}
					// MapStats[i].bCrashes = True;
					continue;
				}
				if (MapStats[i].bCrashes) {
					#define bRetryCrashedMaps True
					if (bRetryCrashedMaps && FRand()<0.01) {
						NormalLog("ChooseNextMap(): "$ MapStats[i].MapName $" previously crashed but considering it, to see if it has been fixed.");
					} else {
						// Too frequent here, but get reported occasionally above: NormalLog("ChooseNextMap(): Skipping "$ MapStats[i].MapName $" because it crashes!");
						continue;
					}
				}
				if ( bStickWithCurrentMode && !( StrBefore(MapStats[i].MapName,"-") ~= StrBefore(currentMap.MapName,"-") ) ) {
					// Prefix does not match current map, rejecting.
					continue;
					// TODO: Otherwise if we do select a map with a different gametype/prefix, we should also change gametype when we switch level!
				}
				// This is our new best map!
				// if (bestMap!="" && FRand()>0.2) {
				if (bestMap!="") {
					// ConsideredMaps = ConsideredMaps $ bestMap $"("$Left(String(mapScore),5)$")"$ " ";
					ConsideredMaps = ConsideredMaps $ bestMap $"("$ NiceAge(DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $","$Left(String(MapRecord(bestMap).PreferredPlayers),4)$")"$ " ";
					if (Len(ConsideredMaps)>60)
						ConsideredMaps = StrAfterFirst(ConsideredMaps," ");
					// NormalLog("Dropped: "$bestMap$" (score "$ NiceFloat(bestScore) $", age "$ NiceAge(DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $")");
					NormalLog("Considering: "$MapStats[i].MapName$" (score "$ NiceFloat(mapScore) $", age "$ NiceAge(DaysSince1970() - MapStats[i].DateLastPlayed) $", players "$ NiceFloat(MapStats[i].PreferredPlayers) $")");
				}
				bestMap = MapStats[i].MapName;
				bestScore = mapScore;
			}
		}
	}
	NormalLog("Best map was "$ bestMap $" with score "$ NiceFloat(bestScore) $" (age "$ NiceAge(DaysSince1970() - MapRecord(bestMap).DateLastPlayed) $")");
	NormalLog("Current players = "$ currentNumPlayers $", map's PreferredPlayers = "$ NiceFloat(MapRecord(bestMap).PreferredPlayers) $".");
	NormalLog("Other considered maps were: "$ ConsideredMaps);
	return bestMap;
}

/*
function Actor GetAny(class<Actor> type) {
	local Actor A;
	foreach AllActors(type, A) {
		return A;
	}
	return None;
}
*/

function int CountActors(class<Actor> type) {
	local Actor A;
	// local Actor lA;
	local int c;
	foreach AllActors(type, A) {
		c++;
		// lA=A;
	}
	// DebugLog("CountActors("$type$") = "$c$" [first="$GetAny(type)$" last="$lA$"]");
	if (bDebugLogging && type != class'PlayerPawn' && type != class'Spectator') { DebugLog("CountActors("$type$") = "$c); }
	return c;
}

#ifdef CATCH_LEVEL_SWITCH
event Tick(float DeltaTime) {

	if (!bInterceptTravel) return;

	// bInterceptTravel = False;

	// check for levelchange
	if (Level.NextURL != "") {
		// NextMap = left(Level.NextURL, instr(Level.NextURL,"."));
		// if (NextMap == "") return;  // maybe a ?restart, Serverpackages remain
		NormalLog("Tick() intercepted LevelChange to: "$ Level.NextURL);
		// NextMap = ChooseNextMap(); // Should be already chosen!
		if (NextMap == "")
			NextMap = ChooseNextMap();
		NormalLog("Tick() is attempting to force: "$NextMap);
		Level.NextURL = NextMap;
		// TODO CONSIDER: Level.ProcessServerTravel(...);
		bInterceptTravel = False;
	}
}
#endif

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCollectDamage) {
		if (Victim!=None && Victim.PlayerReplicationInfo!=None && InstigatedBy!=None && InstigatedBy.PlayerReplicationInfo!=None && (Victim.PlayerReplicationInfo.Team != InstigatedBy.PlayerReplicationInfo.Team || TeamGame(Level.Game)==None)) {
			currentMap.Damage += ActualDamage;
		}
	}
	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);
}

function bool ScanMaps(optional String search) {
	local string FirstMap, NextMap, TestMap, MapName;
	local int availableCount,crashCount,missingCount,unknownCount;
	local int count,i;
	local String prefix;
	// prefix = Botmatch.Parent.Default.MapPrefix;
	// prefix = Botpack.CTFGame.Default.MapPrefix;
	// NormalLog("ScanMaps(): Starting new scan...");
	// NormalLog("Iterate maps running...");
	local int blocked;

	count = 0;
	// Reset bOnDisk info, because we are about to regenerate it:
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "") {
			if (MapStats[i].bOnDisk == False) {
				missingCount++;
			}
			MapStats[i].bOnDisk = False;
			count++;
			if (i<MaxData-1 && MapStats[i+1].MapName != "") {
				blocked++;
			}
		}
	}
	NormalLog("ScanMaps() Total maps in database: "$count$" with "$ 100*blocked/count $"% congestion.");

	prefix = Level.Game.Default.MapPrefix;
	FirstMap = GetMapName(prefix, "", 0);
	NextMap = FirstMap;
	count = 0;
	while (!(FirstMap ~= TestMap)) {
		if( ! ( Left(NextMap,Len(NextMap)-4) ~= (prefix$"-tutorial") ) ) {
			// Add the map.

			// DebugLog("ScanMaps(): "$NextMap);
			count++; // maybe don't count if crashed?
			if (StrEndsWith(NextMap,".unr")) {
				MapName = StrBeforeLast(NextMap,".unr");
			} else {
				MapName = NextMap;
			}

			// Ensure a record exists for the map:
			// MapIndex(MapName);
			// MapStats[MapIndex(MapName)].bOnDisk = True;
			MapRecord(MapName).bOnDisk = True;

			if (MapRecord(MapName).bCrashes) {
				crashCount++;
			} else {
				availableCount++;
				if (MapRecord(MapName).PreferredPlayers==0)
					unknownCount++;
			}

			if (search != "") {
				if (MapName ~= search) {
					return True;
				}
			}

		}
		// Get the map.
		NextMap = GetMapName(prefix, NextMap, 1);
		// Text to see if this is the last.
		TestMap = NextMap;
	}
	// Broadcast because: it should never happen during play, so if it does, we want to know about it!
	BroadcastMessage("MapStats found "$ availableCount $" available "$ prefix $" maps.");
	NormalLog("ScanMaps() Found "$ availableCount $" available "$ prefix $" maps out of "$ count $" known, where "$ crashCount $" crash, "$ missingCount $" are missing, and "$ unknownCount $" have unknown size.");
	return False;
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	local bool hideMessage;
	hideMessage = False;
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.

		#ifdef MAP_RATING
		if (Caps(Msg)=="GOOD MAP") { // CONSIDER: nice map, great map
			if (StrContains(currentMap.RatedUpBy,Sender.getHumanName()$" ")) {
				PlayerPawn(Sender).ClientMessage("You have ALREADY rated this map up!");
			} else {
				currentMap.GoodVotes++;
				PlayerPawn(Sender).ClientMessage("You have rated this map +1");
				BroadcastAndLog("Current rating for "$ currentMap.MapName $" is +"$ currentMap.GoodVotes $" up -"$ currentMap.BadVotes $" down.");
				currentMap.RatedUpBy = currentMap.RatedUpBy $ Sender.getHumanName() $ " ";
			}
			SaveConfig();
		}
		if (Caps(Msg)=="BAD MAP") { // CONSIDER: crap map, shit map
			if (StrContains(currentMap.RatedDownBy,Sender.getHumanName()$" ")) {
				PlayerPawn(Sender).ClientMessage("You have ALREADY rated this map down!");
			} else {
				currentMap.BadVotes++;
				PlayerPawn(Sender).ClientMessage("You have rated this map -1");
				BroadcastAndLog("Current rating for "$ currentMap.MapName $" is +"$ currentMap.GoodVotes $" up -"$ currentMap.BadVotes $" down.");
				currentMap.RatedDownBy = currentMap.RatedDownBy $ Sender.getHumanName() $ " ";
			}
			SaveConfig();
		}
		#endif

		#ifdef MAP_TAGS
		if (Left(Msg,8)~="!tagmap ") {
			AddTags(Right(Msg,8));
			SaveConfig();
		}
		#endif

		#ifdef PLAYERS_CAN_VETO
		// if (StrStartsWith(Msg,"!")) {
			// hideMessage = CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		// }
		// if (Level.Game.bGameEnded && bEndGameSwitchMap) {
		if (NextMap != "") {
			if (Msg ~= "NO" || Msg ~= "!NO") {
				NoCount++; // TODO BUG: can't 1 player just say NO twice and override MinimumNosForVeto?  At least UT chat will usually limit that to some extent.
				if (NoCount >= MinimumNosForVeto) {
					NoCount = 0;
					RejectedMaps = RejectedMaps $ " " $ NextMap;
					NextMap = ChooseNextMap();
					BroadcastAndLog("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
				}
			}
		}
		// }
		#endif

	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage /* || !bSwallowSpokenCommands */ );
}

// Catch mutate messages:
function Mutate(String str, PlayerPawn Sender) {
	local PlayerPawn p;
	if (bAllowMutateSwitch) {
		if (str~="suggest") {
			// Current NextMap is discarded
			// In fact, current NextMap is vetoed:
			if (NextMap != "")
				RejectedMaps = RejectedMaps $ " " $ NextMap;
			NextMap = ChooseNextMap();
			Sender.ClientMessage("Next map will be: "$ NextMap $" (last "$ NiceAge(DaysSince1970() - MapRecord(NextMap).DateLastPlayed) $" ago) [Beaten: "$ConsideredMaps$"]");
			// BroadcastMessage("Next map will be "$NextMap);
		}
		if (
			(str~="nextmap" && (Sender.bAdmin || CountPlayers()==1))
			|| str ~= "nextmap..." || str ~= "next..." // TODO WARNING BUG: This little backdoor allows any player to force a mapswitch, but I am currently using it for TESTING.
			// || str ~= "nextmap "$Level.Game.AdminPassword
		) {
			// if (Level.Game.bGameEnded) {
			if (FRand()<0.25) {
				DoLevelSwitch();
			}
			// Level.Game.bGameEnded = (FRand()<0.3);
			// if (Level.Game.bGameEnded) {
				// foreach AllActors(class'PlayerPawn',p) {
					// p.PreClientTravel(); // We need this when doing Level.ServerTravel()!  Otherwise clients get "Connection failed" when server switches map.
					// // p.ClientTravel("?reconnect", TRAVEL_Relative, False);
				// }
			// }
			if (NextMap=="")
				NextMap = ChooseNextMap();
			// Sender.ClientMessage("Repeat call to switch map to "$ NextMap $" (state= "$ Level.Game.bGameEnded $")");
			Sender.ClientMessage("Repeat call to switch map to "$ NextMap $"");
		}
		if (
			(str~="scanmaps" && (Sender.bAdmin || CountPlayers()==1))
			|| str ~= "scanmaps..."
		) {
			bDoMapScan=True;
			bMapScanDone=False;
			ScanMaps();
		}
		if (str~="help") {
			Sender.ClientMessage("MapStats mutate commands: help | suggest | nextmap | scanmaps | list <part_of_mapname>");
			Sender.ClientMessage("MapStats say commands: good map | bad map | !tagmap <tag1,tag2,...>");
		}
		if (StrStartsWith(Caps(str),"LIST ") || StrStartsWith(Caps(Str),"LISTMAPS")) { // aka SHOWINFO
			if (StrContains(str," ")) {
				ListMapsTo(Sender,StrAfterFirst(str," "));
			} else {
				ListMapsTo(Sender,"");
			}
		}
		#ifdef LIST_RECENTLY_PLAYED
		if (str~="LISTRECENT" || str~="LASTMAPS") {
			BroadcastAndLog("Recently played maps: "$ RecentlyPlayedMaps);
		}
		#endif
	}
	// CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

function ListMapsTo(PlayerPawn p, String str) {
	local int i;
	local bool hit;
	str = Caps(str);
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].MapName != "" && StrContains(Caps(MapStats[i].MapName),str)) {
			#ifdef MAP_TAGS
			p.ClientMessage("["$i$"] "$MapStats[i].MapName$" playcount="$((MapStats[i].GamesStarted+MapStats[i].GamesEnded)/2)$" prefplayers="$Left(""$MapStats[i].PreferredPlayers,4)$" +"$MapStats[i].GoodVotes$" -"$MapStats[i].BadVotes$" tags="$MapStats[i].Tags);
			#else
			p.ClientMessage("["$i$"] "$MapStats[i].MapName$" playcount="$((MapStats[i].GamesStarted+MapStats[i].GamesEnded)/2)$" prefplayers="$Left(""$MapStats[i].PreferredPlayers,4)$" +"$MapStats[i].GoodVotes$" -"$MapStats[i].BadVotes$"");
			#endif
			hit = true;
		}
	}
	if (hit == false) {
		p.ClientMessage("I could not find any map matching "$Locs(str)$" - use mutate scanmaps to rescan at next mapswitch.");
	}
}

#ifdef MAP_TAGS
function AddTags(String tags) {
	currentMap.Tags = currentMap.Tags $ tags $ ",";
	// done outside atm: SaveConfig();
}
#endif

/*
// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local Actor A;
	local String result;
	local int i,j;
	local String squishedName;
	local String url;
	local String rebuilt_string; // CONSIDER: instead of rebuilding the string, we could just use StrAfter(line," ") one or more times.
	local String command;
	// local PlayerSettings ps;
	local String stateStr;

	if (bOnlyAdmin && !Sender.bAdmin) {
		return False;
	}

	// ps = GetPlayerSettingsFor(Sender);
	#define ps GetPlayerSettingsFor(Sender)

	// NormalLog("ActorEditor.CheckMessage() ("$Sender$"): "$Msg$"");
	argcount = SplitString(line," ",args);

	command = args[0];

	if (command ~= "flash") {
		ps.bFlash = !ps.bFlash;
		stateStr = "off";
		if (ps.bFlash)
			stateStr = "on";
		// if (ps.bFlash)
		FlashMessageToPlayer(Sender,"damage flash = "$stateStr,InfoColor,0,2,true);
		// else Sender.ClearProgressMessages();
		Sender.ClientMessage("Your damage flash is "$stateStr);
		return True;
	}

	if (command ~= "damage") {
		ps.bSeeDamageGiven = !ps.bSeeDamageGiven;
		stateStr = "off";
		if (ps.bSeeDamageGiven)
			stateStr = "on";
		Sender.ClientMessage("Your showdamage is "$stateStr);
		// if (ps.bFlash) 
		FlashMessageToPlayer(Sender,"show damage = "$stateStr,SentPainColor,1,2,True);
		return True;
	}

	if (command ~= "pain" || command ~="mydamage") {
		ps.bSeeDamageReceived = !ps.bSeeDamageReceived;
		stateStr = "off";
		if (ps.bSeeDamageReceived)
			stateStr = "on";
		Sender.ClientMessage("Your show pain is "$stateStr);
		FlashMessageToPlayer(Sender,"show pain = "$stateStr,ReceivedPainColor,7,2,True);
		return True;
	}

	if (command ~= "alldamage") {
		ps.bSeeAllDamage = !ps.bSeeAllDamage;
		stateStr = "off";
		if (ps.bSeeAllDamage)
			stateStr = "on";
		Sender.ClientMessage("show alldamage = "$stateStr);
		FlashMessageToPlayer(Sender,"Your show all damage is "$stateStr,InfoColor,3,2,True);
		return True;
	}

	if (command ~= "HELP") {
		Sender.ClientMessage("TrackDamage commands: flash damage pain alldamage");
		return True;
	}

	return False;

}

function FlashMessageToPlayer(PlayerPawn p, string Msg, Color msgColor, optional int linenum, optional int duration, optional bool bAdditional, optional bool bBeep) {
	if (linenum == 0)
		linenum = 4;
	if (duration == 0)
		duration = 2;
	if (!bAdditional)
		p.ClearProgressMessages();
	p.SetProgressTime(duration);
	p.SetProgressColor(msgColor,linenum);
	p.SetProgressMessage(Msg,linenum);
	if (bBeep)
		p.PlaySound(sound'Beep', SLOT_Interface, 2.5, False, 32, 32);
}
*/

// #include "../../JLib/findactor.uc.jpp"

#include "../../JLib/jlib.uc.jpp"

