// vim: tabstop=2 shiftwidth=2 noexpandtab filetype=uc

#define MaxData 3000

class MapStats expands Mutator config(MapStats);

var config bool bLogging;
var config bool bAutoSwitchMap;

struct MapInfo {
	var String MapName;
	var float PreferredPlayers;
	var String PreferredPlayersSource;
	var int TotalGamesStarted;
	var int TotalGamesEnded;
	var int TotalDeaths;
	var float TotalHoursPlayed;
	var float TotalDamageDone;
	var int NumberOfSpawnPoints;
	var int NumberOfWeaponPickups;
	var int NumberOfPathNodes;
	var float DateLastPlayed;
	var float AverageFlow;
	var float AverageNumPlayers;
	var float AverageActorDistance;
};

var config MapInfo MapStats[MaxData];

var String mapName; // Current map's name, generated at start.
var int mapI; // Current map's index, generated at start.

var float StartTime;
var int PlayerCountAtStart;
var bool bDoneGameEnd;
var bool bExpectSwitch;

var String ConsideredMaps;

defaultproperties {
bLogging=True
bAutoSwitchMap=False
}

#define MyLog(X); if (bLogging) DebugLog(X); 
// #define MyLog(X); DebugLog(X);
// function DebugLog(String y) {
	// if (bLogging) { Log(y); }
// }

#define CountPlayers() ( CountActors(class'PlayerPawn') - CountActors(class'Spectator') )

#define AverageActorDistance() AverageActorDistanceType(class'PlayerStart')

function float AverageActorDistanceType(class<Actor> type) {
	local Actor A,B;
	local float totalDistance;
	local int totalCount,realTotalCount;
	local float distance;
	totalCount=0;
	foreach AllActors(type, A) {
		totalCount++;
	}
	realTotalCount=0;
	totalDistance=0;
	foreach AllActors(type, A) {
		if (FRand()<16/totalCount) {
			foreach AllActors(type, B) {
				if (FRand()<16/totalCount) {
					distance = VSize(A.Location-B.Location);
					totalDistance += distance*distance;
					realTotalCount++;
				}
			}
		}
	}
	totalDistance = totalDistance / realTotalCount;
	return Sqrt(totalDistance); // this is actually average squared-distance, we should square-root it.
}

function int HashStr(String str, optional int max) {
	local int hash;
	local int ch;
	local int i;
	if (max == 0) max = 256;
	for (i=0;i<Len(str);i++) {
		ch = Asc(Mid(str,i,1));
		hash += ch;
		while (hash > max) {
			hash -= max;
		}
		while (hash < 0) {
			hash += max;
		}
	}
	return hash;
}

function float DaysSince1970() {
	return Level.Year*365.25 + Level.Month*30.0 + Level.Day + Level.Hour/24.0 + Level.Minute/24.0/60.0 + Level.Second/24.0/60.0/60.0;
}

function int MapIndex(String mapName) {
	local int i;
	i = HashStr(mapName,MaxData);
	while (true) {
		if (MapStats[i].MapName == "") { // empty
			MapStats[i].MapName = mapName;
			return i;
		}
		if (MapStats[i].MapName == mapName) { // hit
			return i;
		}
		// collision, try next slot
		i++;
		if (i>=MaxData) {
			MyLog("MapStats.MapIndex("$mapName$"): hash + collision offset = "$i$" - we are either full or unlucky; returning i=0");
			return 0;
		}
	}
	// never reached: return 0;
}

#define MapRecord(X) MapStats[MapIndex(X)]

function PostBeginPlay() {

	mapName = StrBeforeFirst(""$Self,".");
	mapI = MapIndex(mapName);

	Level.Game.RegisterDamageMutator(Self);

	// TODO:
	// If we were not added as a mutator, but run in some other way (e.g. as a ServerActor), then we need to register as a mutator:
   // Level.Game.BaseMutator.AddMutator(Self);

	// Register to receive spoken messages in MutatorTeamMessage() below:
	// Level.Game.RegisterMessageMutator(Self);

	DoStart();

	SetTimer(5.0,True);

}

function DoStart() {
	// This is actually done when the map is loaded.
	// The game starts when a player joins - see ModifyPlayer().
	local String idealPlayerCount,gotNum,restStr;
	local int count;
	local float avg,num;

	MapStats[mapI].TotalGamesStarted++;
	MapStats[mapI].DateLastPlayed = DaysSince1970();
	MapStats[mapI].AverageActorDistance = AverageActorDistance();
	MapStats[mapI].NumberOfSpawnPoints = CountActors(class'PlayerStart');
	MapStats[mapI].NumberOfWeaponPickups = CountActors(class'Weapon');
	MapStats[mapI].NumberOfPathNodes = CountActors(class'PathNode');

	idealPlayerCount = Level.IdealPlayerCount;
	restStr = idealPlayerCount;
	avg = 0.0;
	count = 0;
	do {
		gotNum = StrFilterNum(restStr,restStr);
		if (gotNum!="") {
			num = Float(gotNum);
			// MyLog("MapStats: Got "$num$" from \""$gotNum$"\" with rest="$restStr);
			if (num>0) {
				avg = (count*avg + num) / (count+1);
				count++;
			}
			if (StrStartsWith(restStr,"-"))
				restStr = Mid(restStr,1);
		}
	} until (gotNum == "");
	if ( count>0 && ( MapStats[mapI].PreferredPlayersSource=="" || StrStartsWith(MapStats[mapI].PreferredPlayersSource,"Level.") ) ) {
		MyLog("MapStats.DoStart(): Got idealPlayerCount "$avg$" from \""$idealPlayerCount$"\".");
		if (avg>20) avg=20;
		MapStats[mapI].PreferredPlayers = avg;
		MapStats[mapI].PreferredPlayersSource = "Ideal="$ avg $"("$ idealPlayerCount $")";
		if (MapStats[mapI].NumberOfSpawnPoints > 0) {
			MapStats[mapI].PreferredPlayers = avg*0.75 + MapStats[mapI].NumberOfSpawnPoints*0.25;
			MapStats[mapI].PreferredPlayersSource = MapStats[mapI].PreferredPlayersSource $ " PlayerStarts="$ MapStats[mapI].NumberOfSpawnPoints;
			MyLog("MapStats.DoStart(): "$ MapStats[mapI].PreferredPlayersSource $" PreferredPlayers="$ MapStats[mapI].PreferredPlayers $".");
		}
	}
	if (count == 0 && MapStats[mapI].PreferredPlayers == 0) {
		MapStats[mapI].PreferredPlayers = MapStats[mapI].NumberOfSpawnPoints;
	}

	// MyLog("MapStats.DoStart(): Saving "$ MapStats[mapI]);
	SaveConfig();

}

function ModifyPlayer(Pawn Other) {
	if (PlayerPawn(Other) != None) {
		if (Other.PlayerReplicationInfo.Deaths == 0) {
			if (StartTime == 0) {
				// First ever spawn
				StartTime = Level.TimeSeconds;
				PlayerCountAtStart = CountPlayers();
			}
		} else {
			// A frag / someone died
			MapStats[mapI].TotalDeaths++;
		}
	}
	Super.ModifyPlayer(Other);
}

event Timer() {
	local string NextMap;
	if (CountActors(class'PlayerPawn')==CountActors(class'UTServerAdminSpectator') && FRand() < 0.1) Level.Game.bGameEnded = True;
	if (Level.Game.bGameEnded && !bDoneGameEnd) {
		DoEnd();
		bDoneGameEnd = True;
		if (bAutoSwitchMap) {
			BroadcastMessage("Considered maps: "$ConsideredMaps);
			BroadcastMessage("Switching to "$ ChooseNextMap() $" in 10 seconds.");
			SetTimer(10,False);
		}
		return;
	}
	if (Level.Game.bGameEnded && bDoneGameEnd && bAutoSwitchMap) {
		BroadcastMessage("Considered maps: "$ConsideredMaps);
		BroadcastMessage("Switching to "$ ChooseNextMap() $" now.");
		bExpectSwitch = True;
		// Enable('Tick');
		// Level.NextURL = ChooseNextMap();
		NextMap = ChooseNextMap();
		if (!StrEndsWith(Caps(NextMap),".UNR"))
			NextMap = NextMap $ ".unr";
		// UTServerAdmin(GetAny(class'UTServerAdmin')).ConsoleCommand("admin servertravel "$ ChooseNextMap() );
		Level.Game.ProcessServerTravel(NextMap,false);
		// bDoneGameEnd = False;
		// MyLog("Maps: "$Maps);
	}
}

function DoEnd() {
	local float playerChangeThisMap,averageNumPlayersThisMap;
	local float totalHours,deltaHours,newTotalHours;

	MapStats[mapI].TotalGamesEnded++;
	MapStats[mapI].DateLastPlayed = DaysSince1970();

	totalHours = MapStats[mapI].TotalHoursPlayed;
	deltaHours = (Level.TimeSeconds - StartTime) / 60.0 / 60.0;
	newTotalHours = MapStats[mapI].TotalHoursPlayed + deltaHours;

	playerChangeThisMap = CountPlayers() - PlayerCountAtStart;
	MapStats[mapI].AverageFlow = (totalHours*MapStats[mapI].AverageFlow + deltaHours*playerChangeThisMap) / newTotalHours;

	averageNumPlayersThisMap = (CountPlayers() + PlayerCountAtStart) / 2.0;
	MapStats[mapI].AverageNumPlayers = (totalHours*MapStats[mapI].AverageNumPlayers + deltaHours*averageNumPlayersThisMap) / newTotalHours;

	MapStats[mapI].TotalHoursPlayed = newTotalHours;

	SaveConfig();
}

function float ScoreForNextMap(int nextI, int currentNumPlayers) {
	local float age, playerDiff;
	age = DaysSince1970() - MapStats[nextI].DateLastPlayed;
	playerDiff = Abs(currentNumPlayers - MapStats[nextI].PreferredPlayers);
	return (age+0.25) / (playerDiff+1);
}

function bool ExistsOnDisk(String mapName) {
	return true;
}

function String ChooseNextMap() {
	local String bestMap;
	local float bestScore;
	local int i,currentNumPlayers;
	local float mapScore;
	// MyLog("CountActors(UTServerAdmin) = "$CountActors(class'UTServerAdmin'));
	// MyLog("CountActors(PlayerPawn) = "$CountActors(class'PlayerPawn'));
	ConsideredMaps="";
	currentNumPlayers = CountActors(class'PlayerPawn'); // TODO: should be - spectators :E
	for (i=0;i<MaxData;i++) {
		if (MapStats[i].PreferredPlayers > 0) {
			mapScore = ScoreForNextMap(i,currentNumPlayers);
			if (bestMap == "" || mapScore > bestScore && ExistsOnDisk(MapStats[i].MapName)) {
				MyLog("MapStats.ChooseNextMap(): "$MapStats[i].MapName$" with score "$mapScore$" beats "$bestMap$" with score "$bestScore);
				bestMap = MapStats[i].MapName;
				bestScore = mapScore;
				if (i>MaxData/4 && FRand()>0.5) ConsideredMaps = ConsideredMaps $ bestMap $" ";
			}
		}
	}
	MyLog("MapStats.ChooseNextMap(): Best map was "$bestMap$" with score "$bestScore);
	return bestMap;
}

function Actor GetAny(class<Actor> type) {
	local Actor A;
	foreach AllActors(type, A) {
		return A;
	}
	return None;
}

function int CountActors(class<Actor> type) {
	local Actor A;
	// local Actor lA;
	local int c;
	foreach AllActors(type, A) {
		c++;
		// lA=A;
	}
	// MyLog(Self$".CountActors("$type$") "$c$" first="$GetAny(type)$" last="$lA);
	return c;
}

function Mutate(String str, PlayerPawn Sender) {
	if (str ~= "nextmap") {
		Level.Game.bGameEnded = True; // bDoneGameEnd = True;
		Sender.ClientMessage("MapStats has set bGameEnded=True, will probably switch to "$ ChooseNextMap());
	}
	// CheckMessage(str, Sender);
	Super.Mutate(str, Sender);
}

event Tick(float DeltaTime) {
	local string NextMap;

	if (!bExpectSwitch) return;

	// bExpectSwitch = False;

	// check for levelchange
	if (Level.NextURL != "") {
		// NextMap = left(Level.NextURL, instr(Level.NextURL,"."));
		// if (NextMap == "") return;  // maybe a ?restart, Serverpackages remain
		NextMap = ChooseNextMap();
		MyLog("Tick intercepted LevelChange to: "$ Level.NextURL);
		MyLog("Tick is forcing: "$NextMap);
		Level.NextURL = NextMap;
		// TODO CONSIDER: Level.ProcessServerTravel(...);
		bExpectSwitch = False;
	}
}

// Catch messages from players:
/*
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	local bool hideMessage;
	hideMessage = False;
	if (Sender == Receiver && Sender.IsA('PlayerPawn')) { // Only process each message once.
		if (StrStartsWith(Msg,"!")) {
			hideMessage = CheckMessage(Mid(Msg,1), PlayerPawn(Sender));
		}
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep) && (!hideMessage || !bSwallowSpokenCommands);
}

// Returns True if the command was recognised (and therefore the player's message could optionally be swallowed).
function bool CheckMessage(String line, PlayerPawn Sender) {
	local int argCount;
	local String args[256];
	local Actor A;
	local String result;
	local int i,j;
	local String squishedName;
	local String url;
	local String rebuilt_string; // CONSIDER: instead of rebuilding the string, we could just use StrAfter(line," ") one or more times.
	local String command;
	// local PlayerSettings ps;
	local String stateStr;

	if (bOnlyAdmin && !Sender.bAdmin) {
		return False;
	}

	// ps = GetPlayerSettingsFor(Sender);
	#define ps GetPlayerSettingsFor(Sender)

	// MyLog("ActorEditor.CheckMessage() ("$Sender$"): "$Msg$"");
	argcount = SplitString(line," ",args);

	command = args[0];

	if (command ~= "flash") {
		ps.bFlash = !ps.bFlash;
		stateStr = "off";
		if (ps.bFlash)
			stateStr = "on";
		// if (ps.bFlash)
		FlashMessageToPlayer(Sender,"damage flash = "$stateStr,InfoColor,0,2,true);
		// else Sender.ClearProgressMessages();
		Sender.ClientMessage("Your damage flash is "$stateStr);
		return True;
	}

	if (command ~= "damage") {
		ps.bSeeDamageGiven = !ps.bSeeDamageGiven;
		stateStr = "off";
		if (ps.bSeeDamageGiven)
			stateStr = "on";
		Sender.ClientMessage("Your showdamage is "$stateStr);
		// if (ps.bFlash) 
		FlashMessageToPlayer(Sender,"show damage = "$stateStr,SentPainColor,1,2,True);
		return True;
	}

	if (command ~= "pain" || command ~="mydamage") {
		ps.bSeeDamageReceived = !ps.bSeeDamageReceived;
		stateStr = "off";
		if (ps.bSeeDamageReceived)
			stateStr = "on";
		Sender.ClientMessage("Your show pain is "$stateStr);
		FlashMessageToPlayer(Sender,"show pain = "$stateStr,ReceivedPainColor,7,2,True);
		return True;
	}

	if (command ~= "alldamage") {
		ps.bSeeAllDamage = !ps.bSeeAllDamage;
		stateStr = "off";
		if (ps.bSeeAllDamage)
			stateStr = "on";
		Sender.ClientMessage("show alldamage = "$stateStr);
		FlashMessageToPlayer(Sender,"Your show all damage is "$stateStr,InfoColor,3,2,True);
		return True;
	}

	if (command ~= "HELP") {
		Sender.ClientMessage("TrackDamage commands: flash damage pain alldamage");
		return True;
	}

	return False;

}

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	local PlayerSettings instigatorSettings;
	local PlayerSettings victimSettings;
	local PlayerPawn pl;
	local String boost;
	local String actualDamageStr;

	Super.MutatorTakeDamage(ActualDamage,Victim,InstigatedBy,HitLocation,Momentum,DamageType);

	if (Victim.PlayerReplicationInfo.Team != InstigatedBy.PlayerReplicationInfo.Team) {
		MapStats[mapI].TotalDamageDone += ActualDamage;
	}

}

function FlashMessageToPlayer(PlayerPawn p, string Msg, Color msgColor, optional int linenum, optional int duration, optional bool bAdditional, optional bool bBeep) {
	if (linenum == 0)
		linenum = 4;
	if (duration == 0)
		duration = 2;
	if (!bAdditional)
		p.ClearProgressMessages();
	p.SetProgressTime(duration);
	p.SetProgressColor(msgColor,linenum);
	p.SetProgressMessage(Msg,linenum);
	if (bBeep)
		p.PlaySound(sound'Beep', SLOT_Interface, 2.5, False, 32, 32);
}
*/

// #include "../../JLib/findactor.uc.jpp"

#include "../../JLib/jlib.uc.jpp"

