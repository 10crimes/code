#define LIST_ACTORS
// #define NO_CHANGE_ANGLE

// CONSIDER: Could continue to watch the first Corpse spawned after the player we are viewing dies (before/after they respawn).

#define DEBUG(X); if (bPrintDebugInfo) { P.ClientMessage(X); }

//================================================================================
// nBAutoSpectate.
//================================================================================

// CameraMode Camera modes:
// 0 - default following ViewTarget, auto-panning
// 1 * custom following FollowActor
// 2 - free standing camera, looking at FollowActor
// 3 * floating camera, panning / looking at centre of mass)
// 4 * custom following FollowActor, but looking at LookActor
// 5 - default following ViewTarget, but looking at LookActor
//
// * = camera floats towards a target

// For AutoTeamBalance COOL_CAMERA, consider not moving the camera, but rotating it so that the powerup appears in the middle, halfway through the shot.

// class nBAutoSpectate extends Info;
class nBAutoSpectate extends Mutator;

var PlayerPawn P;
var Rotator targRot;
var Rotator myRot;
var Rotator prevRot;
var bool bfoundflag;
var bool bviewingFC;
var string blueFC;
var string redFC;
var bool bautoFC;
var bool bAFCOFFmsg;
var bool bAFCONmsg;
// var private bool ;
// var private int ;
// var private int ;
var int ydelta;
var int pdelta;
// var private int ;
// var private int ;
var int Offset;

// nB:
var config bool bPrintDebugInfo;
var config bool bCameraPanning;
var config bool bSwitchCamera;
var config float CameraSwitchSeconds;
var config bool bStickWithFC;

// var String LastList;
var Actor LastNewActor;

var float LastSwitchTime;
var float deltaYaw, deltaPitch, deltaFOV, fov;
var Actor FollowActor, LookActor;

var bool bCheckingForInterestingTarget;

var int CameraMode;

var String RecommendedPlayerName;

function int fun1 (int X, int Y, out int diff) {
	local int newdiff;

	diff = X - Y;
	newdiff = diff;
	if ( (newdiff > 20000) || (newdiff < -20000) )
	{
		newdiff = 20000;
	}
	return newdiff * newdiff / 500000;
}

function PlayerPawn GetRandomPlayer() {
	local PlayerPawn p;
	local int count;
	foreach AllActors(class'PlayerPawn',p)
		count++;
	count = count * FRand();
	foreach AllActors(class'PlayerPawn',p) {
		count--;
		if (count < 0)
			return p;
	}
	return p;
}

function bool isInteresting(Actor a) {
	if (a.IsA('Spectator'))
		return false;
	return (
		// a.IsA('FlagBase')
		// a.IsA('CTFFlag') ||
		// a.IsA('Flag')
		// || (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
		// || (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
		// || a.IsA('HealthPack')
		// a.IsA('Projectile')
		isAGoodProjectile(A)
		|| a.IsA('PlayerPawn')
		|| a.IsA('Bot')
		// || a.IsA('Pawn')
		|| (a.IsA('Weapon') && Inventory(a).bTossedOut)
		// || a.IsA('NavigationPoint')
		|| a.IsA('Effect')
		// || a.IsA('Carcass')
	);
}

function int CountInterestingActors() {
	local int count;
	local Actor a;
	#ifdef LIST_ACTORS
	local String list;
	#endif
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			count++;
			#ifdef LIST_ACTORS
			list = list $ a.Name $ " ";
			#endif
		}
	}
	#ifdef LIST_ACTORS
	// if (count < 10)
		// DEBUG(count$" actors: "$list);
	// else
		// DEBUG(count$" actors.");
	#endif
	return count;
}

function Actor GetRandomActor() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (isFC(a) && FRand()<0.5) {
			return a;
		}
	}

	if (RecommendedPlayerName != "" && FRand()<0.5) {
		foreach AllActors(class'Actor',a) {
			if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
				DEBUG("Re-using "$NameActor(a));
				return a;
			}
		}
		RecommendedPlayerName = ""; // it failed me now, and we don't want it to last forever
	}

	count = CountInterestingActors();
	chosen = count*FRand();
	// Log("Chose "$chosen$" / "$count);
	// DEBUG("Chose "$Int(count*FRand())$" / "$count);
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			chosen--;
			if (chosen < 0)
				return a;
		}
	}
	return a;
}

function bool isFC(Actor a) {
	return ( ( a != None ) &&
		( Pawn(a) != None ) &&
		( Pawn(a).PlayerReplicationInfo != None ) &&
		( Pawn(a).PlayerReplicationInfo.HasFlag != None )
	);
}

// TODO: To get the most action, find a "busy" Actor to view.
// one e.g.: find average location of all pawns; find actor closest to this, to get close into the action
// or: a big lonely map, but 3 players are in the same room; detect that (k-means on distance)

	/*
	Target = GetRandomActor(class'FlagBase');
	if (Target == None)
		Target = GetRandomActor(class'PlayerPawn');
	if (Target == None)
		Target = GetRandomActor(class'ShockRifle');
	if (Target == None)
		Target = GetRandomActor(class'NavigationPoint');
	*/

function SetNewTarget(Actor a, optional Actor b) {
	local String report;

	// if (Level.TimeSeconds < LastSwitchTime + CameraSwitchSeconds)
		// return;

	LastSwitchTime = Level.TimeSeconds;
	bCheckingForInterestingTarget = False;

	if (isFC(P.ViewTarget) && bStickWithFC) {
		return;
	}

	report = "";

	// CameraMode = FRand()*6;
	CameraMode = CameraMode+1;
	if (CameraMode>5)
		CameraMode=0;

	P.ViewTarget = None;
	FollowActor = None;
	LookActor = None;
	NewCamera();
	if (CameraMode == 0) {
		P.ViewTarget = a;
		report = "0 Viewing from "$NameActor(a);
	}
	if (CameraMode == 1) {
		FollowActor = a;
		report = "1 Following "$NameActor(FollowActor);
		P.ViewRotation.Pitch += 8192/2;
		P.SetLocation( FollowActor.Location );
		p.SetLocation( FollowActor.Location - 96*Normal(Vector(P.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
	}
	if (CameraMode == 2) {
		FollowActor = a;
		deltaYaw /= 4;
		deltaPitch /= 4;
		P.SetLocation( FollowActor.Location );
		P.SetLocation( FollowActor.Location - 96*Normal(Vector(P.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
		report = "2 Camera following "$NameActor(a);
	}
	if (CameraMode == 3) {
		NiceCamera();
		deltaYaw /= 4;
		deltaPitch /= 4;
		deltaFOV *= 2;
		// A = FindBusiestActor();
		A = FindClosestInterestingActor(,CentreOfMass());
		P.ViewTarget = None;
		P.SetLocation( A.Location );
		P.ViewRotation = rotator(CentreOfMass() - P.Location);
		P.SetLocation( A.Location - 96*Normal(Vector(P.ViewRotation)) + vect(0,0,16) );
		// FollowActor = FindClosestInterestingActor(A);
		FollowActor = A;
		// report = "3 Camera panning from "$NameActor(A)$" looking at "$NameActor(FollowActor);
		report = "3 Camera panning from and looking at "$NameActor(FollowActor);
	}
	if (CameraMode == 4) {
		FollowActor = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(FollowActor);
		}
		P.ViewRotation = rotator(LookActor.Location - FollowActor.Location);
		P.SetLocation( FollowActor.Location );
		P.SetLocation( FollowActor.Location - 96*Normal(Vector(P.ViewRotation)) + vect(0,0,16) );
		report = "4 Following "$NameActor(FollowActor)$" Facing "$NameActor(LookActor);
	}
	if (CameraMode == 5) {
		P.ViewTarget = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(P.ViewTarget);
		}
		report = "5 Viewing from "$NameActor(a)$" Looking at "$NameActor(LookActor);
	}

	P.bBehindView = ( P.ViewTarget != None );
	if (P.ViewTarget != None) {
		P.ViewTarget.BecomeViewTarget();
	}

		/*

		// Old methods:

		if (P.IsA('Spectator')) {
			// Spectator(P).bChaseCam = (FRand() < 0.80);
			// report = "(chase="$Spectator(P).bChaseCam$") " $ report;
		}

		// Shall we focus?
		if (FRand()<0.5) {
			FollowActor = None;
		}
		if (b != None) {
			FollowActor = b;
		}
		if (FRand()<0.25 || (FollowActor == None && FRand()<0.5)) {
			// FollowActor = FindClosestActor(P.ViewTarget);
			// FollowActor = FindClosestActorMatching(P.ViewTarget,"PlayerPawn");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(P.ViewTarget,"Bot");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(P.ViewTarget,"Projectile");
			// FollowActor = FindClosestActorClass(P.ViewTarget,class'Pawn');
			// FollowActor = FindClosestActorClass(P.ViewTarget,class'Bot');
			// FollowActor = FindClosestActorClass(P.ViewTarget,class'Projectile');
			// FollowActor = FindClosestActorClass(P.ViewTarget,class'PlayerPawn');
			FollowActor = FindClosestInterestingActor(P.ViewTarget);
			if (FollowActor == None) {
				report = "[FindClosestInterestingActor gave "$FollowActor$"] ";
			// } else if (!isInteresting(FollowActor)) {
				// report = "[Dropped uninteresting " $ FollowActor $ "] ";
				// FollowActor = None;
			}
		// } else {
			// FollowActor = None;
		}
		if (FRand()<0.25) {
			FollowActor = p.ViewTarget;
			p.ViewTarget = None;
		}

		NewCamera();

		if (FollowActor != None) {
			// P.SetLocation(P.ViewTarget.Location - 96*Vector(P.ViewRotation) + vect(0,0,48.0));
			P.ViewRotation = rotator(FollowActor.Location - P.Location);
			P.SetLocation(FollowActor.Location - 96*Vector(P.ViewRotation) + FRand()*vect(0,0,48.0));
			if (FRand()<0.25) {
				P.ViewTarget = None;
			}
		} else {
			// I think the ViewTarget will set our location/camera-point later,
			// but our position can be used to set a good initial rotation now.
			P.SetLocation(P.ViewTarget.Location - 96*Vector(P.ViewRotation) + FRand()*vect(0,0,48.0));
		}

		// Set a good initial rotation:
		if (FRand()<0.5) {
			p.ViewRotation = rotator(CentreOfMass() - P.Location);
		}

		// In case the camera wants to detach:
		// P.SetLocation(Target.Location);
		// P.SetRotation(Target.Rotation); // not always facing upwards!

		*/

	/*
	if (FRand()<0.05) {
		if (P.ViewTarget != None) {
			P.SetLocation(P.ViewTarget.Location - 96*Vector(p.ViewRotation) + vect(0,0,48.0));
			// P.SetLocation(P.ViewTarget.Location - 96 * Vector(p.ViewRotation));
			P.ViewTarget = None;
			report = "External camera! " $ report;
		}
	}
	*/

	// if (P.ViewTarget != None)
		// report = report $ "Watching: " $ P.ViewTarget.Name $ " ";
	// if (FollowActor != None)
		// report = report $ "Following: " $ FollowActor.Name $ " ";

	// report = report $ " ";

	// report = report $ " [/"$CountInterestingActors()$"]";
	report = "[" $ CountInterestingActors() $ "] " $ report;
	DEBUG(report);
	// Log(report);

}

// TODO
function Actor FindPlayerWithMostEnemiesNearby() {
	return None;
}

function String NameActor(Actor a) {
	if (A == None)
		return "None";
	if (A.IsA('PlayerPawn'))
		return PlayerPawn(A).PlayerReplicationInfo.PlayerName;
	if (A.IsA('Bot'))
		return Bot(A).getHumanName();
	if (A.IsA('Projectile'))
		return A.Name$"("$Projectile(P.ViewTarget).Owner$")";
	return ""$A.Name;
}

function Vector CentreOfMass() {
	local int count;
	local Vector centre;
	local Actor A;
	count = 0;
	centre = vect(0,0,0);
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			count++;
			centre = centre*(Float(count-1)/Float(count)) + A.Location*(1.0/Float(count));
		}
	}
	return centre;
}

function NewCamera() {

	#ifndef NO_CHANGE_ANGLE
	p.ViewRotation.Yaw = 8192*8*(FRand()-0.5);
	p.ViewRotation.Pitch = 8192*1*(FRand()-0.5);
	p.DesiredFOV = 90 + 30 * FRand();
	// p.ConsoleCommand("FOV "$p.DesiredFOV); // seems to be needed! NO it causes ini file writes!
	#endif

	deltaYaw = 400*(FRand()-0.5);
	// deltaPitch = -Sgn(p.ViewRotation.Pitch) * 50*FRand();
	deltaPitch = 50*(FRand()-0.4);
	deltaFOV = 0.2*(FRand()-0.5);

}

function Actor FindBusiestActor() {
	local Actor A,B,bestActor;
	local float distance,bestDistance;
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			distance = 0;
			foreach AllActors(class'Actor', B) {
				distance = distance + VSize(A.Location-B.Location);
			}
			if (bestActor == None || distance<bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

function NiceCamera() {
	local Actor A;

}

function PointTowardsActor(Pawn P, Actor Target) {
	// RotateTowards(p.ViewRotation,rotator(Target.Location-P.Location));
	PointTowardsLocation(p,Target.Location);
}

function PointTowardsLocation(Pawn P, Vector L) {
	// RotateTowards(p.ViewRotation,rotator(L-P.Location));
	local rotator RB;
	RB = rotator(L-P.Location);
	P.ViewRotation.yaw = RotateAngle(P.ViewRotation.yaw, RB.yaw);
	P.ViewRotation.pitch = RotateAngle(P.ViewRotation.pitch, RB.pitch);
}

/*
function RotateTowards(rotator RA, rotator RB) {
	RA.yaw = RotateAngle(RA.yaw, RB.yaw);
	RA.pitch = RotateAngle(RA.pitch, RB.pitch);
}
*/

function float RotateAngle(float a, float b) {
	while (a<0)
		a+=65536.0;
	while (a>=65536)
		a-=65536.0;
	while (b<0)
		b+=65536.0;
	while (b>=65536)
		b-=65536.0;
	if ( b-a > 65536/2) {
		b -= 65536.0;
	}
	if ( a-b > 65536/2) {
		a -= 65536.0;
	}
	return a * 0.95 + b * 0.05;
}

function bool LosingNetOn(Actor a) {
	if (a == None)
		return true;
	if (a.Location == vect(0,0,0))
		return true;
	return false;
}

function GetRandomCameraNow() {
	SetNewTarget(GetRandomActor());
}

// #define DontLose(X) if (X==None) { DEBUG("Lost X "$X); GetRandomCameraNow(); }
#define DontLose(X); 

function DeltaCamera(float Delta) {

	local Actor HitOut;
	local Vector HitLocation,HitNormal;
	local Rotator followTarget;
	local Vector TargetLocation,NewLocation;

	local bool doNotPan;

	if (CameraMode == 0) {
		DontLose(P.ViewTarget);
	}
	if (CameraMode == 1) {
		PointTowardsActor(P,FollowActor);
		// followTarget = rotator(FollowActor.Location - P.Location);
		// // p.ViewRotation.yaw   = 8192*4 + (p.ViewRotation.yaw-8192*4)   * 0.99 + (followTarget.yaw-8192*4)   * 0.01;
		// p.ViewRotation.yaw   = p.ViewRotation.yaw * 0.95 + followTarget.yaw * 0.05;
		// P.SetLocation( FollowActor.Location - 128*Vector(P.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(P.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 24;
		NewLocation = p.Location * 0.0 + TargetLocation * 1.0;
		p.SetLocation(NewLocation);
		// p.ClientSetLocation(NewLocation,p.ViewRotation);
		// doNotPan = true;
		DontLose(FollowActor);
	}
	if (CameraMode == 2) {
		PointTowardsActor(P,FollowActor);
		// followTarget = rotator(FollowActor.Location - P.Location);
		// p.ViewRotation.yaw   = p.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		// Always points down: p.ViewRotation.pitch = p.ViewRotation.pitch * 0.999 + followTarget.pitch * 0.001;
		doNotPan = true;
		DontLose(FollowActor);
	}
	if (CameraMode == 3) {
		// DONE: if this never works, try following FollowActor instead, just using the nice setup we have.
		TargetLocation = FollowActor.Location - 128*Normal(Vector(P.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 48;
		NewLocation = p.Location * 0.0 + TargetLocation * 1.0;
		p.SetLocation(NewLocation);
		PointTowardsLocation(P,CentreOfMass());
		// followTarget = rotator(CentreOfMass() - P.Location);
		// p.ViewRotation.yaw   = p.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		DontLose(FollowActor);
	}
	if (CameraMode == 4) {
		// P.SetLocation( FollowActor.Location - 128*Vector(P.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(P.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 64;
		NewLocation = p.Location * 0.5 + TargetLocation * 0.5;
		p.SetLocation(NewLocation);
		// p.ClientSetLocation(NewLocation,p.ViewRotation);
		PointTowardsActor(p,LookActor);
		// followTarget = rotator(LookActor.Location - P.Location);
		// p.ViewRotation.yaw   = p.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		DontLose(FollowActor);
		DontLose(LookActor);
	}
	if (CameraMode == 5) {
		// PointTowardsActor(p,FollowActor);
		PointTowardsActor(p,LookActor);
		// followTarget = rotator(FollowActor.Location - P.ViewTarget.Location);
		// p.ViewRotation.yaw   = p.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		DontLose(P.ViewTarget);
	}

	// if (p.ViewTarget != None) {
	if (bCameraPanning && !doNotPan) { // && FollowActor == None) {
		p.ViewRotation.Yaw += deltaYaw;
		p.ViewRotation.Pitch += deltaPitch;
		// p.ConsoleCommand("FOV "$p.DesiredFOV); // seems to be needed! NO it causes ini file writes!
		deltaYaw = deltaYaw * 0.998;
		deltaPitch = deltaPitch * 0.998;
	}
	if (bCameraPanning) {
		p.DesiredFOV = p.DesiredFOV + deltaFOV;
		deltaFOV = deltaFOV * 0.998;
	}

	// if (FollowActor != None) {
		// P.ViewRotation = rotator(FollowActor.Location - P.Location);
		// // P.SetRotation(rotator(FollowActor.Location - P.Location));
		/*
		HitActor = Trace(HitLocation,HitNormal,FollowActor.Location+128*Vector(p.ViewRotation),P.Location+16*Vector(p.ViewRotation),true);
		if (HitActor != FollowActor) {
			DEBUG("Lost follow on "$FollowActor.Name$" got "$HitActor);
			FollowActor = None;
		}
		*/
	// }

}

/*
function CheckForNewActors() {
	local Actor A;
	local String NewList;
	NewList=" "; // BUG TODO: in online play actors will sometimes leave the list then return to it later; so we need an AllActorsEverList
	foreach AllActors(class'Actor', A) {
		NewList = NewList $ A.Name $ " ";
		if (LastList != "") {
			// BUG TODO: this becomes inefficient
			if (InStr(LastList," "$A.Name$" ")<0) {
				HandleNewActor(A);
			}
		}
	}
	LastList = NewList;
}
*/

function CheckForNewActors() {
	local Actor A;
	local bool pastLast;
	foreach AllActors(class'Actor', A) {
		if (pastLast) {
			HandleNewActor(A);
		}
		if (A == LastNewActor) {
			pastLast = true;
		}
	}
	LastNewActor = A;
}

function float Sgn(float num) {
	if (num>0)
		return +1;
	if (num<0)
		return -1;
	return 0;
}

function bool isAGoodProjectile(Actor A) {
	return (A.isA('flakslug') || A.isA('ShockProj') || A.isA('Rocket'));
}

function HandleNewActor(Actor A) {
	if (bCheckingForInterestingTarget) {
		// if (isInteresting(A)) {
		// if (A.IsA('Projectile') && Instr(""$A.Name,"Trans")<0) {
		if (
			isAGoodProjectile(A)
			// || A.IsA('Carcass')
			|| (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
			|| (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
			|| (a.IsA('Armor') && !Pickup(a).bHeldItem)
			|| a.IsA('Effect')
		) {
			// Log("New Actor: "$A);
			DEBUG("New Actor: "$A);
			SetNewTarget(A,A.Owner);
		}
	}
}

/*
function CheckForInterestingTarget() {
	// local Actor A;
	// local Actor LatestProjectile;
	// New projectile or new damage will force camera-switch.
	if (!bCheckingForInterestingTarget) {
		bCheckingForInterestingTarget = True;
		// LastList = "";
	} else {
		CheckForNewActors();
		// LatestProjectile = None;
		// foreach AllActors(class'Projectile', A) {
			// LatestProjectile = A;
		// }
	}
}
*/

event Tick (float Delta) {
	local int i,diffout;

	// if (FRand()<0.01) {
		// Log("Tick delta="$Delta);
	// }

	// if (  !P.PlayerReplicationInfo.bIsSpectator )
	if (!P.PlayerReplicationInfo.bIsSpectator && !P.bIsPlayer) {
		return;
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds) {
		// CheckForInterestingTarget();
		bCheckingForInterestingTarget = True;
	}
	CheckForNewActors();

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 1) {
		// p.ConsoleCommand("ViewTeam"); // to keep fresh list of actors during online play
		// P.ViewClass(class'Pawn'); // to keep fresh list of actors during online play

		// TODO: turned off because of "Now viewing" detection:
		// P.ViewClass(class'Pawn'); // to keep fresh list of actors during online play
		GetRandomCameraNow(); // If we use the player selected by ViewTeam, ... ?
		// NewCamera();
	}

	if (CameraMode != 3) {
		if (p.ViewTarget == None && FollowActor == None && LookActor == None) {
			DEBUG("LOST ACTOR");
			P.ViewClass(class'Pawn');
			GetRandomCameraNow();
		}
	}
	if (p.ViewTarget != None && LosingNetOn(p.ViewTarget)) {
		DEBUG("Losing: "$NameActor(p.ViewTarget));
	}
	if (FollowActor != None && LosingNetOn(FollowActor)) {
		DEBUG("Losing: "$NameActor(FollowActor));
	}
	if (LookActor != None && LosingNetOn(LookActor)) {
		DEBUG("Losing: "$NameActor(LookActor));
	}

	// Maybe it's ok to have both == None (Spec free fly mode)
	/* if (p.ViewTarget == None && FollowActor == None) {
		if (FRand()<0.05) {
			DEBUG("LOST ViewTarget and FollowActor!");
			p.ConsoleCommand("ViewTeam");
			// bCheckingForInterestingTarget = True; CheckForNewActors();
			GetRandomCameraNow();
		}
	} */

	DeltaCamera(Delta);

	/*
	// if ( P.ViewTarget != None ) {
	// if ( P.ViewTarget == None ) {
		// if ( Pawn(P.ViewTarget) != None ) {
			// targRot = Pawn(P.ViewTarget).ViewRotation;
			// targRot.Yaw = targRot.Yaw*0.999 + FRand();
			// targRot.Pitch = targRot.Pitch*0.999 + FRand();
			// myRot = P.ViewRotation;
			// ydelta = fun1(targRot.Yaw,myRot.Yaw,diffout);
			// pdelta = fun1(targRot.Pitch,myRot.Pitch,diffout);
			// if (FRand()<0.01) {
	*/

			/*
			if ( ydelta == -9999 )
			{
				SendErrMsg();
				 // TODO: = True;
			}
			*/
			/*
			if ( Pawn(P.ViewTarget).Health > 0 )
			{
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					if ( ydelta + P.ViewRotation.Yaw > 65536 )
					{
						P.ViewRotation.Yaw = 0;
						return;
					}
					P.ViewRotation.Yaw += ydelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						if ( P.ViewRotation.Yaw - ydelta < 0 )
						{
							P.ViewRotation.Yaw = 65536;
							return;
						}
						P.ViewRotation.Yaw -= ydelta;
					}
				}
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					P.ViewRotation.Pitch += pdelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						P.ViewRotation.Pitch -= pdelta;
					}
				}
				if ( P.ViewRotation.Roll != 0 )
				{
					P.ViewRotation.Roll = 0;
				}
			}
			*/

	// for (i=0;i<P.Player.Console.TopLine;i++) {
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"Now viewing from ");
		// Offset = InStr(P.Player.Console.MsgText[i],"Now viewing from ");
		if (Offset != -1) {
			RecommendedPlayerName = Mid(P.Player.Console.MsgText[P.Player.Console.TopLine],Len("Now viewing from "));
			if (Mid(RecommendedPlayerName,0,1) == " ")
				RecommendedPlayerName = Mid(RecommendedPlayerName,1);
			// DEBUG("OK got >"$RecommendedPlayerName$"<");
			Log("Got RecommendedPlayerName = >"$RecommendedPlayerName$"<");
		}
	// }

	// for (i=0;i<P.Player.Console.TopLine;i++) {
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine]," inflicted mortal damage upon ");
		if (Offset != -1) {
			Log("["$Level$"@"$Level.TimeSeconds$"] Frag: "$P.Player.Console.MsgText[P.Player.Console.TopLine]);
		}
	// }

	Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"mutate AFCOFF");
	if ( (Offset != -1) &&  !bAFCOFFmsg )
	{
		bautoFC = False;
		P.ClientMessage("Auto FC feature off");
		bAFCOFFmsg = True;
		bAFCONmsg = False;
	}
	Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"mutate AFCON");
	if ( (Offset != -1) &&  !bAFCONmsg )
	{
		bautoFC = True;
		P.ClientMessage("Auto FC feature on");
		bAFCOFFmsg = False;
		bAFCONmsg = True;
	}
	if ( bautoFC /* TODO: &&  ! */ )
	{
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"captured the red flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"captured the blue flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"has the red flag!");
		if ( Offset != -1 )
		{
			redFC = Left(P.Player.Console.MsgText[P.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"has the blue flag!");
		if ( Offset != -1 )
		{
			redFC = Left(P.Player.Console.MsgText[P.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(P.Player.Console.MsgText[P.Player.Console.TopLine],"Failed to change view");
		if ( Offset != -1 )
		{
			redFC = "";
			blueFC = "";
		}
		if (  !bviewingFC )
		{
			if ( P.ViewTarget == None )
			{
				if ( redFC != "" )
				{
					ViewRedFC();
				} else {
					if ( blueFC != "" )
					{
						ViewBlueFC();
					}
				}
			} else {
				if ( Pawn(P.ViewTarget) == None )
				{
					if ( redFC != "" )
					{
						ViewRedFC();
					} else {
						if ( blueFC != "" )
						{
							ViewBlueFC();
						}
					}
				} else {
					if ( Pawn(P.ViewTarget).PlayerReplicationInfo.HasFlag == None )
					{
						if ( redFC == Pawn(P.ViewTarget).PlayerReplicationInfo.PlayerName )
						{
							redFC = "";
						} else {
							if ( FindPlayer(redFC) )
							{
								ViewRedFC();
							} else {
								if ( blueFC == Pawn(P.ViewTarget).PlayerReplicationInfo.PlayerName )
								{
									blueFC = "";
								} else {
									if ( FindPlayer(blueFC) )
									{
										ViewBlueFC();
									}
								}
							}
						}
					}
				}
			}
			SetTimer(0.31,False);
			bviewingFC = True;
		}
	}
}

function bool FindPlayer(string S) {
	local int i;
	local TournamentGameReplicationInfo ptgri;

	ptgri = TournamentGameReplicationInfo(P.GameReplicationInfo);
	for (i=0;i<32;i++) {
		if ( ptgri.PRIArray[i] == None ) {
			continue;
		}
		if ( ptgri.PRIArray[i].bIsSpectator ) {
			continue;
		}
		if ( ptgri.PRIArray[i].HasFlag != None ) {
			if ( ptgri.PRIArray[i].PlayerName == S ) {
				return True;
			} else {
				return False;
			}
		}
	}
	return False;
}

function ViewRedFC() {
	P.ViewPlayer(redFC);
	P.ViewRotation = Pawn(P.ViewTarget).ViewRotation;
}

function ViewBlueFC() {
	P.ViewPlayer(blueFC);
	P.ViewRotation = Pawn(P.ViewTarget).ViewRotation;
}

function SendErrMsg() {
	P.ClientMessage("-----------------------------------------");
	P.ClientMessage("MAC Addresses don't match.");
	P.ClientMessage("AutoSpec will cease to function.");
	P.ClientMessage("-----------------------------------------");
}

function Timer () {
	bviewingFC = False;
}

function setpawn (PlayerPawn o) {
	P = o;
	AddSelfAsMutator();
	Level.Game.RegisterDamageMutator(Self);
}

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCheckingForInterestingTarget) {
		DEBUG("Damage "$InstigatedBy$" -> "$Victim$" ActualDamage="$ActualDamage); // DamageType="$DamageType$" 
		if (FRand()<0.5)
			SetNewTarget(InstigatedBy,Victim);
		else
			SetNewTarget(Victim,InstigatedBy);
	}
}

function AddSelfAsMutator() {
	Level.Game.BaseMutator.AddMutator(Self);
}

// TODO: buggy
function AddMutator(Mutator Other) {
	if (Other != None && Other.Class == Self.Class) {
		Log("Not adding another nBAutoSpectate.");
		if (Other == Self) {
		} else {
			nBAutoSpectate(Other).Destroy();
		}
	} else {
		Log("Adding mutator: "$Other);
		Super.AddMutator(Other);
	}
}

function Actor FindClosestInterestingActor(optional Actor from, optional Vector fromV) {
	local Actor A,bestActor;
	local int distance,bestDistance;
	if (from != None)
		fromV = from.Location;
	// foreach VisibleActors(class'Actor', A, 16000000, from.Location) {
	foreach AllActors(class'Actor', A) {
		// if (A != from && isInteresting(A)) {
		if (A == from)
			continue;
		if (
			// isAGoodProjectile(A)
			// || isFC(A) ||
			isInteresting(A)
			// || A.IsA('CTFFlag')
			// || A.IsA('Flag')
			// || A.IsA('Carcass')
		) {
			distance = VSize(A.Location - from.Location);
			if (bestActor == None || distance < bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

defaultproperties {
		bautoFC=True

	bCameraPanning=True
	bSwitchCamera=True
	CameraSwitchSeconds=4
	bStickWithFC=False
	bPrintDebugInfo=True
}

#include "../../JLib/findactor.uc.jpp"
#include "../../JLib/jlib.uc.jpp"

