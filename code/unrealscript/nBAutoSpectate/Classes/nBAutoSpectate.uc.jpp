#define LIST_ACTORS
// #define NO_CHANGE_ANGLE

// TODO:
// I keep losing actors like the one I am looking at, or his weapon.
// Solution:
// We should always be looking primarily at the Camera's ViewTarget.
// We should select the ViewTarget by calling ViewClass().

// CONSIDER: detect when P.ViewTarget changes, as a casual input from the viewer
// TODO: allow user command "!follow <nick>" to set the camera to follow a player (mode 2) e.g. for making a video.

// CONSIDER: Could continue to watch the first Corpse spawned after the player we are viewing dies (before/after they respawn).

// PROBLEM: some actors just go blank before they become None
//          we need to detect or avoid these
// maybe we can trust actors that have recently (re-)entered the pawnlist to be fresh

// #define Log(X); 
#define DEBUG(X); if (bPrintDebugInfo) { Camera.ClientMessage(X); }

//================================================================================
// nBAutoSpectate.
//================================================================================

// CameraMode Camera modes:
// 0 - default following ViewTarget, auto-panning
// 1 * custom following FollowActor
// 2 - free standing camera, looking at FollowActor
// 3 * floating camera, panning / looking at centre of mass)
// 4 * custom following FollowActor, but looking at LookActor
// 5 - default following ViewTarget, but looking at LookActor
//
// * = camera floats towards a target

// For AutoTeamBalance COOL_CAMERA, consider not moving the camera, but rotating it so that the powerup appears in the middle, halfway through the shot.

// class nBAutoSpectate extends Info;
class nBAutoSpectate extends Mutator;

var PlayerPawn Camera;
var Rotator targRot;
var Rotator myRot;
var Rotator prevRot;
var bool bfoundflag;
var bool bviewingFC;
var string blueFC;
var string redFC;
var bool bautoFC;
var bool bAFCOFFmsg;
var bool bAFCONmsg;
// var private bool ;
// var private int ;
// var private int ;
var int ydelta;
var int pdelta;
// var private int ;
// var private int ;
var int Offset;

// nB:
var config bool bPrintDebugInfo;
var config bool bCameraPanning;
var config bool bSwitchCamera;
var config float CameraSwitchSeconds;
var config bool bStickWithFC;
var config bool bDoViewClass;

// var String LastList;
var Actor LastNewActor;

var float LastSwitchTime;
var float deltaYaw, deltaPitch, deltaFOV, fov;
var Actor FollowActor, LookActor;

var bool bCheckingForInterestingTarget;
var bool bDoneViewClass;

var int CameraMode;

var String RecommendedPlayerName;

function int fun1 (int X, int Y, out int diff) {
	local int newdiff;

	diff = X - Y;
	newdiff = diff;
	if ( (newdiff > 20000) || (newdiff < -20000) )
	{
		newdiff = 20000;
	}
	return newdiff * newdiff / 500000;
}

function PlayerPawn GetRandomPlayer() {
	local PlayerPawn p;
	local int count;
	foreach AllActors(class'PlayerPawn',p)
		count++;
	count = count * FRand();
	foreach AllActors(class'PlayerPawn',p) {
		count--;
		if (count < 0)
			return p;
	}
	return p;
}

function bool isInteresting(Actor a) {
	if (a.IsA('Spectator'))
		return false;
	return (
		// a.IsA('FlagBase')
		// a.IsA('CTFFlag') ||
		// a.IsA('Flag')
		// || (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
		// || (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
		// || a.IsA('HealthPack')
		// a.IsA('Projectile')
		isAGoodProjectile(A)
		|| a.IsA('PlayerPawn')
		|| a.IsA('Bot')
		// || a.IsA('Pawn')
		|| (a.IsA('Weapon') && Inventory(a).bTossedOut)
		// || a.IsA('NavigationPoint')
		|| a.IsA('Effect')
		// || a.IsA('Carcass')
	);
}

function int CountInterestingActors() {
	local int count;
	local Actor a;
	#ifdef LIST_ACTORS
	local String list;
	#endif
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			count++;
			#ifdef LIST_ACTORS
			list = list $ a.Name $ " ";
			#endif
		}
	}
	#ifdef LIST_ACTORS
	// if (count < 10)
		// DEBUG(count$" actors: "$list);
	// else
		// DEBUG(count$" actors.");
	#endif
	return count;
}

function Actor GetLastViewClass() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
			DEBUG("Re-using "$NameActor(a));
			// RecommendedPlayerName = ""; // i think i'll only use it once, then discard it.
			return a;
		}
	}
	return None;
}

// #define GetRandomActor GetRandomActorReal
// #define GetRandomActor GetLastViewClass
function Actor GetRandomActor() {
	local Actor a;
	a = GetLastViewClass();
	if (a == None)
		a = GetRandomActorReal();
	return a;
}

function Actor GetRandomActorReal() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (isFC(a) && FRand()<0.5) {
			return a;
		}
	}

	if (RecommendedPlayerName != ""/* && FRand()<0.2*/) {
		foreach AllActors(class'Actor',a) {
			if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
				DEBUG("Re-using "$NameActor(a));
				// RecommendedPlayerName = ""; // i think i'll only use it once, then discard it.
				return a;
			}
		}
		// RecommendedPlayerName = ""; // it has failed me now, and we don't want it to last forever anyway
	}

	count = CountInterestingActors();
	chosen = count*FRand();
	// Log("Chose "$chosen$" / "$count);
	// DEBUG("Chose "$Int(count*FRand())$" / "$count);
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			chosen--;
			if (chosen < 0)
				return a;
		}
	}
	return a;
}

function bool isFC(Actor a) {
	return ( ( a != None ) &&
		( Pawn(a) != None ) &&
		( Pawn(a).PlayerReplicationInfo != None ) &&
		( Pawn(a).PlayerReplicationInfo.HasFlag != None )
	);
}

// TODO: To get the most action, find a "busy" Actor to view.
// one e.g.: find average location of all pawns; find actor closest to this, to get close into the action
// or: a big lonely map, but 3 players are in the same room; detect that (k-means on distance)

	/*
	Target = GetRandomActor(class'FlagBase');
	if (Target == None)
		Target = GetRandomActor(class'PlayerPawn');
	if (Target == None)
		Target = GetRandomActor(class'ShockRifle');
	if (Target == None)
		Target = GetRandomActor(class'NavigationPoint');
	*/

function bool isCameraModeAllowed() {
	return (CameraMode>=0 && CameraMode<=5);
}

function SetNewTarget(Actor a, optional Actor b) {
	local String report;

	// if (Level.TimeSeconds < LastSwitchTime + CameraSwitchSeconds)
		// return;

	LastSwitchTime = Level.TimeSeconds;
	bCheckingForInterestingTarget = False;
	bDoneViewClass = False;

	if (GetLastViewClass() != None) {
		a = GetLastViewClass();
	}

	if (isFC(Camera.ViewTarget) && bStickWithFC) {
		// return;
		a = Camera.ViewTarget;
	}

	report = "";

	// CameraMode = FRand()*6;
	while (true) {
		CameraMode = CameraMode+1;
		if (CameraMode>5)
			CameraMode=0;
		if (isCameraModeAllowed())
			break;
	}

	Camera.ViewTarget = None;
	FollowActor = None;
	LookActor = None;
	NewCamera();
	if (CameraMode == 0) {
		Camera.ViewTarget = a;
		report = "0 Viewing from "$NameActor(a);
	}
	if (CameraMode == 1) {
		FollowActor = a;
		report = "1 Following "$NameActor(FollowActor);
		Camera.ViewRotation.Pitch += 8192/2;
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
	}
	if (CameraMode == 2) {
		FollowActor = a;
		deltaYaw /= 4;
		deltaPitch /= 4;
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( Camera.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
		Camera.ViewRotation = rotator(FollowActor.Location-Camera.Location);
		report = "2 Camera following "$NameActor(a);
	}
	if (CameraMode == 3) {
		NiceCamera();
		deltaYaw /= 4;
		deltaPitch /= 4;
		deltaFOV *= 2;
		// A = FindBusiestActor();
		A = FindClosestInterestingActor(,CentreOfMass());
		Camera.ViewTarget = None;
		// Camera.SetLocation( A.Location );
		// Camera.ViewRotation = rotator(CentreOfMass() - Camera.Location);
		// Camera.SetLocation( A.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,16) );
		Camera.SetLocation( FindGoodCameraSpot(A.Location,96,-8+FRand()*96) );
		// FollowActor = FindClosestInterestingActor(A);
		FollowActor = A;
		// report = "3 Camera panning from "$NameActor(A)$" looking at "$NameActor(FollowActor);
		report = "3 Camera panning on "$NameActor(FollowActor);
	}
	if (CameraMode == 4) {
		FollowActor = a;
		LookActor = b;
		if (LookActor == None || FRand()<0.5) {
			LookActor = FindClosestInterestingActor(FollowActor);
		}
		Camera.ViewRotation = rotator(LookActor.Location - FollowActor.Location);
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,16) );
		report = "4 Following "$NameActor(FollowActor)$" Facing "$NameActor(LookActor);
	}
	if (CameraMode == 5) {
		Camera.ViewTarget = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(Camera.ViewTarget);
		}
		report = "5 Viewing from "$NameActor(a)$" Looking at "$NameActor(LookActor);
	}

	Camera.bBehindView = ( Camera.ViewTarget != None );
	if (Camera.ViewTarget != None) {
		Camera.ViewTarget.BecomeViewTarget();
	}

		/*

		// Old methods:

		if (Camera.IsA('Spectator')) {
			// Spectator(Camera).bChaseCam = (FRand() < 0.80);
			// report = "(chase="$Spectator(Camera).bChaseCam$") " $ report;
		}

		// Shall we focus?
		if (FRand()<0.5) {
			FollowActor = None;
		}
		if (b != None) {
			FollowActor = b;
		}
		if (FRand()<0.25 || (FollowActor == None && FRand()<0.5)) {
			// FollowActor = FindClosestActor(Camera.ViewTarget);
			// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"PlayerPawn");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"Bot");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"Projectile");
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Pawn');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Bot');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Projectile');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'PlayerPawn');
			FollowActor = FindClosestInterestingActor(Camera.ViewTarget);
			if (FollowActor == None) {
				report = "[FindClosestInterestingActor gave "$FollowActor$"] ";
			// } else if (!isInteresting(FollowActor)) {
				// report = "[Dropped uninteresting " $ FollowActor $ "] ";
				// FollowActor = None;
			}
		// } else {
			// FollowActor = None;
		}
		if (FRand()<0.25) {
			FollowActor = Camera.ViewTarget;
			Camera.ViewTarget = None;
		}

		NewCamera();

		if (FollowActor != None) {
			// Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + vect(0,0,48.0));
			Camera.ViewRotation = rotator(FollowActor.Location - Camera.Location);
			Camera.SetLocation(FollowActor.Location - 96*Vector(Camera.ViewRotation) + FRand()*vect(0,0,48.0));
			if (FRand()<0.25) {
				Camera.ViewTarget = None;
			}
		} else {
			// I think the ViewTarget will set our location/camera-point later,
			// but our position can be used to set a good initial rotation now.
			Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + FRand()*vect(0,0,48.0));
		}

		// Set a good initial rotation:
		if (FRand()<0.5) {
			Camera.ViewRotation = rotator(CentreOfMass() - Camera.Location);
		}

		// In case the camera wants to detach:
		// Camera.SetLocation(Target.Location);
		// Camera.SetRotation(Target.Rotation); // not always facing upwards!

		*/

	/*
	if (FRand()<0.05) {
		if (Camera.ViewTarget != None) {
			Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + vect(0,0,48.0));
			// Camera.SetLocation(Camera.ViewTarget.Location - 96 * Vector(Camera.ViewRotation));
			Camera.ViewTarget = None;
			report = "External camera! " $ report;
		}
	}
	*/

	// if (Camera.ViewTarget != None)
		// report = report $ "Watching: " $ Camera.ViewTarget.Name $ " ";
	// if (FollowActor != None)
		// report = report $ "Following: " $ FollowActor.Name $ " ";

	// report = report $ " ";

	// report = report $ " [/"$CountInterestingActors()$"]";
	// report = "[" $ CountInterestingActors() $ "] " $ report;

	// report = "[" $ getTeamCounts() $ "] " $ report;
	report = "[" $ getTeamCounts() $ "/" $ CountInterestingActors() $ "] " $ report;

	DEBUG(report);
	// Log(report);

}

// Just for curiousity/debugging purposes.
function String getTeamCounts() {
	local Actor A;
	local int countRed,countBlue;
	foreach AllActors(class'Actor', A) {
		// if (A.IsA('Pawn')) {
		if (A.IsA('Bot') || A.IsA('PlayerPawn')) {
			if (Pawn(A).PlayerReplicationInfo != None) {
				if (Pawn(A).PlayerReplicationInfo.Team == 0) {
					countRed++;
				}
				if (Pawn(A).PlayerReplicationInfo.Team == 1) {
					countBlue++;
				}
			}
		}
	}
	// return "Red: "$countRed$" | Blue: "$countBlue;
	return countRed $ "v" $countBlue;
}

// TODO
function Actor FindPlayerWithMostEnemiesNearby() {
	return None;
}

function String NameActor(Actor a) {
	if (A == None)
		return "None";
	// if (A.IsA('Pawn') && Pawn(A).PlayerReplicationInfo != None)
		// return PlayerPawn(A).PlayerReplicationInfo.PlayerName; // no good: "" for bots online
	if (A.IsA('PlayerPawn'))
		return PlayerPawn(A).PlayerReplicationInfo.PlayerName;
	if (A.IsA('Bot'))
		return Bot(A).getHumanName();
	if (A.IsA('Projectile'))
		return A.Name$"("$Projectile(Camera.ViewTarget).Owner$")";
	return ""$A.Name;
}

function Vector CentreOfMass() {
	local int count;
	local Vector centre;
	local Actor A;
	count = 0;
	centre = vect(0,0,0);
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			count++;
			centre = centre*(Float(count-1)/Float(count)) + A.Location*(1.0/Float(count));
		}
	}
	return centre;
}

function NewCamera() {

	#ifndef NO_CHANGE_ANGLE
	Camera.ViewRotation.Yaw = 8192*8*(FRand()-0.5);
	Camera.ViewRotation.Pitch = 8192*1*(FRand()-0.5);
	Camera.DesiredFOV = 90 + 30 * FRand();
	// Camera.ConsoleCommand("FOV "$Camera.DesiredFOV); // seems to be needed! NO it causes ini file writes!
	#endif

	deltaYaw = 400*(FRand()-0.5);
	// deltaPitch = -Sgn(Camera.ViewRotation.Pitch) * 50*FRand();
	deltaPitch = 50*(FRand()-0.4);
	deltaFOV = 0.2*(FRand()-0.5);

}

function Actor FindBusiestActor() {
	local Actor A,B,bestActor;
	local float distance,bestDistance;
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			distance = 0;
			foreach AllActors(class'Actor', B) {
				distance = distance + VSize(A.Location-B.Location);
			}
			if (bestActor == None || distance<bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

function NiceCamera() {
	local Actor A;

}

function PointTowardsActor(Pawn P, Actor Target) {
	// RotateTowards(Camera.ViewRotation,rotator(Target.Location-P.Location));
	PointTowardsLocation(P,Target.Location);
}

function PointTowardsLocation(Pawn P, Vector L) {
	// RotateTowards(Camera.ViewRotation,rotator(L-P.Location));
	local rotator RB;
	RB = rotator(L-P.Location);
	P.ViewRotation.yaw = RotateAngle(P.ViewRotation.yaw, RB.yaw);
	P.ViewRotation.pitch = RotateAngle(P.ViewRotation.pitch, RB.pitch);
}

/*
function RotateTowards(rotator RA, rotator RB) {
	RA.yaw = RotateAngle(RA.yaw, RB.yaw);
	RA.pitch = RotateAngle(RA.pitch, RB.pitch);
}
*/

function float RotateAngle(float a, float b) {
	while (a<0)
		a+=65536.0;
	while (a>=65536)
		a-=65536.0;
	while (b<0)
		b+=65536.0;
	while (b>=65536)
		b-=65536.0;
	if ( b-a > 65536/2) {
		b -= 65536.0;
	}
	if ( a-b > 65536/2) {
		a -= 65536.0;
	}
	return a * 0.95 + b * 0.05;
}

function bool LosingNetOn(Actor a) {
	if (a == None)
		return true;
	if (a.Location == vect(0,0,0))
		return true;
	return false;
}

function GetRandomCameraNow() {
	SetNewTarget(GetRandomActor());
}

function MovePawnTowardsLocation(Pawn p, Vector NewLocation, float amount) {
/*
	while (amount<1) {
		NewLocation = p.Location * (1.0-amount) + NewLocation * amount;
		if (p.SetLocation(NewLocation))
			break;
		amount = amount + 0.05;
	}
*/
	p.SetLocation( p.Location * (1.0-amount) + NewLocation * amount );
}

// #define DontLose(X) if (X==None) { DEBUG("Lost X "$X); GetRandomCameraNow(); }
// #define DontLose(X); 
#define DontLose(X,Y); if (LosingNetOn(X)) { DEBUG("Losing " $ Y); GetRandomCameraNow(); }
// TODO: since X==None, Y should be a stored string that described X.

function DeltaCamera(float Delta) {

	local Actor HitOut;
	local Vector HitLocation,HitNormal;
	local Rotator followTarget;
	local Vector TargetLocation,NewLocation;

	local bool doNotPan;

	if (CameraMode == 0) {
		DontLose(Camera.ViewTarget,"Camera.ViewTarget");
	}
	if (CameraMode == 1) {
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(FollowActor.Location - Camera.Location);
		// // Camera.ViewRotation.yaw   = 8192*4 + (Camera.ViewRotation.yaw-8192*4)   * 0.99 + (followTarget.yaw-8192*4)   * 0.01;
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.95 + followTarget.yaw * 0.05;
		// Camera.SetLocation( FollowActor.Location - 128*Vector(Camera.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 24;
		MovePawnTowardsLocation(Camera,NewLocation,1.0);
		// NewLocation = Camera.Location * 0.0 + TargetLocation * 1.0;
		// Camera.SetLocation(NewLocation);
		// Camera.ClientSetLocation(NewLocation,Camera.ViewRotation);
		// doNotPan = true;
		DontLose(FollowActor,FollowActor);
	}
	if (CameraMode == 2) {
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(FollowActor.Location - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		// Always points down: Camera.ViewRotation.pitch = Camera.ViewRotation.pitch * 0.999 + followTarget.pitch * 0.001;
		doNotPan = true;
		DontLose(FollowActor,FollowActor);
	}
	if (CameraMode == 3) {
		// DONE: if this never works, try following FollowActor instead, just using the nice setup we have.
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 48;
		MovePawnTowardsLocation(Camera,TargetLocation,0.2);
		// NewLocation = Camera.Location * 0.8 + TargetLocation * 0.2;
		// Camera.SetLocation(NewLocation);
		PointTowardsLocation(Camera,CentreOfMass());
		// followTarget = rotator(CentreOfMass() - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		DontLose(FollowActor,FollowActor);
	}
	if (CameraMode == 4) {
		// Camera.SetLocation( FollowActor.Location - 128*Vector(Camera.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 64;
		// NewLocation = Camera.Location * 0.9 + TargetLocation * 0.1;
		MovePawnTowardsLocation(Camera,TargetLocation,0.1);
		// Camera.SetLocation(NewLocation);
		// Camera.ClientSetLocation(NewLocation,Camera.ViewRotation);
		PointTowardsActor(Camera,LookActor);
		// followTarget = rotator(LookActor.Location - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		DontLose(FollowActor,FollowActor);
		DontLose(LookActor,LookActor);
	}
	if (CameraMode == 5) {
		// PointTowardsActor(Camera,FollowActor);
		PointTowardsActor(Camera,LookActor);
		// followTarget = rotator(FollowActor.Location - Camera.ViewTarget.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		DontLose(Camera.ViewTarget,Camera.ViewTarget);
	}

	// if (Camera.ViewTarget != None) {
	if (bCameraPanning && !doNotPan) { // && FollowActor == None) {
		Camera.ViewRotation.Yaw += deltaYaw;
		Camera.ViewRotation.Pitch += deltaPitch;
		// Camera.ConsoleCommand("FOV "$Camera.DesiredFOV); // seems to be needed! NO it causes ini file writes!
		deltaYaw = deltaYaw * 0.998;
		deltaPitch = deltaPitch * 0.998;
	}
	if (bCameraPanning) {
		Camera.DesiredFOV = Camera.DesiredFOV + deltaFOV;
		deltaFOV = deltaFOV * 0.998;
	}

	// if (FollowActor != None) {
		// Camera.ViewRotation = rotator(FollowActor.Location - Camera.Location);
		// // Camera.SetRotation(rotator(FollowActor.Location - Camera.Location));
		/*
		HitActor = Trace(HitLocation,HitNormal,FollowActor.Location+128*Vector(Camera.ViewRotation),Camera.Location+16*Vector(Camera.ViewRotation),true);
		if (HitActor != FollowActor) {
			DEBUG("Lost follow on "$FollowActor.Name$" got "$HitActor);
			FollowActor = None;
		}
		*/
	// }

}

/*
function CheckForNewActors() {
	local Actor A;
	local String NewList;
	NewList=" "; // BUG TODO: in online play actors will sometimes leave the list then return to it later; so we need an AllActorsEverList
	foreach AllActors(class'Actor', A) {
		NewList = NewList $ A.Name $ " ";
		if (LastList != "") {
			// BUG TODO: this becomes inefficient
			if (InStr(LastList," "$A.Name$" ")<0) {
				HandleNewActor(A);
			}
		}
	}
	LastList = NewList;
}
*/

function CheckForNewActors() {
	local Actor A;
	local bool pastLast;
	foreach AllActors(class'Actor', A) {
		if (pastLast) {
			HandleNewActor(A);
		}
		if (A == LastNewActor) {
			pastLast = true;
		}
	}
	LastNewActor = A;
}

function float Sgn(float num) {
	if (num>0)
		return +1;
	if (num<0)
		return -1;
	return 0;
}

function bool isAGoodProjectile(Actor A) {
	return (A.isA('flakslug') || A.isA('ShockProj') || A.isA('Rocket'));
}

function HandleNewActor(Actor A) {
	if (bCheckingForInterestingTarget) {
		// if (isInteresting(A)) {
		// if (A.IsA('Projectile') && Instr(""$A.Name,"Trans")<0) {
		if (
			isAGoodProjectile(A)
			// || A.IsA('Carcass')
			|| (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
			|| (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
			|| (a.IsA('Armor') && !Pickup(a).bHeldItem)
			|| a.IsA('Effect')
		) {
			// Log("New Actor: "$A);
			DEBUG("New Actor: "$A);
			SetNewTarget(A,A.Owner);
		}
	}
}

/*
function CheckForInterestingTarget() {
	// local Actor A;
	// local Actor LatestProjectile;
	// New projectile or new damage will force camera-switch.
	if (!bCheckingForInterestingTarget) {
		bCheckingForInterestingTarget = True;
		// LastList = "";
	} else {
		CheckForNewActors();
		// LatestProjectile = None;
		// foreach AllActors(class'Projectile', A) {
			// LatestProjectile = A;
		// }
	}
}
*/

event Tick (float Delta) {
	local int i,diffout;

	// if (FRand()<0.01) {
		// Log("Tick delta="$Delta);
	// }

	// if (  !Camera.PlayerReplicationInfo.bIsSpectator )
	if (!Camera.PlayerReplicationInfo.bIsSpectator && !Camera.bIsPlayer) {
		return;
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds - 1) {
		// Start watching for actors which we want to catch on spawn (e.g. short-lived projectiles)
		bCheckingForInterestingTarget = True;
	}
	CheckForNewActors();

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 0) {
		// Camera.ConsoleCommand("ViewTeam"); // to keep fresh list of actors during online play
		// Camera.ViewClass(class'Pawn'); // to keep fresh list of actors during online play

		// TODO: turned off because of "Now viewing" detection:
		//       and back on again ;)
		// BUG: when online, this takes a little time to get back, *after* we switch cam :S
		// maybe we should detect "now viewing from" and *then* switch cam
		if (bDoViewClass && !bDoneViewClass) {
			// To keep a fresh list of actors during online play, we call ViewClass:
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Actor');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Actor');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Pawn');
			bDoneViewClass = True;
		}
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 1) {
		GetRandomCameraNow(); // If we use the player selected by ViewTeam, ... ?
		// NewCamera();
	}

	if (CameraMode != 3) {
		if (Camera.ViewTarget == None && FollowActor == None && LookActor == None) {
			DEBUG("LOST ACTOR");
			if (bDoViewClass) {
				Camera.ViewClass(class'Pawn');
			}
			GetRandomCameraNow();
		}
	}
	if (Camera.ViewTarget != None && LosingNetOn(Camera.ViewTarget)) {
		DEBUG("Losing: "$NameActor(Camera.ViewTarget));
	}
	if (FollowActor != None && LosingNetOn(FollowActor)) {
		DEBUG("Losing: "$NameActor(FollowActor));
	}
	if (LookActor != None && LosingNetOn(LookActor)) {
		DEBUG("Losing: "$NameActor(LookActor));
	}

	// Maybe it's ok to have both == None (Spec free fly mode)
	/* if (Camera.ViewTarget == None && FollowActor == None) {
		if (FRand()<0.05) {
			DEBUG("LOST ViewTarget and FollowActor!");
			Camera.ConsoleCommand("ViewTeam");
			// bCheckingForInterestingTarget = True; CheckForNewActors();
			GetRandomCameraNow();
		}
	} */

	DeltaCamera(Delta);

	/*
	// if ( Camera.ViewTarget != None ) {
	// if ( Camera.ViewTarget == None ) {
		// if ( Pawn(Camera.ViewTarget) != None ) {
			// targRot = Pawn(Camera.ViewTarget).ViewRotation;
			// targRot.Yaw = targRot.Yaw*0.999 + FRand();
			// targRot.Pitch = targRot.Pitch*0.999 + FRand();
			// myRot = Camera.ViewRotation;
			// ydelta = fun1(targRot.Yaw,myRot.Yaw,diffout);
			// pdelta = fun1(targRot.Pitch,myRot.Pitch,diffout);
			// if (FRand()<0.01) {
	*/

			/*
			if ( ydelta == -9999 )
			{
				SendErrMsg();
				 // TODO: = True;
			}
			*/
			/*
			if ( Pawn(Camera.ViewTarget).Health > 0 )
			{
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					if ( ydelta + Camera.ViewRotation.Yaw > 65536 )
					{
						Camera.ViewRotation.Yaw = 0;
						return;
					}
					Camera.ViewRotation.Yaw += ydelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						if ( Camera.ViewRotation.Yaw - ydelta < 0 )
						{
							Camera.ViewRotation.Yaw = 65536;
							return;
						}
						Camera.ViewRotation.Yaw -= ydelta;
					}
				}
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					Camera.ViewRotation.Pitch += pdelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						Camera.ViewRotation.Pitch -= pdelta;
					}
				}
				if ( Camera.ViewRotation.Roll != 0 )
				{
					Camera.ViewRotation.Roll = 0;
				}
			}
			*/

	// for (i=0;i<Camera.Player.Console.TopLine;i++) {
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"Now viewing from ");
		// Offset = InStr(Camera.Player.Console.MsgText[i],"Now viewing from ");
		if (Offset != -1) {
			RecommendedPlayerName = Mid(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Len("Now viewing from "));
			if (Mid(RecommendedPlayerName,0,1) == " ")
				RecommendedPlayerName = Mid(RecommendedPlayerName,1);
			// DEBUG("OK got >"$RecommendedPlayerName$"<");
			Log("Got RecommendedPlayerName = >"$RecommendedPlayerName$"<");
			// Force a switch now:
			if (CameraMode != 0 && CameraMode != 5) {
				// We don't do it in mode 0 or 5 since they both *cause* "Now viewing from"
				// LastSwitchTime = Level.TimeSeconds - CameraSwitchSeconds + 2; // immediate switch seems no good - tended to put me in 1st person view
				// LastSwitchTime = Level.TimeSeconds - CameraSwitchSeconds; // turned it off anyway
			}
		}
	// }

	// for (i=0;i<Camera.Player.Console.TopLine;i++) {
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]," inflicted mortal damage upon ");
		if (Offset != -1) {
			Log("["$Level$"@"$Level.TimeSeconds$"] Frag: "$Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]);
		}
	// }

	Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"mutate AFCOFF");
	if ( (Offset != -1) &&  !bAFCOFFmsg )
	{
		bautoFC = False;
		Camera.ClientMessage("Auto FC feature off");
		bAFCOFFmsg = True;
		bAFCONmsg = False;
	}
	Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"mutate AFCON");
	if ( (Offset != -1) &&  !bAFCONmsg )
	{
		bautoFC = True;
		Camera.ClientMessage("Auto FC feature on");
		bAFCOFFmsg = False;
		bAFCONmsg = True;
	}
	if ( bautoFC /* TODO: &&  ! */ )
	{
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"captured the red flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"captured the blue flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"has the red flag!");
		if ( Offset != -1 )
		{
			redFC = Left(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"has the blue flag!");
		if ( Offset != -1 )
		{
			redFC = Left(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"Failed to change view");
		if ( Offset != -1 )
		{
			redFC = "";
			blueFC = "";
		}
		if (  !bviewingFC )
		{
			if ( Camera.ViewTarget == None )
			{
				if ( redFC != "" )
				{
					ViewRedFC();
				} else {
					if ( blueFC != "" )
					{
						ViewBlueFC();
					}
				}
			} else {
				if ( Pawn(Camera.ViewTarget) == None )
				{
					if ( redFC != "" )
					{
						ViewRedFC();
					} else {
						if ( blueFC != "" )
						{
							ViewBlueFC();
						}
					}
				} else {
					if ( Pawn(Camera.ViewTarget).PlayerReplicationInfo.HasFlag == None )
					{
						if ( redFC == Pawn(Camera.ViewTarget).PlayerReplicationInfo.PlayerName )
						{
							redFC = "";
						} else {
							if ( FindPlayer(redFC) )
							{
								ViewRedFC();
							} else {
								if ( blueFC == Pawn(Camera.ViewTarget).PlayerReplicationInfo.PlayerName )
								{
									blueFC = "";
								} else {
									if ( FindPlayer(blueFC) )
									{
										ViewBlueFC();
									}
								}
							}
						}
					}
				}
			}
			SetTimer(0.31,False);
			bviewingFC = True;
		}
	}
}

function bool FindPlayer(string S) {
	local int i;
	local TournamentGameReplicationInfo ptgri;

	ptgri = TournamentGameReplicationInfo(Camera.GameReplicationInfo);
	for (i=0;i<32;i++) {
		if ( ptgri.PRIArray[i] == None ) {
			continue;
		}
		if ( ptgri.PRIArray[i].bIsSpectator ) {
			continue;
		}
		if ( ptgri.PRIArray[i].HasFlag != None ) {
			if ( ptgri.PRIArray[i].PlayerName == S ) {
				return True;
			} else {
				return False;
			}
		}
	}
	return False;
}

function ViewRedFC() {
	Camera.ViewPlayer(redFC);
	Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
}

function ViewBlueFC() {
	Camera.ViewPlayer(blueFC);
	Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
}

function SendErrMsg() {
	Camera.ClientMessage("-----------------------------------------");
	Camera.ClientMessage("MAC Addresses don't match.");
	Camera.ClientMessage("AutoSpec will cease to function.");
	Camera.ClientMessage("-----------------------------------------");
}

function Timer () {
	bviewingFC = False;
}

function setpawn (PlayerPawn o) {
	Camera = o;
	AddSelfAsMutator();
	Level.Game.RegisterDamageMutator(Self);
}

function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCheckingForInterestingTarget) {
		// TODO: never happens =/
		DEBUG("Damage "$InstigatedBy$" -> "$Victim$" ActualDamage="$ActualDamage); // DamageType="$DamageType$" 
		if (FRand()<0.5)
			SetNewTarget(InstigatedBy,Victim);
		else
			SetNewTarget(Victim,InstigatedBy);
	}
}

function AddSelfAsMutator() {
	Level.Game.BaseMutator.AddMutator(Self);
}

// TODO: buggy ... how tho?!
function AddMutator(Mutator Other) {
	if (Other != None && Other.Class == Self.Class) {
		Log("Not adding another nBAutoSpectate.");
		if (Other == Self) {
		} else {
			nBAutoSpectate(Other).Destroy();
		}
	} else {
		Log("Adding mutator: "$Other);
		Super.AddMutator(Other);
	}
}

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, out coerce string Msg, optional bool bBeep, out optional name Type) {
	if (Sender == Receiver && Sender.IsA('Spectator')) { // Only process the message once.
		CheckMessage(Mid(Msg,InStr(Msg,":")+1), Sender);
	}
	return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type);
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	if (Sender == Receiver) { // Only process the message once.
		CheckMessage(Msg, Sender);
	}
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

function Mutate(String str, PlayerPawn Sender) {
	if (Left(str,1) == "!") {
		CheckMessage(Mid(str,2), Sender);
	}
	Super.Mutate(str,Sender);
}

function CheckMessage(String str, Actor Sender) {
	DEBUG("Got message: >"$str$"< from "$Sender);
	if (str ~= "followfc")
		bStickWithFC = True;
	if (str ~= "nofollowfc")
		bStickWithFC = False;
	if (str ~= "doviewclass")
		bDoViewClass = True;
	if (str ~= "nodoviewclass")
		bDoViewClass = False;
	if (StrStartsWith(Locs(str),"follow"))
		RecommendedPlayerName = StrAfter(str," ");
}

simulated function Destroyed() {
	if (Camera != None) {
		Camera.ViewTarget = None;
		Camera.bBehindView = False;
		Camera.DesiredFOV = Camera.default.DesiredFOV;
	}
}

function Vector FindGoodCameraSpot(Vector from, float radius, float height) {
	local float yaw,elev;
	local Vector to;
	local Vector HitLocation,HitNormal;
	local rotator rotation;
	local int i;
	// for (yaw=FRand()*8192/2;yaw<8192*8;yaw+=8192/2) {
		// for (y=minZ;y<maxZ;y+=16) {
	// }
	for (i=0;i<20;i++) {
		yaw = FRand()*8192*8;
		// y = minZ + FRand()*(maxZ - minZ);
			rotation.roll = 0;
			// rotation.pitch = pitch;
			rotation.pitch = 0;
			rotation.yaw = yaw;
			to = from + radius*Vector(rotation);
			to.z = from.z + height;
			HitActor = Trace(HitLocation,HitNormal,to,from,false);
			// dist = VSize(HitLocation-from);
			if (HitActor == None)
				return to;
			if (i==19)
				return from + (HitLocation-from)*0.9;
		// }
	}
}

function Actor FindClosestInterestingActor(optional Actor from, optional Vector fromV) {
	local Actor A,bestActor;
	local int distance,bestDistance;
	if (from != None)
		fromV = from.Location;
	// foreach VisibleActors(class'Actor', A, 16000000, from.Location) {
	foreach AllActors(class'Actor', A) {
		// if (A != from && isInteresting(A)) {
		if (A == from)
			continue;
		if (
			// isAGoodProjectile(A)
			// || isFC(A) ||
			isInteresting(A)
			// || A.IsA('CTFFlag')
			// || A.IsA('Flag')
			// || A.IsA('Carcass')
		) {
			distance = VSize(A.Location - from.Location);
			if (bestActor == None || distance < bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

defaultproperties {
		bautoFC=True

	bCameraPanning=True
	bSwitchCamera=True
	CameraSwitchSeconds=4
	bStickWithFC=True
	bDoViewClass=False
	bPrintDebugInfo=True
}

#include "../../JLib/findactor.uc.jpp"
#include "../../JLib/jlib.uc.jpp"

