//================================================================================
// nBAutoSpectate.
//================================================================================

// #define LIST_ACTORS
// #define NO_CHANGE_ANGLE
#define ENABLE_EVENT_RECORD_REPLAY
// #define PKATB

/*

// CameraMode Camera modes:
// 0 - default following ViewTarget, auto-panning
// 1 * custom following FollowActor
// 2 - free standing camera, looking at FollowActor
// 3 * floating camera, panning / looking at centre of mass)
// // 4 * custom following FollowActor, but looking at LookActor
// 4 * custom following FollowActor, and looking at LookActor
// 5 - default following ViewTarget, but looking at LookActor
// 6 - Viewing from behind FollowActor To LookActor
//
// * = camera floats towards a target

// For AutoTeamBalance COOL_CAMERA, consider not moving the camera, but rotating it so that the powerup appears in the middle, halfway through the shot.

*/

/*

// TODO: check messages for events
//       Camera.ProgressMessage[0] - [7]     or maybe playeerPawn.ProgressMessage[0-7]
//       Keep LastProgressMessage[0] - [7] to make checking easier
// Didn't work, try Console messages?
// No I think we really need to check ChallengeHUD.CurrentMessage and ShortMessageQueue[0-3] and LocalMessages[0-9]

// TODO:
// I keep losing actors like the one I am looking at, or his weapon.
// Solution:
// We should always be looking primarily at the Camera's ViewTarget.
// We should select the ViewTarget by calling ViewClass().

// CONSIDER: detect when P.ViewTarget changes, as a casual input from the viewer
// TODO: allow user command "!follow <nick>" to set the camera to follow a player (mode 2) e.g. for making a video.

// CONSIDER: Could continue to watch the first Corpse spawned after the player we are viewing dies (before/after they respawn).

// PROBLEM: some actors just go blank before they become None
//          we need to detect or avoid these
// maybe we can trust actors that have recently (re-)entered the pawnlist to be fresh

*/

// #define DEBUG(X); 
// #define DEBUG(X); Log("nBAS] "$X);
// #define DEBUG(X); if (bPrintDebugInfo) { Camera.ClientMessage(X); }
// #define DEBUG(X); if (bPrintDebugInfo) { Camera.ClientMessage("[nBAS] "$(X)); Log("[nBAS] "$(X)); }
// #define DEBUG(X); if (bPrintDebugInfo) { Camera.ClientMessage("> "$(X)); Log("[nBAS "$GetDate()$"] "$(X)); }
// #define DEBUG(X); if (bPrintDebugInfo) { Camera.ClientMessage("> "$(X)); Log("[nBAS "$Int(Level.TimeSeconds)$"] "$(X)); }
// #define Log(X); 
// #define Log(X); DEBUG(X);

#define DEBUG(X); if (bPrintDebugInfo) { Log("[nBAS "$Int(Level.TimeSeconds)$"] "$(X)); }
#define INFO(X); if (bPrintDebugInfo) { Camera.ClientMessage("> "$(X)); Log("[nBAS "$Int(Level.TimeSeconds)$"] "$(X)); }



// class nBAutoSpectate extends Info;
class nBAutoSpectate extends Mutator config(nBAutoSpectate);

var PlayerPawn Camera;
var Rotator targRot;
var Rotator myRot;
var Rotator prevRot;
var bool bfoundflag;
var bool bviewingFC;
var string blueFC;
var string redFC;
#ifdef PKATB
var bool bautoFC;
#endif
var bool bAFCOFFmsg;
var bool bAFCONmsg;
// var private bool ;
// var private int ;
// var private int ;
var int ydelta;
var int pdelta;
// var private int ;
// var private int ;
var int Offset;

// nB:
var config bool bPrintDebugInfo;
var config bool bCameraPanning;
var config bool bSwitchCamera;
var config float CameraSwitchSeconds;
var config bool bStickWithFC;
var config bool bDoViewClass;
var config bool bTiltWhenPointing;

// var String LastList;
var Actor LastNewActor;

var float LastSwitchTime;
var float deltaYaw, deltaPitch, deltaFOV, fov;
var Actor FollowActor, LookActor;

var bool bCheckingForInterestingTarget;
var bool bDoneViewClass;

var int CameraMode;

var String RecommendedPlayerName;


#ifdef ENABLE_EVENT_RECORD_REPLAY

var config bool bFlashing;
var config bool bLogConsole; // entirely optional
var config bool bRecordEvents;
var config bool bReplayEvents;

var String LastProgressMessage[10];

var String LastConsoleLine;

var Color colGreen,colRed,colYellow,colBlue;

struct LoggedEvent {
	var String Map;
	var float Time;
	var String Primary;
	var String Secondary;
	var vector PrimaryLocation;
	var vector SecondaryLocation;
	var String Line;
};

// var config String ConsoleLog[4096];
// var config String EventLog[4096];
var config LoggedEvent EventLog[4096];
var config int eventCount;

// var config String AllPlayerNames;

var int NextEventEndTime;
var int CurrentEventi;

#endif

function int fun1 (int X, int Y, out int diff) {
	local int newdiff;

	diff = X - Y;
	newdiff = diff;
	if ( (newdiff > 20000) || (newdiff < -20000) )
	{
		newdiff = 20000;
	}
	return newdiff * newdiff / 500000;
}

function PlayerPawn GetRandomPlayer() {
	local PlayerPawn p;
	local int count;
	foreach AllActors(class'PlayerPawn',p)
		count++;
	count = count * FRand();
	foreach AllActors(class'PlayerPawn',p) {
		count--;
		if (count < 0)
			return p;
	}
	return p;
}

function bool isInteresting(Actor a) {
	if (a.IsA('Spectator'))
		return false;
	return (
		// a.IsA('FlagBase')
		// a.IsA('CTFFlag') ||
		// a.IsA('Flag')
		// || (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
		// || (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
		// || a.IsA('HealthPack')
		// a.IsA('Projectile')
		isAGoodProjectile(A)
		|| a.IsA('PlayerPawn')
		|| a.IsA('Bot')
		// || a.IsA('Pawn')
		|| (a.IsA('Weapon') && Inventory(a).bTossedOut)
		// || a.IsA('NavigationPoint')
		|| a.IsA('Effect')
		// || a.IsA('Carcass')
	);
}

function int CountAllActors() {
	local int count;
	local Actor a;
	#ifdef LIST_ACTORS
	local String list;
	#endif
	foreach AllActors(class'Actor',a) {
		count++;
		#ifdef LIST_ACTORS
		list = list $ a.Name $ " ";
		#endif
	}
	#ifdef LIST_ACTORS
	// if (count < 10)
		// DEBUG(count$" actors: "$list);
	// else
		// DEBUG(count$" actors.");
	#endif
	return count;
}

function int CountInterestingActors() {
	local int count;
	local Actor a;
	#ifdef LIST_ACTORS
	local String list;
	#endif
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			count++;
			#ifdef LIST_ACTORS
			list = list $ a.Name $ " ";
			#endif
		}
	}
	#ifdef LIST_ACTORS
	// if (count < 10)
		// DEBUG(count$" actors: "$list);
	// else
		// DEBUG(count$" actors.");
	#endif
	return count;
}

function Actor GetLastViewClass() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
			// DEBUG("Re-using "$NameActor(a));
			if (FRand()<0.2)
				RecommendedPlayerName = ""; // i think i'll only use it once, then discard it.
			return a;
		}
	}
	return None;
}

// #define GetRandomActor GetRandomActorReal
// #define GetRandomActor GetLastViewClass
function Actor GetRandomActor() {
	local Actor a;
	a = GetLastViewClass();
	if (a == None)
		a = GetRandomActorReal();
	return a;
}

function Actor GetRandomActorReal() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (isFC(a) && FRand()<0.5) {
			return a;
		}
	}

	if (RecommendedPlayerName != ""/* && FRand()<0.2*/) {
		foreach AllActors(class'Actor',a) {
			if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
				// DEBUG("Re-using "$NameActor(a));
				if (FRand()<0.2)
					RecommendedPlayerName = ""; // i think i'll only use it once, then discard it.
				return a;
			}
		}
		// RecommendedPlayerName = ""; // it has failed me now, and we don't want it to last forever anyway
	}

	count = CountInterestingActors();
	chosen = count*FRand();
	// Log("Chose "$chosen$" / "$count);
	// DEBUG("Chose "$Int(count*FRand())$" / "$count);
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			chosen--;
			if (chosen < 0)
				return a;
		}
	}
	return a;
}

function bool isFC(Actor a) {
	return ( ( a != None ) &&
		( Pawn(a) != None ) &&
		( Pawn(a).PlayerReplicationInfo != None ) &&
		( Pawn(a).PlayerReplicationInfo.HasFlag != None )
	);
}

// TODO: To get the most action, find a "busy" Actor to view.
// one e.g.: find average location of all pawns; find actor closest to this, to get close into the action
// or: a big lonely map, but 3 players are in the same room; detect that (k-means on distance)

	/*
	Target = GetRandomActor(class'FlagBase');
	if (Target == None)
		Target = GetRandomActor(class'PlayerPawn');
	if (Target == None)
		Target = GetRandomActor(class'ShockRifle');
	if (Target == None)
		Target = GetRandomActor(class'NavigationPoint');
	*/

function bool isCameraModeAllowed() {
	return (CameraMode>=0 && CameraMode<=6);
}

function CreateNewCamera(Actor a, optional Actor b) {
	local String report;

	// if (Level.TimeSeconds < LastSwitchTime + CameraSwitchSeconds)
		// return;

	LastSwitchTime = Level.TimeSeconds;
	bCheckingForInterestingTarget = False;
	bDoneViewClass = False;

	if (GetLastViewClass() != None) {
		a = GetLastViewClass();
	}
	if (bStickWithFC) {
		if (isFC(LookActor)) {
			a = LookActor;
		}
		if (isFC(FollowActor)) {
			a = FollowActor;
		}
		if (isFC(Camera.ViewTarget)) {
			a = Camera.ViewTarget;
		}
	}

	report = "";

	// CameraMode = FRand()*6;
	while (true) {
		CameraMode = CameraMode+1;
		if (CameraMode>6)
			CameraMode=0;
		if (isCameraModeAllowed())
			break;
	}

	Camera.ViewTarget = None;
	FollowActor = None;
	LookActor = None;
	NewCamera();
	if (CameraMode == 0) {
		Camera.ViewTarget = a;
		report = "[0] Viewing from "$NameActor(a);
	}
	if (CameraMode == 1) {
		FollowActor = a;
		report = "[1] Following "$NameActor(FollowActor);
		Camera.ViewRotation.Pitch += 8192/2;
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
	}
	if (CameraMode == 2) {
		FollowActor = a;
		deltaYaw /= 4;
		deltaPitch /= 3;
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( Camera.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
		Camera.ViewRotation = rotator(FollowActor.Location-Camera.Location);
		report = "[2] Camera following "$NameActor(a);
	}
	if (CameraMode == 3) {
		NiceCamera();
		deltaYaw /= 4;
		deltaPitch /= 3;
		deltaFOV *= 2;
		// A = FindBusiestActor();
		A = FindClosestInterestingActor(,CentreOfMass());
		Camera.ViewTarget = None;
		// Camera.SetLocation( A.Location );
		// Camera.ViewRotation = rotator(CentreOfMass() - Camera.Location);
		// Camera.SetLocation( A.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,16) );
		Camera.SetLocation( FindGoodCameraSpot(A.Location,96,-8+FRand()*96) );
		// FollowActor = FindClosestInterestingActor(A);
		FollowActor = A;
		// report = "[3] Camera panning from "$NameActor(A)$" looking at "$NameActor(FollowActor);
		report = "[3] Camera panning on "$NameActor(FollowActor);
	}
	if (CameraMode == 4) {
		FollowActor = a;
		LookActor = b;
		if (LookActor == None || FRand()<0.5) {
			LookActor = FindClosestInterestingActor(FollowActor);
		}
		Camera.ViewRotation = rotator(LookActor.Location - FollowActor.Location);
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,16) );
		// report = "[4] Following "$NameActor(FollowActor)$" Facing "$NameActor(LookActor);
		report = "[4] Following "$NameActor(FollowActor)$"";
	}
	if (CameraMode == 5) {
		Camera.ViewTarget = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(Camera.ViewTarget);
		}
		report = "[5] Viewing from "$NameActor(a)$" Looking at "$NameActor(LookActor);
	}
	if (CameraMode == 6) {
		Camera.ViewTarget = None;
		FollowActor = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(Camera.ViewTarget);
		}
		if (!CanSee(FollowActor.Location,Camera.Location)) {
			Camera.SetLocation( FollowActor.Location + vect(0,0,64) );
			Camera.SetRotation( rotator(LookActor.Location - Camera.Location) );
		}
		report = "[6] Viewing from behind "$NameActor(FollowActor)$" To "$NameActor(LookActor);
	}

	Camera.bBehindView = ( Camera.ViewTarget != None );
	if (Camera.ViewTarget != None) {
		Camera.ViewTarget.BecomeViewTarget();
	}

		/*

		// Old methods:

		if (Camera.IsA('Spectator')) {
			// Spectator(Camera).bChaseCam = (FRand() < 0.80);
			// report = "(chase="$Spectator(Camera).bChaseCam$") " $ report;
		}

		// Shall we focus?
		if (FRand()<0.5) {
			FollowActor = None;
		}
		if (b != None) {
			FollowActor = b;
		}
		if (FRand()<0.25 || (FollowActor == None && FRand()<0.5)) {
			// FollowActor = FindClosestActor(Camera.ViewTarget);
			// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"PlayerPawn");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"Bot");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"Projectile");
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Pawn');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Bot');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Projectile');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'PlayerPawn');
			FollowActor = FindClosestInterestingActor(Camera.ViewTarget);
			if (FollowActor == None) {
				report = "[FindClosestInterestingActor gave "$FollowActor$"] ";
			// } else if (!isInteresting(FollowActor)) {
				// report = "[Dropped uninteresting " $ FollowActor $ "] ";
				// FollowActor = None;
			}
		// } else {
			// FollowActor = None;
		}
		if (FRand()<0.25) {
			FollowActor = Camera.ViewTarget;
			Camera.ViewTarget = None;
		}

		NewCamera();

		if (FollowActor != None) {
			// Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + vect(0,0,48.0));
			Camera.ViewRotation = rotator(FollowActor.Location - Camera.Location);
			Camera.SetLocation(FollowActor.Location - 96*Vector(Camera.ViewRotation) + FRand()*vect(0,0,48.0));
			if (FRand()<0.25) {
				Camera.ViewTarget = None;
			}
		} else {
			// I think the ViewTarget will set our location/camera-point later,
			// but our position can be used to set a good initial rotation now.
			Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + FRand()*vect(0,0,48.0));
		}

		// Set a good initial rotation:
		if (FRand()<0.5) {
			Camera.ViewRotation = rotator(CentreOfMass() - Camera.Location);
		}

		// In case the camera wants to detach:
		// Camera.SetLocation(Target.Location);
		// Camera.SetRotation(Target.Rotation); // not always facing upwards!

		*/

	/*
	if (FRand()<0.05) {
		if (Camera.ViewTarget != None) {
			Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + vect(0,0,48.0));
			// Camera.SetLocation(Camera.ViewTarget.Location - 96 * Vector(Camera.ViewRotation));
			Camera.ViewTarget = None;
			report = "External camera! " $ report;
		}
	}
	*/

	// if (Camera.ViewTarget != None)
		// report = report $ "Watching: " $ Camera.ViewTarget.Name $ " ";
	// if (FollowActor != None)
		// report = report $ "Following: " $ FollowActor.Name $ " ";

	// report = report $ " ";

	// report = report $ " [/"$CountInterestingActors()$"]";
	// report = "[" $ CountInterestingActors() $ "] " $ report;

	// report = "[" $ getTeamCounts() $ "] " $ report;
	// report = "[" $ getTeamCounts() $ "/" $ CountInterestingActors() $ "] " $ report;

	report = report $ " {"$CountInterestingActors()$"/"$CountAllActors()$"}";

	DEBUG(report);
	// Log(report);

}

// Just for curiousity/debugging purposes.
function String getTeamCounts() {
	local Actor A;
	local int countRed,countBlue;
	foreach AllActors(class'Actor', A) {
		// if (A.IsA('Pawn')) {
		if (A.IsA('Bot') || A.IsA('PlayerPawn')) {
			if (Pawn(A).PlayerReplicationInfo != None) {
				if (Pawn(A).PlayerReplicationInfo.Team == 0) {
					countRed++;
				}
				if (Pawn(A).PlayerReplicationInfo.Team == 1) {
					countBlue++;
				}
			}
		}
	}
	// return "Red: "$countRed$" | Blue: "$countBlue;
	return countRed $ "v" $countBlue;
}

// TODO
function Actor FindPlayerWithMostEnemiesNearby() {
	return None;
}

function String NameActor(Actor a) {
	local String append;
	if (A == None)
		return "None";
	// if (A.IsA('Pawn') && Pawn(A).PlayerReplicationInfo != None)
		// return PlayerPawn(A).PlayerReplicationInfo.PlayerName; // no good: "" for bots online
	if (A.IsA('PlayerPawn'))
		//// This works, if we want to use it:
		// if (PlayerPawn(A).PlayerReplicationInfo.Score > 0)
			// append = " (with " $ Int(PlayerPawn(A).PlayerReplicationInfo.Score) $ " frags)";
			append = " (" $ Int(PlayerPawn(A).PlayerReplicationInfo.Score) $ ")";
		return PlayerPawn(A).PlayerReplicationInfo.PlayerName $ append;
	if (A.IsA('Bot'))
		return ""$Bot(A).getHumanName()$"b";
	if (A.IsA('Projectile'))
		return A.Name$"("$Projectile(Camera.ViewTarget).Owner$")";
	return ""$A.Name;
}

function Vector CentreOfMass() {
	local int count;
	local Vector centre;
	local Actor A;
	count = 0;
	centre = vect(0,0,0);
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			count++;
			centre = centre*(Float(count-1)/Float(count)) + A.Location*(1.0/Float(count));
		}
	}
	return centre;
}

function float FFRand() { // returns a number between 0.5 and 1.0
	return 0.5 + 0.5 * FRand();
}

function float SgnRand() { // returns -1.0 or +1.0 randomly
	if (FRand()<0.5) {
		return 1.0;
	} else {
		return -1.0;
	}
}

function NewCamera() {

	#ifndef NO_CHANGE_ANGLE
	// Camera.ViewRotation.Yaw = 8192*8*(FRand()-0.5);
	// // Camera.ViewRotation.Pitch = 8192*0.5*(FRand()-0.3);
	// Camera.ViewRotation.Pitch = 8192*0.5*(FRand()-0.7);
	Camera.ViewRotation.Yaw = 8192*8*FFRand()*SgnRand();
	Camera.ViewRotation.Pitch = 8192*0.8*FFRand()*SgnRand();
	Camera.ViewRotation.Roll = 0;
	Camera.DesiredFOV = 90 + 30 * FRand();
	// Camera.ConsoleCommand("FOV "$Camera.DesiredFOV); // seems to be needed! NO it causes ini file writes!
	#endif

	// deltaYaw = 400*FFRand()*SgnRand();
	deltaYaw = 400*(FRand()-0.5);
	deltaPitch = -Sgn(Camera.ViewRotation.Pitch) * 40*FRand();
	// deltaPitch = 30*(FRand()-0.7);
	deltaFOV = 0.2*(FRand()-0.5);

	bTiltWhenPointing = (FRand() < 0.1);

}

function Actor FindBusiestActor() {
	local Actor A,B,bestActor;
	local float distance,bestDistance;
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			distance = 0;
			foreach AllActors(class'Actor', B) {
				distance = distance + VSize(A.Location-B.Location);
			}
			if (bestActor == None || distance<bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

function NiceCamera() {
	local Actor A;

}

function PointTowardsActor(Pawn P, Actor Target) {
	// RotateTowards(Camera.ViewRotation,rotator(Target.Location-P.Location));
	PointTowardsLocation(P,Target.Location);
}

function PointTowardsLocation(Pawn P, Vector L) {
	// RotateTowards(Camera.ViewRotation,rotator(L-P.Location));
	local rotator RB;
	RB = rotator(L-P.Location);
	P.ViewRotation.yaw = RotateAngle(P.ViewRotation.yaw, RB.yaw);
	P.ViewRotation.pitch = RotateAngle(P.ViewRotation.pitch, RB.pitch);
	// For some extra fun, we roll the camera if it is not yet pointing at the target:
	if (bTiltWhenPointing) {
		P.ViewRotation.roll = (P.ViewRotation.yaw-RB.yaw) + (P.ViewRotation.pitch-RB.pitch);
		// Really bad!!:  (Makes me wonder what the above is doing!)
		// P.ViewRotation.roll = 0.6 * ( (P.ViewRotation.yaw-RB.yaw) + (P.ViewRotation.pitch-RB.pitch) );
	}
}

/*
function RotateTowards(rotator RA, rotator RB) {
	RA.yaw = RotateAngle(RA.yaw, RB.yaw);
	RA.pitch = RotateAngle(RA.pitch, RB.pitch);
}
*/

function float RotateAngle(float a, float b) {
	while (a<0)
		a+=65536.0;
	while (a>=65536)
		a-=65536.0;
	while (b<0)
		b+=65536.0;
	while (b>=65536)
		b-=65536.0;
	if ( b-a > 65536/2) {
		b -= 65536.0;
	}
	if ( a-b > 65536/2) {
		a -= 65536.0;
	}
	return a * 0.92 + b * 0.08;
}

function bool LosingNetOn(Actor a) {
	if (a == None)
		return true;
	if (a.Location == vect(0,0,0))
		return true;
	return false;
}

function GetRandomCameraNow() {
	CreateNewCamera(GetRandomActor());
}

function MovePawnTowardsLocation(Pawn p, Vector NewLocation, float amount) {
/*
	while (amount<1) {
		NewLocation = p.Location * (1.0-amount) + NewLocation * amount;
		if (p.SetLocation(NewLocation))
			break;
		amount = amount + 0.05;
	}
*/
	p.SetLocation( p.Location * (1.0-amount) + NewLocation * amount );
}

// #define DontLose(X) if (X==None) { DEBUG("Lost X "$X); GetRandomCameraNow(); }
// #define DontLose(X); 
// #define DontLose(X,Y); if (LosingNetOn(X)) { DEBUG("Losing " $ Y); GetRandomCameraNow(); }
// TODO: since X==None, Y should be a stored string that described X.
/*
function DontLose(Actor X,String Y) {
	if (LosingNetOn(X)) {
		FlashMessageToPlayer(Camera,"LosingNetOn " $ Y,colBlue,8,0.5);
		if (bSwitchCamera)
			GetRandomCameraNow();
	}
}
*/
#define DontLose(X,Y); if (LosingNetOn(X)) { DEBUG("Losing " $ Y); if (bSwitchCamera) { GetRandomCameraNow(); } return; }

function DeltaCamera(float Delta) {

	local Actor HitOut;
	local Vector HitLocation,HitNormal;
	local Rotator followTarget;
	local Vector TargetLocation,NewLocation;

	local bool doNotPan;

	if (CameraMode == 0) {
		DontLose(Camera.ViewTarget,"Camera.ViewTarget");
	}
	if (CameraMode == 1) {
		DontLose(FollowActor,"FollowActor");
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(FollowActor.Location - Camera.Location);
		// // Camera.ViewRotation.yaw   = 8192*4 + (Camera.ViewRotation.yaw-8192*4)   * 0.99 + (followTarget.yaw-8192*4)   * 0.01;
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.95 + followTarget.yaw * 0.05;
		// Camera.SetLocation( FollowActor.Location - 128*Vector(Camera.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 24;
		MovePawnTowardsLocation(Camera,NewLocation,1.0);
		// NewLocation = Camera.Location * 0.0 + TargetLocation * 1.0;
		// Camera.SetLocation(NewLocation);
		// Camera.ClientSetLocation(NewLocation,Camera.ViewRotation);
		// doNotPan = true;
	}
	if (CameraMode == 2) {
		DontLose(FollowActor,"FollowActor");
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(FollowActor.Location - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		// Always points down: Camera.ViewRotation.pitch = Camera.ViewRotation.pitch * 0.999 + followTarget.pitch * 0.001;
		doNotPan = true;
	}
	if (CameraMode == 3) {
		DontLose(FollowActor,"FollowActor");
		// DONE: if this never works, try following FollowActor instead, just using the nice setup we have.
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 48;
		MovePawnTowardsLocation(Camera,TargetLocation,0.2);
		// NewLocation = Camera.Location * 0.8 + TargetLocation * 0.2;
		// Camera.SetLocation(NewLocation);
		PointTowardsLocation(Camera,CentreOfMass());
		// followTarget = rotator(CentreOfMass() - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		if (!CanSee(CentreOfMass(),Camera.Location) && FRand()<0.1) {
			DEBUG("CanSee failed - Forcing FollowActor=None");
			FollowActor = None;
		}
	}
	if (CameraMode == 4) {
		DontLose(FollowActor,"FollowActor");
		// DontLose(LookActor,LookActor);
		// Camera.SetLocation( FollowActor.Location - 128*Vector(Camera.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 64;
		// NewLocation = Camera.Location * 0.9 + TargetLocation * 0.1;
		MovePawnTowardsLocation(Camera,TargetLocation,0.02);
		// Camera.SetLocation(NewLocation);
		// Camera.ClientSetLocation(NewLocation,Camera.ViewRotation);
		// PointTowardsActor(Camera,LookActor);
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(LookActor.Location - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
	}
	if (CameraMode == 5) {
		DontLose(Camera.ViewTarget,"Camera.ViewTarget");
		DontLose(LookActor,"LookActor");
		// PointTowardsActor(Camera,FollowActor);
		PointTowardsActor(Camera,LookActor);
		// followTarget = rotator(FollowActor.Location - Camera.ViewTarget.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
	}
	if (CameraMode == 6) {
		DontLose(FollowActor,"FollowActor");
		DontLose(LookActor,"LookActor");
		// PointTowardsLocation(Camera, (LookActor.Location + FollowActor.Location) / 2.0 );
		PointTowardsLocation(Camera, LookActor.Location);
		TargetLocation = FollowActor.Location - Normal(LookActor.Location-FollowActor.Location)*180 + vect(0,0,1)*64;

		MovePawnTowardsLocation(Camera,TargetLocation,0.90);
		/*
		// #ifdef ENABLE_EVENT_RECORD_REPLAY
		if (CurrentEventi > 0) {
			#define timeToEvent (LoggedEvent[CurrentEventi].Time - Level.TimeSeconds)
			#define moveAmountTimeBased Chop(0.01,1.0,timeToEvent/5.0)
			MovePawnTowardsLocation(Camera, TargetLocation, moveAmountTimeBased);
			
		}
		// #endif ENABLE_EVENT_RECORD_REPLAY
		*/

		// followTarget = rotator(FollowActor.Location - Camera.ViewTarget.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
	}

	// if (Camera.ViewTarget != None) {
	if (bCameraPanning && !doNotPan) { // && FollowActor == None) {
		Camera.ViewRotation.Yaw += deltaYaw;
		Camera.ViewRotation.Pitch += deltaPitch;
		// Camera.ConsoleCommand("FOV "$Camera.DesiredFOV); // seems to be needed! NO it causes ini file writes!
		deltaYaw = deltaYaw * 0.998;
		deltaPitch = deltaPitch * 0.998;
	}
	if (bCameraPanning) {
		Camera.DesiredFOV = Camera.DesiredFOV + deltaFOV;
		deltaFOV = deltaFOV * 0.998;
	}

	// if (FollowActor != None) {
		// Camera.ViewRotation = rotator(FollowActor.Location - Camera.Location);
		// // Camera.SetRotation(rotator(FollowActor.Location - Camera.Location));
		/*
		HitActor = Trace(HitLocation,HitNormal,FollowActor.Location+128*Vector(Camera.ViewRotation),Camera.Location+16*Vector(Camera.ViewRotation),true);
		if (HitActor != FollowActor) {
			DEBUG("Lost follow on "$FollowActor.Name$" got "$HitActor);
			FollowActor = None;
		}
		*/
	// }

	if (!CanSeeActors(Camera,Camera.ViewTarget) && !CanSeeActors(Camera,FollowActor) && !CanSeeActors(Camera,LookActor) && FRand()<0.1) {
		Camera.ClientMessage("Lost line-of-sight to "$Camera.ViewTarget$", "$FollowActor$" and "$LookActor$"!");
		if (bSwitchCamera)
			GetRandomCameraNow();
	}

}

function float Chop(float Lowest, float Highest, float In) {
	if (In < Lowest)
		return Lowest;
	if (In > Highest)
		return Highest;
	return In;
}

function bool CanSeeActors(Actor from, Actor to) {
	if (from == None || to == None)
		return false;
	return CanSee(from.Location,to.Location);
}

function bool CanSee(Vector from, Vector to) {
	local Vector HitLocation, HitNormal;
	// CollisionRadius=1;
	// CollisionHeight=1;
	SetCollisionSize(1,1);
	HitActor = Trace(HitLocation,HitNormal,to,from,false);
	if (HitActor == None)
		return true;
	else
		return false;
}

/*
function CheckForNewActors() {
	local Actor A;
	local String NewList;
	NewList=" "; // BUG TODO: in online play actors will sometimes leave the list then return to it later; so we need an AllActorsEverList
	foreach AllActors(class'Actor', A) {
		NewList = NewList $ A.Name $ " ";
		if (LastList != "") {
			// BUG TODO: this becomes inefficient
			if (InStr(LastList," "$A.Name$" ")<0) {
				HandleNewActor(A);
			}
		}
	}
	LastList = NewList;
}
*/

function CheckForNewActors() {
	local Actor A;
	local bool pastLast;
	foreach AllActors(class'Actor', A) {
		if (pastLast) {
			HandleNewActor(A);
		}
		if (A == LastNewActor) {
			pastLast = true;
		}
	}
	LastNewActor = A;
}

function float Sgn(float num) {
	if (num>0)
		return +1;
	if (num<0)
		return -1;
	return 0;
}

function bool isAGoodProjectile(Actor A) {
	return (A.isA('flakslug') || A.isA('ShockProj') || A.isA('Rocket'));
}

function HandleNewActor(Actor A) {
	if (bCheckingForInterestingTarget) {
		// if (isInteresting(A)) {
		// if (A.IsA('Projectile') && Instr(""$A.Name,"Trans")<0) {
		if (
			isAGoodProjectile(A)
			// || A.IsA('Carcass')
			|| (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
			|| (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
			|| (a.IsA('Armor') && !Pickup(a).bHeldItem)
			|| a.IsA('Effect')
		) {
			// Log("New Actor: "$A);
			DEBUG("New Actor: "$A);
			CreateNewCamera(A,A.Owner);
		}
	}
}

/*
function CheckForInterestingTarget() {
	// local Actor A;
	// local Actor LatestProjectile;
	// New projectile or new damage will force camera-switch.
	if (!bCheckingForInterestingTarget) {
		bCheckingForInterestingTarget = True;
		// LastList = "";
	} else {
		CheckForNewActors();
		// LatestProjectile = None;
		// foreach AllActors(class'Projectile', A) {
			// LatestProjectile = A;
		// }
	}
}
*/

#ifdef ENABLE_EVENT_RECORD_REPLAY

function RecordEvents() {
	// local int i;
	// local PlayerPawn P;
	// local string comp;
	// local ChallengeHUD ch;
	// local Actor A;
	// local Console C;
	local String line;
	local int wordCount,i;
	local String words[256];
	local String word;
	local LoggedEvent ev;
	local Color msgCol;
	local Pawn p;

		// TODO CONSIDER BUG: Sometimes events occur with a player that we cannot find in the current Actor list (using FindPlayerNamed()).  (e.g. someone captures a flag beyond our view)
		// Is it worthwhile recording these events?  There may not be much to see at their location.

	line = Camera.Player.Console.MsgText[Camera.Player.Console.TopLine];

	if (line != LastConsoleLine) {
		// new console line

		if (bLogConsole)
			Log("[CONSOLE] ("$Int(Level.TimeSeconds)$") "$line);

		if (!StrStartsWith(line,"> ")) { // prevent infinite loop detecting its own output!

			// Can we find players in the line?  If so, fill ev.Primary and ev.Secondary:
			wordCount = SplitString(line," ",words);
			for (i=0;i<wordCount;i++) {
				word = words[i];
				// if (StrEndsWith(word,"\'s"))
				if (Right(word,2) == "\'s")
					word = StrBeforeLast(word,"\'s");
				// if (StrEndsWith(word,"."))
					// word = StrBeforeLast(word,".");
				// if (StrEndsWith(word,"!"))
					// word = StrBeforeLast(word,"!");
				// Log("Seeking \""$word$"\"");
				p = FindPlayerNamed(word);
				// DEBUG("Got player: "$p);
				if (p != None) { // player can currently be seen in the game
					if (ev.Primary == "") {
						ev.Primary = word;
						ev.PrimaryLocation = p.Location;
					} else {
						ev.Secondary = word;
						ev.SecondaryLocation = p.Location;

						// Different death messages for various weapons display the player names in different orders.
						// We just randomly switch the two players.
						if (FRand()<0.5) {
							ev.Secondary = ev.Primary;
							ev.SecondaryLocation = ev.PrimaryLocation;
							ev.Primary = word;
							ev.PrimaryLocation = p.Location;
						}

					}
				}
			}

			// TODO: We might want to accept only Primary.
			if (ev.Primary != "" && ev.Secondary != "") {

				// NOTE BUG: We should not loop this, or ev might start non-empty!
				ev.Map = StrBefore(""$Self,".");
				ev.Time = Level.TimeSeconds;
				ev.Line = line;

				// DEBUG("[O] RECORD ("$ev.Primary$","$ev.Secondary$"): " $ line );
				INFO("[O] RECORD ("$ev.Primary$","$ev.Secondary$")");
				FlashMessageToPlayer(Camera,"[O] " $ ev.Primary$" v "$ev.Secondary,colRed,7,1.0);

				// Once database is full, it overwrites old events randomly
				if (eventCount >= 4096) {
					EventLog[Int(FRand()*4096)] = ev;
				} else {
					EventLog[eventCount] = ev;
					eventCount++;
				}
				if (FRand()<0.1) {
					FlashMessageToPlayer(Camera,"[O] SAVING "$ev.Secondary,colRed,6,1.0);
					DEBUG("[O] SAVING ...");
					SaveConfig();
					INFO("[O] DONE");
				}

			}

		}
		LastConsoleLine = line;
	}

	// if (InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]," killed ") >= 0) {
		// if (!StrContains(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"FRAG!")) { // prevent infinite loop detecting its own output!
			// INFO("Detected FRAG! " $ Camera.Player.Console.MsgText[Camera.Player.Console.TopLine] );
		// }
	// }

	// foreach AllActors(class'Actor', A) {
		// if (A.isA('Console'))
			// C = Console(A); // Error, Cast from 'Actor' to 'Console' will always fail
		// else
			// continue;
		// line = C.MsgText[C.TopLine];
	// OK I haven't found a way to read the consoles of other players, it always did seem pretty unrealistic :P

		// if (InStr(line," killed ") >= 0) {
			// if (!StrContains(line,"FRAG!")) { // prevent infinite loop detecting its own output!

	// }

	// foreach AllActors(class'PlayerPawn', P) {
		/*
		// Checking ProgressMessages seems useless; they only pick up XOL's flashed hiscores.
		// I wonder though if we can still access the ineyes player's console even when we are viewing 3rdperson.
		if (P.myHUD == None)
			continue;
		ch = ChallengeHUD(P.myHUD);
		if (ch == None)
			continue;
		if (ch.CurrentMessage != LastProgressMessage[0]) {
			INFO("Detected line: " $ ch.CurrentMessage);
			LastProgressMessage[0] = ch.CurrentMessage;
		}
		*/
		/*
		// There is no such thing P.Console or ch.Console
		if (InStr(ch.Console.MsgText[ch.Console.TopLine]," killed ") >= 0) {
			if (!StrContains(ch.Console.MsgText[ch.Console.TopLine],"FRAG!")) { // prevent infinite loop detecting its own output! (less likely here)
				INFO("Detected FRAG! (from "$P.getHumanName()$"'s console) " $ ch.Console.MsgText[ch.Console.TopLine] );
			}
		}
		// ok screw this let's cheat
		*/
		// for (i=0;i<8;i++) {
			/*
			if (P.ProgressMessage[i] != "" && P.ProgressMessage[i] != LastProgressMessage[i]) {
				INFO("Detected line: " $ P.ProgressMessage[i]);
			}
			LastProgressMessage[i] = P.ProgressMessage[i];
			*/
			/*
			if (P.Console.GetMsgText(i) != LastConsoleMsg[i]) {
			}
			*/
		// These cause: Error, Context expression: Variable is too large (640 bytes, 255 max)
		/*
		for (i=0;i<10;i++) {
			if (ChallengeHUD(P.myHUD).LocalMessages[i] != LastProgressMessage[i]) {
				INFO("Detected line: " $ ChallengeHUD(P.myHUD).LocalMessages[i]);
			}
			LastProgressMessage[i] = ChallengeHUD(P.myHUD).LocalMessages[i];
		}
		for (i=0;i<10;i++) {
			comp = ch.LocalMessages[i];
			if (comp != LastProgressMessage[i]) {
				INFO("Detected line: " $ comp);
			}
			LastProgressMessage[i] = comp;
		}
		*/
	// }

}

function FlashMessageToPlayer(PlayerPawn p, string Msg, Color msgColor, optional int linenum, optional float duration) {
	// if (bPrintDebugInfo) { Log("[nBAS "$GetDate()$"] FlashMessageToPlayer("$p$",\""$Msg$"\",...)"); }
	p.SetProgressTime(duration);
	p.SetProgressColor(msgColor,linenum);
	p.SetProgressMessage(Msg,linenum);
}

function ReplayEvents() {
	local String mapname;
	local int i;
	local LoggedEvent CurrentEvent;
	local Color msgCol;
	local string report;

	CurrentEvent = EventLog[CurrentEventi];

	if (Level.TimeSeconds > CurrentEvent.Time + 1) {
		// We would like to find a new event
		if (FRand()<0.1) { // not every tick
			FindNewEvent();
			CurrentEvent = EventLog[CurrentEventi];
			NextEventEndTime = CurrentEvent.Time + 1; // not used
			// bRecordEvents = True/False;
		}
	}

	ReplayEvent(CurrentEvent);

	// if (FRand()<0.9) // not every tick
		// return;

	/*
	if (NextEventEndTime > Level.TimeSeconds) {
		// We are waiting for the last event to finish
		INFO("Waiting.");
		return;
	}
	*/

	// if (NextEventEndTime < CurrentEvent.Time + 2) {
		// // we are switching to a new event
	// }
	if (Int(Level.TimeSeconds) == Int(CurrentEvent.Time)) {
		// event is happening now!
	}

}

function FindNewEvent() {
	local String mapname;
	local int i;
	local LoggedEvent ev;
	
	mapname = StrBefore(""$Self,".");
	for (i=CurrentEventi+1;i<eventCount;i++) {
		ev = EventLog[i];
		// Log("[nBAS] Comparing "$ev.Map$" = "$mapname$" and "$(ev.Time+2)$" > "$Level.TimeSeconds);
		// ev.Map == None because my early recordings failed to record it
		if (
			(ev.Map == "None" || ev.Map == mapname)
			&& ev.Time > Level.TimeSeconds+1
			&& ev.Time < Level.TimeSeconds+15
			&& ev.Secondary != ""
		) {
			INFO("[>] REPLAY (+"$Int(ev.Time - Level.TimeSeconds)$"): "$Int(ev.TimeSeconds)$" $ev.Primary$" v "$ev.Secondary /*$" | REPORT: "$report*/ );
			CurrentEventi = i;
			bRecordEvents = False; // auto_record
			return; // don't look at any others
			// SwitchToEvent(ev);
			// ReplayEvent(ev);
		}
	}

	bRecordEvents = True; // auto_record

	if (FRand()<0.1)
		INFO("Failed to find actor for replay");

}

function ReplayEvent(LoggedEvent ev) {
	local String report;

	// CreateNewCamera();
	if (ev.Secondary == "") {
		// One-man event
		// Let's skip these:
		// continue;
		// NewCamera();
		if (FindPlayerNamed(ev.Primary) != None) {
			Camera.ViewTarget = FindPlayerNamed(ev.Primary);
			Camera.bBehindView = True;
			CameraMode = 0;
			report = "Got target "$FindPlayerNamed(ev.Primary);
		}
	} else {
		Camera.ViewTarget = None;
		Camera.bBehindView = False;
		if (FindPlayerNamed(ev.Primary) != None) {
			LookActor = FindPlayerNamed(ev.Primary);
			report = "Got primary "$LookActor;
		}
		if (FindPlayerNamed(ev.Secondary) != None) {
			FollowActor = FindPlayerNamed(ev.Secondary);
			report = report $ "Got secondary "$FollowActor;
			if (!CanSee(Camera.Location,FollowActor.Location)) {
				INFO("Had to move camera to see "$FollowActor);
				if (FollowActor != None) {
					Camera.SetLocation(FollowActor.Location);
				}
			}
		}
		CameraMode = 6;
		if (bFlashing && FRand()<0.1) {
			if (ev.Time > Level.TimeSeconds)
				FlashMessageToPlayer(Camera,"[>] ("$Left(""$Level.TimeSeconds,4)$") " $ ev.Primary$" v "$ev.Secondary $ " (" $ Int(ev.Time-Level.TimeSeconds+1) $ ")",colGreen,7,1.0);
			else
				FlashMessageToPlayer(Camera,"[_] ("$Left(""$Level.TimeSeconds,4)$") " $ ev.Primary$" v "$ev.Secondary $ " (" $ Int(ev.Time-Level.TimeSeconds+1) $ ")",colRed,7,1.0);
		}
	}

	/*
	if (ev.PrimaryLocation != vect(0,0,0)) {
		Camera.SetLocation(ev.PrimaryLocation);
	}
	if (ev.SecondaryLocation != vect(0,0,0)) {
		Camera.SetLocation(ev.SecondaryLocation);
	}
	*/

}

#endif

function CheckSwitchCamera() {

	local int i,j;
	local string report;

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds - 1) {
		// Start watching for actors which we want to catch on spawn (e.g. short-lived projectiles)
		bCheckingForInterestingTarget = True;
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 0) {
		// Camera.ConsoleCommand("ViewTeam"); // to keep fresh list of actors during online play
		// Camera.ViewClass(class'Pawn'); // to keep fresh list of actors during online play

		// TODO: turned off because of "Now viewing" detection:
		//       and back on again ;)
		// BUG: when online, this takes a little time to get back, *after* we switch cam :S
		// maybe we should detect "now viewing from" and *then* switch cam
		if (bDoViewClass && !bDoneViewClass && FRand()<0.2) {
			report = report $ "[From "$CountInterestingActors();
			// To keep a fresh list of actors during online play, we call ViewClass:
			/*
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Actor');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Actor');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Pawn');
			*/
			j = FRand()*12;
			for (i=0;i<j;i++) {
				if (Frand()<0.5)
					Camera.ViewClass(class'Pawn');
				else
					Camera.ViewClass(class'Actor');
			}
			bDoneViewClass = True;
		}
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 1) {
		GetRandomCameraNow(); // If we use the player selected by ViewTeam, ... ?
		// NewCamera();
			// I want to report this later, after some time for the info to come and go:
			// if (bDoneViewClass) {
				report = report $ " to "$CountInterestingActors()$"] ";
			// }
	}

	if (CameraMode != 3) {
		if (Camera.ViewTarget == None && FollowActor == None && LookActor == None) {
			report = report $ "LOST EVERYTHING! ";
			if (bDoViewClass) {
				Camera.ViewClass(class'Pawn');
			}
			GetRandomCameraNow();
		}
	} else {
		if (Camera.ViewTarget != None && LosingNetOn(Camera.ViewTarget)) {
			INFO("Losing: "$NameActor(Camera.ViewTarget));
		}
		if (FollowActor != None && LosingNetOn(FollowActor)) {
			INFO("Losing: "$NameActor(FollowActor));
		}
		if (LookActor != None && LosingNetOn(LookActor)) {
			INFO("Losing: "$NameActor(LookActor));
		}
	}

	if (report != "") {
		INFO(report);
	}

}

event Tick (float Delta) {
	local int i,j;
	// local int diffout;

	// if (FRand()<0.01) {
		// INFO("Tick delta="$Delta);
	// }

	// if (  !Camera.PlayerReplicationInfo.bIsSpectator )
	// if (!Camera.PlayerReplicationInfo.bIsSpectator && !Camera.bIsPlayer) {
		// return;
	// }

	#ifdef ENABLE_EVENT_RECORD_REPLAY
	if (bRecordEvents) {
		RecordEvents();
	}
	#endif

	CheckForNewActors();
	if (bSwitchCamera) {
		CheckSwitchCamera();
	}

	#ifdef ENABLE_EVENT_RECORD_REPLAY
	if (bReplayEvents) {
		ReplayEvents();
	}
	#endif

	DeltaCamera(Delta);

	// Maybe it's ok to have both == None (Spec free fly mode)
	/* if (Camera.ViewTarget == None && FollowActor == None) {
		if (FRand()<0.05) {
			INFO("LOST ViewTarget and FollowActor!");
			Camera.ConsoleCommand("ViewTeam");
			// bCheckingForInterestingTarget = True; CheckForNewActors();
			GetRandomCameraNow();
		}
	} */

	/*
	// if ( Camera.ViewTarget != None ) {
	// if ( Camera.ViewTarget == None ) {
		// if ( Pawn(Camera.ViewTarget) != None ) {
			// targRot = Pawn(Camera.ViewTarget).ViewRotation;
			// targRot.Yaw = targRot.Yaw*0.999 + FRand();
			// targRot.Pitch = targRot.Pitch*0.999 + FRand();
			// myRot = Camera.ViewRotation;
			// ydelta = fun1(targRot.Yaw,myRot.Yaw,diffout);
			// pdelta = fun1(targRot.Pitch,myRot.Pitch,diffout);
			// if (FRand()<0.01) {
	*/

			/*
			if ( ydelta == -9999 )
			{
				SendErrMsg();
				 // TODO: = True;
			}
			*/
			/*
			if ( Pawn(Camera.ViewTarget).Health > 0 )
			{
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					if ( ydelta + Camera.ViewRotation.Yaw > 65536 )
					{
						Camera.ViewRotation.Yaw = 0;
						return;
					}
					Camera.ViewRotation.Yaw += ydelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						if ( Camera.ViewRotation.Yaw - ydelta < 0 )
						{
							Camera.ViewRotation.Yaw = 65536;
							return;
						}
						Camera.ViewRotation.Yaw -= ydelta;
					}
				}
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					Camera.ViewRotation.Pitch += pdelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						Camera.ViewRotation.Pitch -= pdelta;
					}
				}
				if ( Camera.ViewRotation.Roll != 0 )
				{
					Camera.ViewRotation.Roll = 0;
				}
			}
			*/

	// for (i=0;i<Camera.Player.Console.TopLine;i++) {
	for (i=Camera.Player.Console.TopLine;i>=0;i--) {
		Offset = InStr(Camera.Player.Console.MsgText[i],"Now viewing from ");
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"Now viewing from ");
		if (Offset != -1) {
			// RecommendedPlayerName = Mid(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Len("Now viewing from "));
			RecommendedPlayerName = Mid(Camera.Player.Console.MsgText[i],Len("Now viewing from "));
			if (Mid(RecommendedPlayerName,0,1) == " ") // sometimes (always?) there is an extra space
				RecommendedPlayerName = Mid(RecommendedPlayerName,1);
			// INFO("OK got >"$RecommendedPlayerName$"<");
			// INFO("Got RecommendedPlayerName = >"$RecommendedPlayerName$"<");
			// Force a switch now:
			if (CameraMode != 0 && CameraMode != 5) {
				// We don't do it in mode 0 or 5 since they both *cause* "Now viewing from"
				// LastSwitchTime = Level.TimeSeconds - CameraSwitchSeconds + 2; // immediate switch seems no good - tended to put me in 1st person view
				// LastSwitchTime = Level.TimeSeconds - CameraSwitchSeconds; // turned it off anyway
			}
		}
	}

	/*
	// for (i=0;i<Camera.Player.Console.TopLine;i++) {
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]," inflicted mortal damage upon ");
		if (Offset != -1) {
			if (!StrContains(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"FRAG!")) { // prevent infinite loop detecting its own output!
				INFO("["$Level$"@"$Level.TimeSeconds$"] FRAG! "$Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]);
			}
		}
	// }
	*/

	#ifdef PKATB

	Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"mutate AFCOFF");
	if ( (Offset != -1) &&  !bAFCOFFmsg )
	{
		bautoFC = False;
		Camera.ClientMessage("Auto FC feature off");
		bAFCOFFmsg = True;
		bAFCONmsg = False;
	}
	Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"mutate AFCON");
	if ( (Offset != -1) &&  !bAFCONmsg )
	{
		bautoFC = True;
		Camera.ClientMessage("Auto FC feature on");
		bAFCOFFmsg = False;
		bAFCONmsg = True;
	}
		// TODO!
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"dropped the red flag!");
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"returns the red flag!");
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"You killed ");
	if ( bautoFC /* TODO: &&  ! */ )
	{
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"captured the red flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"captured the blue flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"has the red flag!");
		if ( Offset != -1 )
		{
			redFC = Left(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"has the blue flag!");
		if ( Offset != -1 )
		{
			redFC = Left(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"Failed to change view");

		/*
		if ( Offset != -1 )
		{
			redFC = "";
			blueFC = "";
		}
		if (  !bviewingFC )
		{
			if ( Camera.ViewTarget == None )
			{
				if ( redFC != "" )
				{
					ViewRedFC();
				} else {
					if ( blueFC != "" )
					{
						ViewBlueFC();
					}
				}
			} else {
				if ( Pawn(Camera.ViewTarget) == None )
				{
					if ( redFC != "" )
					{
						ViewRedFC();
					} else {
						if ( blueFC != "" )
						{
							ViewBlueFC();
						}
					}
				} else {
					if ( Pawn(Camera.ViewTarget).PlayerReplicationInfo.HasFlag == None )
					{
						if ( redFC == Pawn(Camera.ViewTarget).PlayerReplicationInfo.PlayerName )
						{
							redFC = "";
						} else {
							if ( FindPlayer(redFC) )
							{
								ViewRedFC();
							} else {
								if ( blueFC == Pawn(Camera.ViewTarget).PlayerReplicationInfo.PlayerName )
								{
									blueFC = "";
								} else {
									if ( FindPlayer(blueFC) )
									{
										ViewBlueFC();
									}
								}
							}
						}
					}
				}
			}
			SetTimer(0.31,False);
			bviewingFC = True;
		}
		*/
	}

	#endif

}





// from AutoSpectate - only if they have the flag
/*
function bool FindPlayer(string S) {
	local int i;
	local TournamentGameReplicationInfo ptgri;

	ptgri = TournamentGameReplicationInfo(Camera.GameReplicationInfo);
	for (i=0;i<32;i++) {
		if ( ptgri.PRIArray[i] == None ) {
			continue;
		}
		if ( ptgri.PRIArray[i].bIsSpectator ) {
			continue;
		}
		if ( ptgri.PRIArray[i].HasFlag != None ) {
			if ( ptgri.PRIArray[i].PlayerName == S ) {
				return True;
			} else {
				return False;
			}
		}
	}
	return False;
}
*/


/*
// Find player by name
// In first-person demo playback, only saw self =(
function Pawn FindPlayerNamed(String str) {
	local Pawn p;
	for (p=Level.PawnList; p!=None; p=p.NextPawn) {
		if (p.IsA('PlayerPawn') || p.IsA('Bot')) {
			INFO("nBAutoSpectate.FindPlayerNamed(\""$str$"\"): comparing to \""$p.getHumanName()$"\"");
			if (p.getHumanName() == str) {
				return p;
			}
		}
	}
	return None;
}
*/

function PlayerPawn FindPlayerNamed(string S) {
	local int i;
	local TournamentGameReplicationInfo ptgri;

	ptgri = TournamentGameReplicationInfo(Camera.GameReplicationInfo);
	for (i=0;i<32;i++) {
		if ( ptgri.PRIArray[i] == None ) {
			continue;
		}
		if ( ptgri.PRIArray[i].bIsSpectator ) {
			continue;
		}
		// INFO("nBAutoSpectate.FindPlayerNamed(\""$S$"\"): comparing to \""$ptgri.PRIArray[i].PlayerName$"\"");
		if ( ptgri.PRIArray[i].PlayerName == S ) {
			return PlayerPawn(ptgri.PRIArray[i].Owner);
		}
	}
	return None;
}

function ViewRedFC() {
	Camera.ViewPlayer(redFC);
	Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
}

function ViewBlueFC() {
	Camera.ViewPlayer(blueFC);
	Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
}

function SendErrMsg() {
	Camera.ClientMessage("-----------------------------------------");
	Camera.ClientMessage("MAC Addresses don't match.");
	Camera.ClientMessage("AutoSpec will cease to function.");
	Camera.ClientMessage("-----------------------------------------");
}





function Timer () {
	bviewingFC = False;
}

function setpawn (PlayerPawn o) {
	Camera = o;
	AddSelfAsMutator();
	Level.Game.RegisterDamageMutator(Self);
	#ifdef ENABLE_EVENT_RECORD_REPLAY
	INFO("nBAutoSpectate cam="$bSwitchCamera$" rec="$bRecordEvents$" replay="$bReplayEvents);
	#endif
}

function AddSelfAsMutator() {
	Level.Game.BaseMutator.AddMutator(Self);
}

// TODO: buggy ... how tho?!
function AddMutator(Mutator Other) {
	if (Other != None && Other.Class == Self.Class) {
		INFO("Not adding another nBAutoSpectate.");
		if (Other == Self) {
		} else {
			nBAutoSpectate(Other).Destroy();
		}
	} else {
		INFO("Adding mutator: "$Other);
		Super.AddMutator(Other);
	}
}

// I have not seen this hit, online or during demos:
function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCheckingForInterestingTarget) {
		// TODO: never happens =/
		INFO("Damage "$InstigatedBy$" -> "$Victim$" ActualDamage="$ActualDamage); // DamageType="$DamageType$" 
		if (FRand()<0.5)
			CreateNewCamera(InstigatedBy,Victim);
		else
			CreateNewCamera(Victim,InstigatedBy);
	}
}

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, out coerce string Msg, optional bool bBeep, out optional name Type) {
	if (Sender == Receiver && Sender.IsA('Spectator')) { // Only process the message once.
		CheckMessage(Mid(Msg,InStr(Msg,":")+1), Sender);
	}
	if (StrContains(Msg,"ow viewing from "))
		Msg="~~ "$StrAfterLast(Msg," ")$" ~~";
	return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type);
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	if (Sender == Receiver) { // Only process the message once.
		CheckMessage(Msg, Sender);
	}
	if (StrContains(Msg,"ow viewing from "))
		Msg="~~ "$StrAfterLast(Msg," ")$" ~~";
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

function Mutate(String str, PlayerPawn Sender) {
	CheckMessage("!"$str, Sender);
	Super.Mutate(str,Sender);
}

function CheckMessage(String str, Actor Sender) {
	DEBUG("Got message: >"$str$"< from "$Sender);
	if (Left(str,1) == "!") {
		str = Mid(str,1);
		if (str ~= "followfc")
			bStickWithFC = True;
		if (str ~= "nofollowfc")
			bStickWithFC = False;
		if (str ~= "doviewclass")
			bDoViewClass = True;
		if (str ~= "nodoviewclass")
			bDoViewClass = False;
		if (Left(str,7)~="follow ")
			RecommendedPlayerName = Mid(str,7);
		if (Left(str,7)~="resize " && Camera.ViewTarget != None)
			Camera.ViewTarget.DrawScale = 0.3+1.5*FRand();
		if (Left(str,7)~="roll ") {
			// Camera.Rotation.roll = -8192 + 8192*2*FRand();
			Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
		}
	}
}

simulated function Destroyed() {
	SaveConfig();
	if (Camera != None) {
		Camera.ViewTarget = None;
		Camera.bBehindView = False;
		Camera.DesiredFOV = Camera.default.DesiredFOV;
	}
}

function Vector FindGoodCameraSpot(Vector from, float radius, float height) {
	local float yaw,elev;
	local Vector to;
	local Vector HitLocation,HitNormal;
	local rotator rotation;
	local int i;
	// for (yaw=FRand()*8192/2;yaw<8192*8;yaw+=8192/2) {
		// for (y=minZ;y<maxZ;y+=16) {
	// }
	for (i=0;i<20;i++) {
		yaw = FRand()*8192*8;
		// y = minZ + FRand()*(maxZ - minZ);
			rotation.roll = 0;
			// rotation.pitch = pitch;
			rotation.pitch = 0;
			rotation.yaw = yaw;
			to = from + radius*Vector(rotation);
			to.z = from.z + height;
			HitActor = Trace(HitLocation,HitNormal,to,from,false);
			// dist = VSize(HitLocation-from);
			if (HitActor == None)
				return to;
			if (i==19)
				return from + (HitLocation-from)*0.9;
		// }
	}
}

function Actor FindClosestInterestingActor(optional Actor from, optional Vector fromV) {
	local Actor A,bestActor;
	local int distance,bestDistance;
	if (from != None)
		fromV = from.Location;
	// foreach VisibleActors(class'Actor', A, 16000000, from.Location) {
	foreach AllActors(class'Actor', A) {
		// if (A != from && isInteresting(A)) {
		if (A == from)
			continue;
		if (
			// isAGoodProjectile(A)
			// || isFC(A) ||
			isInteresting(A)
			// || A.IsA('CTFFlag')
			// || A.IsA('Flag')
			// || A.IsA('Carcass')
		) {
			distance = VSize(A.Location - from.Location);
			if (bestActor == None || distance < bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

defaultproperties {

	#ifdef PKATB
	bautoFC=True
	#endif

	bCameraPanning=True
	bSwitchCamera=False
	CameraSwitchSeconds=6
	bStickWithFC=True
	bDoViewClass=True

	bPrintDebugInfo=True

	#ifdef ENABLE_EVENT_RECORD_REPLAY
	bFlashing=True
	bLogConsole=False
	bRecordEvents=False
	bReplayEvents=True

	colGreen=(R=0,G=255,B=0,A=16);
	colRed=(R=255,G=0,B=0,A=16);
	colBlue=(R=0,G=0,B=255,A=16);
	colYellow=(R=180,G=180,B=64,A=24);
	#endif

}

#include "../../JLib/findactor.uc.jpp"
#include "../../JLib/jlib.uc.jpp"

