//================================================================================
// nBAutoSpectate.
//================================================================================

// TODO: nBAutoSpectate Online will record events even if we are not recording a demo!

// TODO: a different CameraMode 6 which just moves from last position to next position smoothly, so less moving about in general

// TODO: follow non frag events too

// This might make for some nice following of CTF runs
// (Especially if we decide to focus on FC whilst following frags!)

// #define LIST_ACTORS
// #define NO_CHANGE_ANGLE
#define ENABLE_EVENT_RECORD_REPLAY
// #define PKATB
// #define MEASURE_TICKRATE
#define RECORD_ALL_PLAYERNAMES

#define MaxEvents 4096

/*

// CameraMode Camera modes:
// 0 - default following ViewTarget, auto-panning
// 1 * custom following FollowActor
// 2 - free standing camera, looking at FollowActor
// 3 * floating camera, panning / looking at centre of mass)
// // 4 * custom following FollowActor, but looking at LookActor
// 4 * custom following FollowActor, and looking at LookActor
// 5 - default following ViewTarget, but looking at LookActor
// 6 - Viewing from behind FollowActor To LookActor
//
// * = camera floats towards a target

// For AutoTeamBalance COOL_CAMERA, consider not moving the camera, but rotating it so that the powerup appears in the middle, halfway through the shot.

*/

/*

// TODO: check messages for events
//       Camera.ProgressMessage[0] - [7]     or maybe playeerPawn.ProgressMessage[0-7]
//       Keep LastProgressMessage[0] - [7] to make checking easier
// Didn't work, try Console messages?
// No I think we really need to check ChallengeHUD.CurrentMessage and ShortMessageQueue[0-3] and LocalMessages[0-9]

// TODO:
// I keep losing actors like the one I am looking at, or his weapon.
// Solution:
// We should always be looking primarily at the Camera's ViewTarget.
// We should select the ViewTarget by calling ViewClass().

// CONSIDER: detect when P.ViewTarget changes, as a casual input from the viewer
// TODO: allow user command "!follow <nick>" to set the camera to follow a player (mode 2) e.g. for making a video.

// CONSIDER: Could continue to watch the first Corpse spawned after the player we are viewing dies (before/after they respawn).

// PROBLEM: some actors just go blank before they become None
//          we need to detect or avoid these
// maybe we can trust actors that have recently (re-)entered the pawnlist to be fresh

*/

// #define LogFlash(X); if (bLogging) { Camera.ClientMessage("> "$(X)); }
#define LogFlash(X) if (bLogging && bFlashing) { FlashMessageToPlayer(Camera,"> "$(X),colGrey,4,1.0); }

#define LogDebug2(X) 
// #define LogDebug2(X); if (bDebugLogging) { Log("[nBAS DEBUG2 "$Int(Level.TimeSeconds)$"] "$(X)); }

// #define LogDebug(X); 
#define LogDebug(X) if (bLogging) { Log("[nBAS DEBUG "$Int(Level.TimeSeconds)$"] "$(X)); }

// #define LogInfo(X); if (bLogging) { Log("[nBAS INFO "$Int(Level.TimeSeconds)$"] "$(X)); }
#define LogInfo(X) if (bLogging) { Log("[nBAS INFO "$Int(Level.TimeSeconds)$"] "$(X)); } if (bLogging && bFlashing) { FlashMessageToPlayer(Camera,"> "$(X),colWhite,3,0.5); }

#define LogWarn(X) if (bLogging) { Log("[nBAS WARN "$Int(Level.TimeSeconds)$"] > "$(X)); Camera.ClientMessage("> "$(X)); }

// #define LogError(X); 
// #define LogError(X); if (bLogging) { Log("[nBAS "$Int(Level.TimeSeconds)$"] "$(X)); }
// #define LogError(X); if (bLogging) { Camera.ClientMessage("> "$(X)); Log("[nBAS "$Int(Level.TimeSeconds)$"] "$(X)); }

// #define LogDebug(X); Log("nBAS] "$X);
// #define LogDebug(X); if (bLogging) { Camera.ClientMessage(X); }
// #define LogDebug(X); if (bLogging) { Camera.ClientMessage("[nBAS] "$(X)); Log("[nBAS] "$(X)); }
// #define LogDebug(X); if (bLogging) { Camera.ClientMessage("> "$(X)); Log("[nBAS "$GetDate()$"] "$(X)); }
// #define LogDebug(X); if (bLogging) { Camera.ClientMessage("> "$(X)); Log("[nBAS "$Int(Level.TimeSeconds)$"] "$(X)); }
// #define Log(X); 
// #define Log(X); LogDebug(X);



// class nBAutoSpectate extends Info;
class nBAutoSpectate extends Mutator config(nBAutoSpectate);

var PlayerPawn Camera;
var Rotator targRot;
var Rotator myRot;
var Rotator prevRot;
var bool bfoundflag;
var bool bviewingFC;
var string blueFC;
var string redFC;
#ifdef PKATB
var bool bautoFC;
#endif
var bool bAFCOFFmsg;
var bool bAFCONmsg;
// var private bool ;
// var private int ;
// var private int ;
var int ydelta;
var int pdelta;
// var private int ;
// var private int ;
var int Offset;

// nB:
var config bool bLogging;
var config bool bDebugLogging;
var config bool bCameraPanning;
var config bool bSwitchCamera;
var config float CameraSwitchSeconds;
var config bool bStickWithFC;
var config bool bDoViewClass;
var config bool bTiltWhenPointing;

// var String LastList;
var Actor LastNewActor;

var float LastSwitchTime;
var float deltaYaw, deltaPitch, deltaFOV, fov;
var Actor FollowActor, LookActor;

var bool bCheckingForInterestingTarget;
var bool bDoneViewClass;

var int CameraMode;

var String RecommendedPlayerName;

#ifdef MEASURE_TICKRATE
var int TickSecond;
var int TickCount;
#endif

#ifdef ENABLE_EVENT_RECORD_REPLAY

var config bool bFlashing;
var config bool bLogConsole; // entirely optional
var config bool bFlashConsole; // entirely optional
var config bool bRecordEvents;
var config bool bReplayEvents; // auto replay, and switch all the other autos
var config bool bAutoRecord;
var config bool bAutoSwitch;
var config bool bAutoSpeed;
var config bool bAutoSave;

var String LastProgressMessage[10];

var String LastConsoleLine;

var Color colGreen,colRed,colYellow,colBlue,colWhite,colGrey,colOrange;

struct LoggedEvent {
	var String Map;
	var float Time;
	var String Primary;
	var String Secondary;
	var vector PrimaryLocation;
	var vector SecondaryLocation;
	var String Line;
};

#ifdef STRUCTS_DB

	// Using the LoggedEvent structure, I could save 80 events np, but on loading, every record beyond 37 would be empty.

	// var config String ConsoleLog[4096];
	// var config String EventLog[MaxEvents];
	var config LoggedEvent EventLog[MaxEvents];

	#define GetMap(i) EventLog[i].Map
	#define GetTime(i) EventLog[i].Time
	#define GetPrimary(i) EventLog[i].Primary
	#define GetSecondary(i) EventLog[i].Secondary
	#define GetPrimaryLocation(i) EventLog[i].PrimaryLocation
	#define GetSecondaryLocation(i) EventLog[i].SecondaryLocation
	#define GetLine(i) EventLog[i].Line

#else

	// Using this method, EventTime gets blanked on reading from 256 onwards.
	// Meanwhile EventPrimaryLocation is blanked from 86, but EventMap and EventPrimary reach 500 without trouble.
	// Solution: use Strings?
	// Yes that solved it.  :)
	// But I don't like this structure.  So we could try structs again, but this time with Strings only, or we could make one big space-delimited record array, like ATB's.

	var config string EventMap[MaxEvents];
	var config string EventTime[MaxEvents];
	var config string EventPrimary[MaxEvents];
	var config string EventSecondary[MaxEvents];
	var config string EventPrimaryLocation[MaxEvents];
	var config string EventSecondaryLocation[MaxEvents];
	var config string EventLine[MaxEvents];

	#define GetMap(i) EventMap[i]
	#define GetTime(i) Float(EventTime[i])
	#define GetPrimary(i) EventPrimary[i]
	#define GetSecondary(i) EventSecondary[i]
	#define GetPrimaryLocation(i) Vector(EventPrimaryLocation[i])
	#define GetSecondaryLocation(i) Vector(EventSecondaryLocation[i])
	#define GetLine(i) EventLine[i]

#endif

var config int eventCount;

#ifdef RECORD_ALL_PLAYERNAMES
var String AllPlayerNames;
#endif

var int NextEventEndTime;
var int CurrentEventi;

#endif

function int fun1 (int X, int Y, out int diff) {
	local int newdiff;

	diff = X - Y;
	newdiff = diff;
	if ( (newdiff > 20000) || (newdiff < -20000) )
	{
		newdiff = 20000;
	}
	return newdiff * newdiff / 500000;
}

function PlayerPawn GetRandomPlayer() {
	local PlayerPawn p;
	local int count;
	foreach AllActors(class'PlayerPawn',p)
		count++;
	count = count * FRand();
	foreach AllActors(class'PlayerPawn',p) {
		count--;
		if (count < 0)
			return p;
	}
	return p;
}

function bool isInteresting(Actor a) {
	if (a.IsA('Spectator'))
		return false;
	return (
		// a.IsA('FlagBase')
		// a.IsA('CTFFlag') ||
		// a.IsA('Flag')
		// || (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
		// || (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
		// || a.IsA('HealthPack')
		// a.IsA('Projectile')
		isAGoodProjectile(A)
		|| a.IsA('PlayerPawn')
		|| a.IsA('Bot')
		// || a.IsA('Pawn')
		|| (a.IsA('Weapon') && Inventory(a).bTossedOut)
		// || a.IsA('NavigationPoint')
		|| a.IsA('Effect')
		// || a.IsA('Carcass')
	);
}

function int CountAllActors() {
	local int count;
	local Actor a;
	#ifdef LIST_ACTORS
	local String list;
	#endif
	foreach AllActors(class'Actor',a) {
		count++;
		#ifdef LIST_ACTORS
		list = list $ a.Name $ " ";
		#endif
	}
	#ifdef LIST_ACTORS
	// if (count < 10)
		// LogDebug(count$" actors: "$list);
	// else
		// LogDebug(count$" actors.");
	#endif
	return count;
}

function int CountInterestingActors() {
	local int count;
	local Actor a;
	#ifdef LIST_ACTORS
	local String list;
	#endif
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			count++;
			#ifdef LIST_ACTORS
			list = list $ a.Name $ " ";
			#endif
		}
	}
	#ifdef LIST_ACTORS
	// if (count < 10)
		// LogDebug(count$" actors: "$list);
	// else
		// LogDebug(count$" actors.");
	#endif
	return count;
}

function Actor GetLastViewClass() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo != None && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
			// LogDebug("Re-using "$NameActor(a));
			if (FRand()<0.2)
				RecommendedPlayerName = ""; // i think i'll only use it once, then discard it.
			return a;
		}
	}
	return None;
}

// #define GetRandomActor GetRandomActorReal
// #define GetRandomActor GetLastViewClass
function Actor GetRandomActor() {
	local Actor a;
	a = GetLastViewClass();
	if (a == None)
		a = GetRandomActorReal();
	return a;
}

function Actor GetRandomActorReal() {
	local int count,chosen;
	local Actor a;

	foreach AllActors(class'Actor',a) {
		if (isFC(a) && FRand()<0.5) {
			return a;
		}
	}

	if (RecommendedPlayerName != ""/* && FRand()<0.2*/) {
		foreach AllActors(class'Actor',a) {
			if (a.IsA('PlayerPawn') && PlayerPawn(a).PlayerReplicationInfo != None && PlayerPawn(a).PlayerReplicationInfo.PlayerName == RecommendedPlayerName) {
				// LogDebug("Re-using "$NameActor(a));
				// Occasionally we discard the last viewed player; there may be other actors worth viewing!
				if (FRand()<0.2)
					RecommendedPlayerName = "";
				return a;
			}
		}
		// RecommendedPlayerName = ""; // it has failed me now, and we don't want it to last forever anyway
	}

	count = CountInterestingActors();
	chosen = count*FRand();
	// Log("Chose "$chosen$" / "$count);
	// LogDebug("Chose "$Int(count*FRand())$" / "$count);
	foreach AllActors(class'Actor',a) {
		if (isInteresting(a)) {
			chosen--;
			if (chosen < 0)
				return a;
		}
	}
	return a;
}

function bool isFC(Actor a) {
	return ( ( a != None ) &&
		( Pawn(a) != None ) &&
		( Pawn(a).PlayerReplicationInfo != None ) &&
		( Pawn(a).PlayerReplicationInfo.HasFlag != None )
	);
}

// TODO: To get the most action, find a "busy" Actor to view.
// one e.g.: find average location of all pawns; find actor closest to this, to get close into the action
// or: a big lonely map, but 3 players are in the same room; detect that (k-means on distance)

	/*
	Target = GetRandomActor(class'FlagBase');
	if (Target == None)
		Target = GetRandomActor(class'PlayerPawn');
	if (Target == None)
		Target = GetRandomActor(class'ShockRifle');
	if (Target == None)
		Target = GetRandomActor(class'NavigationPoint');
	*/

function GetRandomCameraNow() {
	CreateNewCamera(GetRandomActor());
}

function bool isCameraModeAllowed() {
	return (CameraMode>=0 && CameraMode<=6);
}

function CreateNewCamera(Actor a, optional Actor b) {
	local String report;

	// if (Level.TimeSeconds < LastSwitchTime + CameraSwitchSeconds)
		// return;

	LastSwitchTime = Level.TimeSeconds;
	bCheckingForInterestingTarget = False;
	bDoneViewClass = False;

	if (GetLastViewClass() != None) {
		a = GetLastViewClass();
	}
	if (bStickWithFC) {
		if (isFC(LookActor)) {
			a = LookActor;
		}
		if (isFC(FollowActor)) {
			a = FollowActor;
		}
		if (isFC(Camera.ViewTarget)) {
			a = Camera.ViewTarget;
		}
	}

	report = "";

	// CameraMode = FRand()*6;
	while (true) {
		CameraMode = CameraMode+1;
		if (CameraMode>6)
			CameraMode=0;
		if (isCameraModeAllowed())
			break;
	}
	// LogDebug("CreateNewCamera("$a$","$b$"): Chose CameraMode = " $ CameraMode);

	Camera.ViewTarget = None;
	FollowActor = None;
	LookActor = None;
	NewCamera();
	if (CameraMode == 0) {
		Camera.ViewTarget = a;
		report = "[0] Viewing from "$NameActor(a);
	}
	if (CameraMode == 1) {
		FollowActor = a;
		report = "[1] Following "$NameActor(FollowActor);
		Camera.ViewRotation.Pitch += 8192/2;
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
	}
	if (CameraMode == 2) {
		FollowActor = a;
		deltaYaw /= 4;
		deltaPitch /= 3;
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( Camera.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,1)*(64.0+FRand()*64.0) );
		Camera.ViewRotation = rotator(FollowActor.Location-Camera.Location);
		report = "[2] Camera following "$NameActor(a);
	}
	if (CameraMode == 3) {
		NiceCamera();
		deltaYaw /= 4;
		deltaPitch /= 3;
		deltaFOV *= 2;
		// A = FindBusiestActor();
		A = FindClosestInterestingActor(,CentreOfMass());
		Camera.ViewTarget = None;
		// Camera.SetLocation( A.Location );
		// Camera.ViewRotation = rotator(CentreOfMass() - Camera.Location);
		// Camera.SetLocation( A.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,16) );
		Camera.SetLocation( FindGoodCameraSpot(A.Location,96,-8+FRand()*96) );
		// FollowActor = FindClosestInterestingActor(A);
		FollowActor = A;
		// report = "[3] Camera panning from "$NameActor(A)$" looking at "$NameActor(FollowActor);
		report = "[3] Camera panning on "$NameActor(FollowActor);
	}
	if (CameraMode == 4) {
		FollowActor = a;
		LookActor = b;
		if (LookActor == None || FRand()<0.5) {
			LookActor = FindClosestInterestingActor(FollowActor);
		}
		Camera.ViewRotation = rotator(LookActor.Location - FollowActor.Location);
		Camera.SetLocation( FollowActor.Location );
		Camera.SetLocation( FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + vect(0,0,16) );
		// report = "[4] Following "$NameActor(FollowActor)$" Facing "$NameActor(LookActor);
		report = "[4] Following "$NameActor(FollowActor)$"";
	}
	if (CameraMode == 5) {
		Camera.ViewTarget = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(Camera.ViewTarget);
		}
		report = "[5] Viewing from "$NameActor(a)$" Looking at "$NameActor(LookActor);
	}
	if (CameraMode == 6) {
		Camera.ViewTarget = None;
		FollowActor = a;
		LookActor = b;
		if (LookActor == None) {
			LookActor = FindClosestInterestingActor(Camera.ViewTarget);
		}
		if (!CanSee(FollowActor.Location,Camera.Location)) {
			Camera.SetLocation( FollowActor.Location + vect(0,0,64) );
			Camera.SetRotation( rotator(LookActor.Location - Camera.Location) );
		}
		report = "[6] Viewing from behind "$NameActor(FollowActor)$" To "$NameActor(LookActor);
	}

	Camera.bBehindView = ( Camera.ViewTarget != None );
	if (Camera.ViewTarget != None) {
		Camera.ViewTarget.BecomeViewTarget();
	}

		/*

		// Old methods:

		if (Camera.IsA('Spectator')) {
			// Spectator(Camera).bChaseCam = (FRand() < 0.80);
			// report = "(chase="$Spectator(Camera).bChaseCam$") " $ report;
		}

		// Shall we focus?
		if (FRand()<0.5) {
			FollowActor = None;
		}
		if (b != None) {
			FollowActor = b;
		}
		if (FRand()<0.25 || (FollowActor == None && FRand()<0.5)) {
			// FollowActor = FindClosestActor(Camera.ViewTarget);
			// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"PlayerPawn");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"Bot");
			// if (FollowActor == None)
				// FollowActor = FindClosestActorMatching(Camera.ViewTarget,"Projectile");
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Pawn');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Bot');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'Projectile');
			// FollowActor = FindClosestActorClass(Camera.ViewTarget,class'PlayerPawn');
			FollowActor = FindClosestInterestingActor(Camera.ViewTarget);
			if (FollowActor == None) {
				report = "[FindClosestInterestingActor gave "$FollowActor$"] ";
			// } else if (!isInteresting(FollowActor)) {
				// report = "[Dropped uninteresting " $ FollowActor $ "] ";
				// FollowActor = None;
			}
		// } else {
			// FollowActor = None;
		}
		if (FRand()<0.25) {
			FollowActor = Camera.ViewTarget;
			Camera.ViewTarget = None;
		}

		NewCamera();

		if (FollowActor != None) {
			// Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + vect(0,0,48.0));
			Camera.ViewRotation = rotator(FollowActor.Location - Camera.Location);
			Camera.SetLocation(FollowActor.Location - 96*Vector(Camera.ViewRotation) + FRand()*vect(0,0,48.0));
			if (FRand()<0.25) {
				Camera.ViewTarget = None;
			}
		} else {
			// I think the ViewTarget will set our location/camera-point later,
			// but our position can be used to set a good initial rotation now.
			Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + FRand()*vect(0,0,48.0));
		}

		// Set a good initial rotation:
		if (FRand()<0.5) {
			Camera.ViewRotation = rotator(CentreOfMass() - Camera.Location);
		}

		// In case the camera wants to detach:
		// Camera.SetLocation(Target.Location);
		// Camera.SetRotation(Target.Rotation); // not always facing upwards!

		*/

	/*
	if (FRand()<0.05) {
		if (Camera.ViewTarget != None) {
			Camera.SetLocation(Camera.ViewTarget.Location - 96*Vector(Camera.ViewRotation) + vect(0,0,48.0));
			// Camera.SetLocation(Camera.ViewTarget.Location - 96 * Vector(Camera.ViewRotation));
			Camera.ViewTarget = None;
			report = "External camera! " $ report;
		}
	}
	*/

	// if (Camera.ViewTarget != None)
		// report = report $ "Watching: " $ Camera.ViewTarget.Name $ " ";
	// if (FollowActor != None)
		// report = report $ "Following: " $ FollowActor.Name $ " ";

	// report = report $ " ";

	// report = report $ " [/"$CountInterestingActors()$"]";
	// report = "[" $ CountInterestingActors() $ "] " $ report;

	// report = "[" $ getTeamCounts() $ "] " $ report;
	// report = "[" $ getTeamCounts() $ "/" $ CountInterestingActors() $ "] " $ report;

	report = report $ " {"$CountInterestingActors()$"/"$CountAllActors()$"}";

	LogInfo("Switch " $ report);
	// Log(report);

}

// Just for curiousity/debugging purposes.
function String getTeamCounts() {
	local Actor A;
	local int countRed,countBlue;
	foreach AllActors(class'Actor', A) {
		// if (A.IsA('Pawn')) {
		if (A.IsA('Bot') || A.IsA('PlayerPawn')) {
			if (Pawn(A).PlayerReplicationInfo != None) {
				if (Pawn(A).PlayerReplicationInfo.Team == 0) {
					countRed++;
				}
				if (Pawn(A).PlayerReplicationInfo.Team == 1) {
					countBlue++;
				}
			}
		}
	}
	// return "Red: "$countRed$" | Blue: "$countBlue;
	return countRed $ "v" $countBlue;
}

// TODO
function Actor FindPlayerWithMostEnemiesNearby() {
	return None;
}

function String NameActor(Actor a) {
	local String append;
	if (A == None)
		return "None";
	// if (A.IsA('Pawn') && Pawn(A).PlayerReplicationInfo != None)
		// return PlayerPawn(A).PlayerReplicationInfo.PlayerName; // no good: "" for bots online
	if (A.IsA('PlayerPawn') && PlayerPawn(A).PlayerReplicationInfo != None) {
		//// This works, if we want to use it:
		// if (PlayerPawn(A).PlayerReplicationInfo.Score > 0)
			// append = " (with " $ Int(PlayerPawn(A).PlayerReplicationInfo.Score) $ " frags)";
		append = " (" $ Int(PlayerPawn(A).PlayerReplicationInfo.Score) $ ")";
		return PlayerPawn(A).PlayerReplicationInfo.PlayerName $ append;
	}
	if (A.IsA('Bot'))
		return ""$Bot(A).getHumanName()$"b";
	if (A.IsA('Projectile'))
		// return A.Name$"("$Projectile(Camera.ViewTarget).Owner$")";
		return A.Name$"("$Projectile(A).Owner$")";
	// return String(A.Name);
	return A.Name $ "[" $ A.Class $ "]";
}

function Vector CentreOfMass() {
	local int count;
	local Vector centre;
	local Actor A;
	count = 0;
	centre = vect(0,0,0);
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			count++;
			centre = centre*(Float(count-1)/Float(count)) + A.Location*(1.0/Float(count));
		}
	}
	return centre;
}

function float FFRand() { // returns a number between 0.5 and 1.0
	return 0.5 + 0.5 * FRand();
}

function float SgnRand() { // returns -1.0 or +1.0 randomly
	if (FRand()<0.5) {
		return 1.0;
	} else {
		return -1.0;
	}
}

function NewCamera() {

	#ifndef NO_CHANGE_ANGLE
	// Camera.ViewRotation.Yaw = 8192*8*(FRand()-0.5);
	// // Camera.ViewRotation.Pitch = 8192*0.5*(FRand()-0.3);
	// Camera.ViewRotation.Pitch = 8192*0.5*(FRand()-0.7);
	Camera.ViewRotation.Yaw = 8192*8*FFRand()*SgnRand();
	Camera.ViewRotation.Pitch = 8192*0.8*FFRand()*SgnRand();
	Camera.ViewRotation.Roll = 0;
	Camera.DesiredFOV = 90 + 30 * FRand();
	// Camera.ConsoleCommand("FOV "$Camera.DesiredFOV); // seems to be needed! NO it causes ini file writes!
	#endif

	// deltaYaw = 400*FFRand()*SgnRand();
	deltaYaw = 400*(FRand()-0.5);
	deltaPitch = -Sgn(Camera.ViewRotation.Pitch) * 40*FRand();
	// deltaPitch = 30*(FRand()-0.7);
	deltaFOV = 0.2*(FRand()-0.5);

	bTiltWhenPointing = (FRand() < 0.1);

}

function Actor FindBusiestActor() {
	local Actor A,B,bestActor;
	local float distance,bestDistance;
	foreach AllActors(class'Actor',A) {
		if (isInteresting(A)) {
			distance = 0;
			foreach AllActors(class'Actor', B) {
				distance = distance + VSize(A.Location-B.Location);
			}
			if (bestActor == None || distance<bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

function NiceCamera() {
	local Actor A;

}

function PointTowardsActor(Pawn P, Actor Target) {
	// RotateTowards(Camera.ViewRotation,rotator(Target.Location-P.Location));
	PointTowardsLocation(P,Target.Location);
}

function PointTowardsLocation(Pawn P, Vector L) {
	// RotateTowards(Camera.ViewRotation,rotator(L-P.Location));
	local rotator RB;
	RB = rotator(L-P.Location);
	P.ViewRotation.yaw = RotateAngle(P.ViewRotation.yaw, RB.yaw);
	P.ViewRotation.pitch = RotateAngle(P.ViewRotation.pitch, RB.pitch);
	// For some extra fun, we roll the camera if it is not yet pointing at the target:
	if (bTiltWhenPointing) {
		P.ViewRotation.roll = (P.ViewRotation.yaw-RB.yaw) + (P.ViewRotation.pitch-RB.pitch);
		// Really bad!!:  (Makes me wonder what the above is doing!)
		// P.ViewRotation.roll = 0.6 * ( (P.ViewRotation.yaw-RB.yaw) + (P.ViewRotation.pitch-RB.pitch) );
	}
}

/*
function RotateTowards(rotator RA, rotator RB) {
	RA.yaw = RotateAngle(RA.yaw, RB.yaw);
	RA.pitch = RotateAngle(RA.pitch, RB.pitch);
}
*/

function float RotateAngle(float a, float b) {
	while (a<0)
		a+=65536.0;
	while (a>=65536)
		a-=65536.0;
	while (b<0)
		b+=65536.0;
	while (b>=65536)
		b-=65536.0;
	if ( b-a > 65536/2) {
		b -= 65536.0;
	}
	if ( a-b > 65536/2) {
		a -= 65536.0;
	}
	return a * 0.92 + b * 0.08;
}

function bool LosingNetOn(Actor a) {
	if (a == None)
		return true;
	if (a.Location == vect(0,0,0))
		return true;
	return false;
	// TODO: Sometimes the pawn we are viewing disappears, and the camera just stays looking
	//       at his last known location.
	//       This is what LosingNetOn() was meant to detect, but it doesn't!
	//       We could check bVisible, or the mesh or smth.
	//       Or maybe we should compare his current position against his last position, and
	//       see if he has not moved.  (That would give a false positive on campers though.)
}

function MovePawnTowardsLocation(Pawn p, Vector NewLocation, float amount) {
/*
	while (amount<1) {
		NewLocation = p.Location * (1.0-amount) + NewLocation * amount;
		if (p.SetLocation(NewLocation))
			break;
		amount = amount + 0.05;
	}
*/
	p.SetLocation( p.Location * (1.0-amount) + NewLocation * amount );
}

// #define DontLose(X) if (X==None) { LogDebug("Lost X "$X); GetRandomCameraNow(); }
// #define DontLose(X); 
// #define DontLose(X,Y); if (LosingNetOn(X)) { LogDebug("Losing " $ Y); GetRandomCameraNow(); }
// TODO: since X==None, Y should be a stored string that described X.
function DontLose(Actor X,String Y) {
	if (LosingNetOn(X)) {
		LogWarn("LosingNetOn " $ Y $ " - Calling GetRandomCameraNow() ...");
		if (bSwitchCamera)
			GetRandomCameraNow();
	}
}
/*
#define DontLose(X,Y); if (LosingNetOn(X)) { LogDebug2("Losing(DontLose): " $ Y); if (bSwitchCamera) { GetRandomCameraNow(); } return; }
*/

function DeltaCamera(float Delta) {

	local Actor HitOut;
	local Vector HitLocation,HitNormal;
	local Rotator followTarget;
	local Vector TargetLocation,NewLocation;

	local bool doNotPan;

	if (CameraMode == 0) {
		DontLose(Camera.ViewTarget,"Camera.ViewTarget");
	}
	if (CameraMode == 1) {
		DontLose(FollowActor,"FollowActor");
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(FollowActor.Location - Camera.Location);
		// // Camera.ViewRotation.yaw   = 8192*4 + (Camera.ViewRotation.yaw-8192*4)   * 0.99 + (followTarget.yaw-8192*4)   * 0.01;
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.95 + followTarget.yaw * 0.05;
		// Camera.SetLocation( FollowActor.Location - 128*Vector(Camera.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 24;
		MovePawnTowardsLocation(Camera,NewLocation,1.0);
		// NewLocation = Camera.Location * 0.0 + TargetLocation * 1.0;
		// Camera.SetLocation(NewLocation);
		// Camera.ClientSetLocation(NewLocation,Camera.ViewRotation);
		// doNotPan = true;
	}
	if (CameraMode == 2) {
		DontLose(FollowActor,"FollowActor");
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(FollowActor.Location - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		// Always points down: Camera.ViewRotation.pitch = Camera.ViewRotation.pitch * 0.999 + followTarget.pitch * 0.001;
		doNotPan = true;
	}
	if (CameraMode == 3) {
		DontLose(FollowActor,"FollowActor");
		// DONE: if this never works, try following FollowActor instead, just using the nice setup we have.
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 48;
		MovePawnTowardsLocation(Camera,TargetLocation,0.2);
		// NewLocation = Camera.Location * 0.8 + TargetLocation * 0.2;
		// Camera.SetLocation(NewLocation);
		PointTowardsLocation(Camera,CentreOfMass());
		// followTarget = rotator(CentreOfMass() - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
		if (!CanSee(CentreOfMass(),Camera.Location) && FRand()<0.1) {
			LogInfo("CanSee failed - Forcing FollowActor=None");
			FollowActor = None;
		}
	}
	if (CameraMode == 4) {
		DontLose(FollowActor,"FollowActor");
		// DontLose(LookActor,LookActor);
		// Camera.SetLocation( FollowActor.Location - 128*Vector(Camera.ViewRotation) + vect(0,0,64) );
		TargetLocation = FollowActor.Location - 128*Normal(Vector(Camera.ViewRotation));
		TargetLocation.Z = FollowActor.Location.Z + 64;
		// NewLocation = Camera.Location * 0.9 + TargetLocation * 0.1;
		MovePawnTowardsLocation(Camera,TargetLocation,0.02);
		// Camera.SetLocation(NewLocation);
		// Camera.ClientSetLocation(NewLocation,Camera.ViewRotation);
		// PointTowardsActor(Camera,LookActor);
		PointTowardsActor(Camera,FollowActor);
		// followTarget = rotator(LookActor.Location - Camera.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
	}
	if (CameraMode == 5) {
		DontLose(Camera.ViewTarget,"Camera.ViewTarget");
		DontLose(LookActor,"LookActor");
		// PointTowardsActor(Camera,FollowActor);
		PointTowardsActor(Camera,LookActor);
		// followTarget = rotator(FollowActor.Location - Camera.ViewTarget.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
	}
	if (CameraMode == 6) {
		DontLose(FollowActor,"FollowActor");
		DontLose(LookActor,"LookActor"); // Was happening in a nasty loop on demo playback - maybe fixed now i don't set mode 6 so often
		// if (LosingNetOn(LookActor)) {
			// LogFlash("[6] LosingNetOn LookActor="$LookActor);
		// }
		// PointTowardsLocation(Camera, (LookActor.Location + FollowActor.Location) / 2.0 );
		#ifdef ENABLE_EVENT_RECORD_REPLAY
		if (bReplayEvents) {
			// Look=Primary, Follow=Secondary
			// The extra - 1 just makes the camera arrive 1 second early at the FinalTarget.
			#define thru Chop(0.0, 1.0, 1.0 - (GetTime(CurrentEventi) - 1 - Level.TimeSeconds) / 4.0)
			// #define panPos Camera.Location * (1.0 - thru) + (GetSecondaryLocation(CurrentEventi)-64*Normal(Vector(Camera.ViewRotation))) * thru;
			// TargetLocation = panPos;
			#define InitialTarget (LookActor.Location - 160*Normal(Vector(Camera.ViewRotation)) + 48*vect(0,0,1))
			// #define FinalTarget (GetSecondaryLocation(CurrentEventi) - 160*Normal(Vector(Camera.ViewRotation)) + 32*vect(0,0,1))   // This was running off somewhere unwanted (maybe location recorded after death/respawn?)
			// #define FinalTarget (FollowActor.Location - 96*Normal(Vector(Camera.ViewRotation)) + 16*vect(0,0,1))
			// #define FinalTarget (FollowActor.Location - Normal(LookActor.Location-FollowActor.Location)*128 + vect(0,0,1)*8)
			#define FinalTarget (GetSecondaryLocation(CurrentEventi) - Normal(LookActor.Location-FollowActor.Location)*140 + vect(0,0,1)*12)
			TargetLocation = FinalTarget * thru + InitialTarget * (1.0 - thru);
			// MovePawnTowardsLocation(Camera,TargetLocation,thru);
			// Camera.SetLocation(TargetLocation);
			MovePawnTowardsLocation(Camera,TargetLocation,0.1+0.4*thru);
			#define TargetLookLocation (LookActor.Location * thru + FollowActor.Location * (1.0 - thru))
		} else {
		#else
			#define thru 0.90
			TargetLocation = FollowActor.Location - Normal(LookActor.Location-FollowActor.Location)*180 + vect(0,0,1)*64;
			MovePawnTowardsLocation(Camera,TargetLocation,thru);
			#define TargetLookLocation LookActor.Location
		#endif
		}
		// PointTowardsLocation(Camera, LookActor.Location);
		PointTowardsLocation(Camera, TargetLookLocation);
		#undef TargetLookLocation
		// TargetLocation = FollowActor.Location - Normal(LookActor.Location-FollowActor.Location)*180 + vect(0,0,1)*64;
		if (!CanSee(TargetLocation,Camera.Location) && !CanSee(Camera.Location,FollowActor.Location) && !CanSee(Camera.Location,LookActor.Location)) {
			// Camera.SetLocation( FinalTarget + vect(16,0,16) );
			Camera.SetLocation( LookActor.Location );
			Camera.SetLocation( TargetLocation + vect(16,0,16) );
			if (FRand()<0.1)
				LogFlash("Had to move camera to see "$TargetLocation);
			// Problem is, sometimes we still can't see it!  TargetLocation may be inside a wall!  :P
			// Camera.SetRotation( rotator(LookActor.Location - Camera.Location) );
		}

		/*
		// #ifdef ENABLE_EVENT_RECORD_REPLAY
		if (CurrentEventi > 0) {
			#define timeToEvent (LoggedEvent[CurrentEventi].Time - Level.TimeSeconds)
			#define moveAmountTimeBased Chop(0.01,1.0,timeToEvent/5.0)
			MovePawnTowardsLocation(Camera, TargetLocation, moveAmountTimeBased);
		}
		// #endif ENABLE_EVENT_RECORD_REPLAY
		*/

		// followTarget = rotator(FollowActor.Location - Camera.ViewTarget.Location);
		// Camera.ViewRotation.yaw   = Camera.ViewRotation.yaw * 0.99 + followTarget.yaw * 0.01;
		doNotPan = true;
	}

	// if (Camera.ViewTarget != None) {
	if (bCameraPanning && !doNotPan) { // && FollowActor == None) {
		Camera.ViewRotation.Yaw += deltaYaw;
		Camera.ViewRotation.Pitch += deltaPitch;
		// Camera.ConsoleCommand("FOV "$Camera.DesiredFOV); // seems to be needed! NO it causes ini file writes!
		deltaYaw = deltaYaw * 0.998;
		deltaPitch = deltaPitch * 0.998;
	}
	if (bCameraPanning) {
		Camera.DesiredFOV = Camera.DesiredFOV + deltaFOV;
		deltaFOV = deltaFOV * 0.998;
	}

	// if (FollowActor != None) {
		// Camera.ViewRotation = rotator(FollowActor.Location - Camera.Location);
		// // Camera.SetRotation(rotator(FollowActor.Location - Camera.Location));
		/*
		HitActor = Trace(HitLocation,HitNormal,FollowActor.Location+128*Vector(Camera.ViewRotation),Camera.Location+16*Vector(Camera.ViewRotation),true);
		if (HitActor != FollowActor) {
			LogInfo("Lost follow on "$FollowActor.Name$" got "$HitActor);
			FollowActor = None;
		}
		*/
	// }

	if (!CanSeeActors(Camera,Camera.ViewTarget) && !CanSeeActors(Camera,FollowActor) && !CanSeeActors(Camera,LookActor) && FRand()<0.1) {
		LogInfo("Lost line-of-sight to "$NameActor(Camera.ViewTarget)$", "$NameActor(FollowActor)$" and "$NameActor(LookActor)$"!");
		if (bSwitchCamera)
			GetRandomCameraNow();
	}

}

function float Chop(float Lowest, float Highest, float In) {
	if (In < Lowest)
		return Lowest;
	if (In > Highest)
		return Highest;
	return In;
}

function bool CanSeeActors(Actor from, Actor to) {
	if (from == None || to == None)
		return false;
	return CanSee(from.Location,to.Location);
}

function bool CanSee(Vector from, Vector to) {
	local Vector HitLocation, HitNormal;
	// CollisionRadius=1;
	// CollisionHeight=1;
	SetCollisionSize(1,1);
	HitActor = Trace(HitLocation,HitNormal,to,from,false);
	if (HitActor == None)
		return true;
	else
		return false;
}

/*
function CheckForNewActors() {
	local Actor A;
	local String NewList;
	NewList=" "; // BUG TODO: in online play actors will sometimes leave the list then return to it later; so we need an AllActorsEverList
	foreach AllActors(class'Actor', A) {
		NewList = NewList $ A.Name $ " ";
		if (LastList != "") {
			// BUG TODO: this becomes inefficient
			if (InStr(LastList," "$A.Name$" ")<0) {
				HandleNewActor(A);
			}
		}
	}
	LastList = NewList;
}
*/

function CheckForNewActors() {
	local Actor A;
	local bool pastLast;
	foreach AllActors(class'Actor', A) {
		if (pastLast) {
			HandleNewActor(A);
		}
		if (A == LastNewActor) {
			pastLast = true;
		}
	}
	LastNewActor = A;
}

function float Sgn(float num) {
	if (num>0)
		return +1;
	if (num<0)
		return -1;
	return 0;
}

function bool isAGoodProjectile(Actor A) {
	return (A.isA('flakslug') || A.isA('ShockProj') || A.isA('Rocket'));
}

function HandleNewActor(Actor A) {
	if (bCheckingForInterestingTarget) {
		// if (isInteresting(A)) {
		// if (A.IsA('Projectile') && Instr(""$A.Name,"Trans")<0) {
		if (
			isAGoodProjectile(A)
			// || A.IsA('Carcass')
			|| (a.IsA('UT_ShieldBelt') && !Pickup(a).bHeldItem)
			|| (a.IsA('UT_Damage') && !Pickup(a).bHeldItem)
			|| (a.IsA('Armor') && !Pickup(a).bHeldItem)
			|| a.IsA('Effect')
		) {
			// Log("New Actor: "$A);
			LogInfo("HandleNewActor(): New Actor: "$A);
			// TODO: CreateNewCamera works for bSwitchCamera, but we could also integrate HandleNewActor() into the bRecordEvents or bReplayEvents system.
			CreateNewCamera(A,A.Owner);
		}
	}
}

/*
function CheckForInterestingTarget() {
	// local Actor A;
	// local Actor LatestProjectile;
	// New projectile or new damage will force camera-switch.
	if (!bCheckingForInterestingTarget) {
		bCheckingForInterestingTarget = True;
		// LastList = "";
	} else {
		CheckForNewActors();
		// LatestProjectile = None;
		// foreach AllActors(class'Projectile', A) {
			// LatestProjectile = A;
		// }
	}
}
*/

#ifdef ENABLE_EVENT_RECORD_REPLAY

function CheckConsole() {
	// local int i;
	// local PlayerPawn P;
	// local string comp;
	// local ChallengeHUD ch;
	// local Actor A;
	// local Console C;
	local String line;

		// TODO CONSIDER BUG: Sometimes events occur with a player that we cannot find in the current Actor list (using FindPlayerNamed()).  (e.g. someone captures a flag beyond our view)
		// Is it worthwhile recording these events?  There may not be much to see at their location.

	line = Camera.Player.Console.MsgText[Camera.Player.Console.TopLine];

	if (line != LastConsoleLine) {
		// New console line!

		if (bLogConsole)
			Log("[CONSOLE] ("$Int(Level.TimeSeconds)$") "$line);
		if (bFlashConsole)
			FlashMessageToPlayer(Camera,line,colBlue,0,1.0);

		#ifdef ENABLE_EVENT_RECORD_REPLAY
		if (!StrStartsWith(line,"> ")) { // prevent infinite loop detecting its own output!
			if (bRecordEvents) {
				CheckLineForEvent(line);
			}
		}
		#endif

		// This allows us to catch when our user gives commands to nBAS.
		// However, it will also accept commands from any player in the game!!
		if (StrStartsWith(line,"!")) {
			CheckMessage(line,None);
		}

		LastConsoleLine = line;
	}

}

function CheckLineForEvent(String line) {
	local int wordCount,i;
	local String words[256];
	local String word;
	local LoggedEvent ev;
	local Color msgCol;
	local Pawn p;

	FlashMessageToPlayer(Camera,"[o] ("$Int(Level.TimeSeconds)$") ? " $ CountInterestingActors() $ "/" $ CountAllActors(),colYellow,6,1.0);

	// Can we find players in the line?  If so, fill ev.Primary and ev.Secondary:
	wordCount = SplitString(line," ",words);
	for (i=0;i<wordCount;i++) {
		word = words[i];
		// if (StrEndsWith(word,"\'s"))
		if (Right(word,2) == "\'s")
			word = StrBeforeLast(word,"\'s");
		// if (StrEndsWith(word,"."))
			// word = StrBeforeLast(word,".");
		// if (StrEndsWith(word,"!"))
			// word = StrBeforeLast(word,"!");
		// Log("Seeking \""$word$"\"");
		p = FindPlayerNamed(word);
		// LogDebug("Got player: "$p);
		if (p != None) { // player can currently be seen in the game
			if (ev.Primary == "") {
				ev.Primary = word;
				ev.PrimaryLocation = p.Location;
			} else {
				ev.Secondary = word;
				ev.SecondaryLocation = p.Location;
				// We could break now that we have primary and secondary, or keep searching words for other secondaries...
				// break;

				// Different death messages for various weapons display the player names in different orders.
				// We just randomly switch the two players.
				// if (FRand()<0.5) {
				// if (true) {
				// if (false) { // Until we properly detect, we don't swap - this puts victim at the end of shock kills
				if (
						StrContains(line," inflicted mortal damage upon ")
					|| StrContains(line," put a bullet through ")
					|| StrContains(line," into a leaky piece of meat.")
					|| StrContains(line," took a bloody chunk out of ")
					|| StrContains(line," with a blood soaked ")
					|| StrContains(line," telefragged ")
					|| StrContains(line," full of holes with the ")
					|| StrContains(line," ripped a chunk of meat out of ")
					|| StrContains(line," electrified ")
				) {
					// Do nothing.  Primary > Secondary
				} else {
					// Due to the type of death message, swap the order, so that Primary > Secondary
					ev.Secondary = ev.Primary;
					ev.SecondaryLocation = ev.PrimaryLocation;
					ev.Primary = word;
					ev.PrimaryLocation = p.Location;
				}

			}
		}
	}

	// Done: We might want to accept only Primary.
	// if (ev.Primary != "" && ev.Secondary != "") {
	if (ev.Primary != "") {

		// NOTE BUG: We should not loop this, or ev might start non-empty!
		ev.Map = GetDemoID();
		ev.Time = Level.TimeSeconds;
		ev.Line = line;

		// LogDebug("[o] RECORD ("$ev.Primary$","$ev.Secondary$"): " $ line );
		LogDebug("["$Int(Level.TimeSeconds)$"] [o] RECORD "$ev.Primary$" > "$ev.Secondary$" #"$eventCount);
		FlashMessageToPlayer(Camera,"["$Int(Level.TimeSeconds)$"] [o] REC #" $ eventCount $ " " $ ev.Primary$" > "$ev.Secondary,colRed,7,1.0);

		// Once database is full, it overwrites old events randomly
		if (eventCount >= MaxEvents) {
			// EventLog[i] = ev;
			i = Int(FRand()*MaxEvents);
		} else {
			// EventLog[eventCount] = ev;
			i = eventCount;
			eventCount++;
		}
		EventMap[i] = ev.Map;
		EventTime[i] = String(ev.Time);
		EventPrimary[i] = ev.Primary;
		EventSecondary[i] = ev.Secondary;
		EventPrimaryLocation[i] = String(ev.PrimaryLocation);
		EventSecondaryLocation[i] = String(ev.SecondaryLocation);
		EventLine[i] = ev.Line;

		// if (FRand()<0.1) {
		// if ((eventCount % 8) == 0) {
		// if (true) {
		// if (false) {
		if (bAutoSave && FRand()<0.1) {
			// LogWarn("SAVING "$eventCount$" ...");
			// LogInfo("[o] SAVING ...");
			FlashMessageToPlayer(Camera,"[o] SAVING "$eventCount$" ...",colRed,6,3.0);
			// FlashMessageToPlayer(Camera,"[o] SAVING ...",colRed,7,3.0);
			LogInfo("[o] SAVING...");
			SaveConfig();
			LogInfo("[o] DONE");
		}

	}

}

	// if (InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]," killed ") >= 0) {
		// if (!StrContains(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"FRAG!")) { // prevent infinite loop detecting its own output!
			// LogInfo("Detected FRAG! " $ Camera.Player.Console.MsgText[Camera.Player.Console.TopLine] );
		// }
	// }

	// foreach AllActors(class'Actor', A) {
		// if (A.isA('Console'))
			// C = Console(A); // Error, Cast from 'Actor' to 'Console' will always fail
		// else
			// continue;
		// line = C.MsgText[C.TopLine];
	// OK I haven't found a way to read the consoles of other players, it always did seem pretty unrealistic :P

		// if (InStr(line," killed ") >= 0) {
			// if (!StrContains(line,"FRAG!")) { // prevent infinite loop detecting its own output!

	// }

	// foreach AllActors(class'PlayerPawn', P) {
		/*
		// Checking ProgressMessages seems useless; they only pick up XOL's flashed hiscores.
		// I wonder though if we can still access the ineyes player's console even when we are viewing 3rdperson.
		if (P.myHUD == None)
			continue;
		ch = ChallengeHUD(P.myHUD);
		if (ch == None)
			continue;
		if (ch.CurrentMessage != LastProgressMessage[0]) {
			LogInfo("Detected line: " $ ch.CurrentMessage);
			LastProgressMessage[0] = ch.CurrentMessage;
		}
		*/
		/*
		// There is no such thing P.Console or ch.Console
		if (InStr(ch.Console.MsgText[ch.Console.TopLine]," killed ") >= 0) {
			if (!StrContains(ch.Console.MsgText[ch.Console.TopLine],"FRAG!")) { // prevent infinite loop detecting its own output! (less likely here)
				LogInfo("Detected FRAG! (from "$P.getHumanName()$"'s console) " $ ch.Console.MsgText[ch.Console.TopLine] );
			}
		}
		// ok screw this let's cheat
		*/
		// for (i=0;i<8;i++) {
			/*
			if (P.ProgressMessage[i] != "" && P.ProgressMessage[i] != LastProgressMessage[i]) {
				LogInfo("Detected line: " $ P.ProgressMessage[i]);
			}
			LastProgressMessage[i] = P.ProgressMessage[i];
			*/
			/*
			if (P.Console.GetMsgText(i) != LastConsoleMsg[i]) {
			}
			*/
		// These cause: Error, Context expression: Variable is too large (640 bytes, 255 max)
		/*
		for (i=0;i<10;i++) {
			if (ChallengeHUD(P.myHUD).LocalMessages[i] != LastProgressMessage[i]) {
				LogInfo("Detected line: " $ ChallengeHUD(P.myHUD).LocalMessages[i]);
			}
			LastProgressMessage[i] = ChallengeHUD(P.myHUD).LocalMessages[i];
		}
		for (i=0;i<10;i++) {
			comp = ch.LocalMessages[i];
			if (comp != LastProgressMessage[i]) {
				LogInfo("Detected line: " $ comp);
			}
			LastProgressMessage[i] = comp;
		}
		*/
	// }

function FlashMessageToPlayer(PlayerPawn p, string Msg, Color msgColor, optional int linenum, optional float duration) {
	if (!bFlashing)
		return; // blocked
	// Log("[nBAS "$GetDate()$"] FlashMessageToPlayer("$p$",\""$Msg$"\",...)");
	p.SetProgressTime(duration);
	p.SetProgressColor(msgColor,linenum);
	p.SetProgressMessage(Msg,linenum);
}

function ReplayEvents() {
	local String mapname;
	local int i;
	// local LoggedEvent CurrentEvent;
	local Color msgCol;
	local string report;

	// CurrentEvent = EventLog[CurrentEventi];

	if (CurrentEventi == 0 || Level.TimeSeconds > GetTime(CurrentEventi) + 3) {
		// We would like to find a new event
		if (FRand()<0.1) { // not every tick
			FindNextEvent();
			// CurrentEvent = EventLog[CurrentEventi];
			NextEventEndTime = GetTime(CurrentEventi) + 1; // not used
			// bRecordEvents = True/False;
		}
	}

	if (CurrentEventi > 0)
		ReplayEvent(CurrentEventi);

	// if (FRand()<0.9) // not every tick
		// return;

	/*
	if (NextEventEndTime > Level.TimeSeconds) {
		// We are waiting for the last event to finish
		LogInfo("Waiting.");
		return;
	}
	*/

	// if (NextEventEndTime < EventLog[CurrentEventi].Time + 2) {
		// // we are switching to a new event
	// }
	if (Int(Level.TimeSeconds) == Int(GetTime(CurrentEventi))) {
		// event is happening now!
	}

}

// Somehow we are forgetting all the EventLog[i]'s when we start a new one.

function String GetDemoID() {
	local String mapName;
	mapName = StrBefore(""$Self,".");
	LogInfo("Instead of \"" $ mapName $ "\" we could use \"" $ Level.GetLocalURL() $ "\".");
	// PlayerOwner().Level.GetLocalURL()
	return mapName;
}

function FindNextEvent() {
	local String mapname;
	local int i;
	// local LoggedEvent ev;
	#define ev EventLog[i]
	local String report;
	local string tmpName;
	local vector tmpLocation;
	
	mapname = GetDemoID();
	// for (i=CurrentEventi+1;i<eventCount;i++) {
	for (i=0;i<eventCount;i++) {
		// ev = EventLog[i];
		// EventLog[i] = ev; // will this prevent records getting lost?
		if (GetPrimary(i) == "") // null record
			continue;
		if ( bDebugLogging && FRand()<0.1 ) {
			LogDebug2( "Comparing #"$i$": "$ GetMap(i) $" = "$mapname$" and "$Int(GetTime(i))$" > "$Int(Level.TimeSeconds+2) );
			// LogDebug2(report);
		}
		// GetMap(i) == "" because my early recordings failed to record it
			// (GetMap(i) == "" || GetMap(i) == mapname)
		if (
			GetMap(i) == mapname
			&& GetTime(i) > Level.TimeSeconds+2
			&& GetTime(i) < Level.TimeSeconds+15
			&& GetSecondary(i) != ""
		) {
			CurrentEventi = i;
			report = "[>] REPLAY #"$i$" (+" $ Int(GetTime(i) - Level.TimeSeconds) $ "): " $ Int(GetTime(i)) $ " " $ GetPrimary(i) $ " > " $ GetSecondary(i);
			LogInfo(report);
			/*
			// if (FRand()<0.5) {
			// if (false) {
			if (true) {
				// Swap the primary and seconday - oh boy this swaps them in the DB!
				tmpName = EventPrimary[i];
				tmpLocation = Vector(EventPrimaryLocation[i]);
				EventPrimary[i] = EventSecondary[i];
				EventPrimaryLocation[i] = EventSecondaryLocation[i];
				EventSecondary[i] = tmpName;
				EventSecondaryLocation[i] = String(tmpLocation);
			}
			*/
			if (bAutoRecord && bRecordEvents) {
				LogInfo("Auto turning recording off.");
				bRecordEvents = False; // auto_record // TODO BUG: this is getting called a lot!
			}
			if (bAutoSwitch && bSwitchCamera) {
				LogInfo("Auto disabling camera switching.");
				bSwitchCamera = False;
			}
			// TODO: Should do this when time to ev3nt is 3 or 5, not 15!
			if (bAutoSpeed && bReplayEvents) {
				LogWarn("Changing speed to 0.8");
				Camera.ConsoleCommand("slomo 0.8");
			}
			return; // don't look at any others
			// SwitchToEvent(EventLog[i]);
			// ReplayEvent(EventLog[i]);
		}
	}

	// TODO CONSIDER: Set CurrentEventi == 0 ?

	// LogInfo("Failed to find actor for replay");
	if (FRand()<0.02) {
		// LogFlash("Failed to find actor for replay");
		FlashMessageToPlayer(Camera,"["$Int(Level.TimeSeconds)$"] [_] No ev3nt",colYellow,7,0.9);
	}

	if (bAutoRecord && !bRecordEvents) {
		LogInfo("Auto turning recording on.");
		bRecordEvents = True; // auto_record
		if (bAutoSpeed && bReplayEvents) {
			LogWarn("Changing speed to 1.2");
			Camera.ConsoleCommand("slomo 1.2");
		}
	}
	if (bAutoSwitch && !bSwitchCamera) {
		LogInfo("Auto enabling camera switching.");
		bSwitchCamera = True;
	}

	#undef ev

}

function ReplayEvent(int i) {
	local String report;

	// #define ev EventLog[i]

	// CreateNewCamera();
	if (GetSecondary(i) == "") {
		// One-man event
		// Let's skip these:
		// continue;
		// NewCamera();
		if (FindPlayerNamed(GetPrimary(i)) != None) {
			Camera.ViewTarget = FindPlayerNamed(GetPrimary(i));
			Camera.bBehindView = True;
			CameraMode = 0;
			report = "Got target "$FindPlayerNamed(GetPrimary(i));
		}
	} else {
		Camera.ViewTarget = None;
		Camera.bBehindView = False;
		report = report $ " ";
		if (FindPlayerNamed(GetPrimary(i)) != None) {
			LookActor = FindPlayerNamed(GetPrimary(i));
			report = report $ "1"; // ="$LookActor;
		}
		report = report $ "+";
		if (FindPlayerNamed(GetSecondary(i)) != None) {
			FollowActor = FindPlayerNamed(GetSecondary(i));
			report = report $ "2"; // ="$FollowActor;
			// if (!CanSee(Camera.Location,FollowActor.Location)) {
				// LogInfo("Had to move camera to see "$FollowActor);
				// Camera.SetLocation(FollowActor.Location);
			// }
		}
		if (FollowActor != None && LookActor != None) {
			CameraMode = 6;
		}
		if (bFlashing && FRand()<0.1) {
			if (Level.TimeSeconds < GetTime(i)+5)
				FlashMessageToPlayer(Camera,"["$Int(Level.TimeSeconds)$"] [>] #"$CurrentEventi$" " $ GetPrimary(i) $ " > " $ GetSecondary(i) $ " (" $ Int(GetTime(i)-Level.TimeSeconds+1) $ ") "$report,colGreen,7,1.0);
			// else
				// FlashMessageToPlayer(Camera,"["$Int(Level.TimeSeconds)$"] [_] #"$CurrentEventi$" " $ GetPrimary(i) $ " > " $ GetSecondary(i) $ " (" $ Int(GetTime(i)-Level.TimeSeconds+1) $ ")",colGreen,7,1.0);
		}
	}

	/*
	if (GetPrimaryLocation(i) != vect(0,0,0)) {
		Camera.SetLocation(GetPrimaryLocation(i));
	}
	if (GetSecondaryLocation(i) != vect(0,0,0)) {
		Camera.SetLocation(GetSecondaryLocation(i));
	}
	*/

	#undef ev

}

function ClearFlashedMessages() {
	local int i;
	for (i=0;i<8;i++)
		FlashMessageToPlayer(Camera,"",colWhite,i,0.1);
}

#endif

function CheckSwitchCamera() {

	local int i,j;
	local string report;

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds - 1) {
		// Start watching for actors which we want to catch on spawn (e.g. short-lived projectiles)
		bCheckingForInterestingTarget = True;
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 0) {
		// Camera.ConsoleCommand("ViewTeam"); // to keep fresh list of actors during online play
		// Camera.ViewClass(class'Pawn'); // to keep fresh list of actors during online play

		// TODO: turned off because of "Now viewing" detection:
		//       and back on again ;)
		// BUG: when online, this takes a little time to get back, *after* we switch cam :
		// maybe we should detect "now viewing from" and *then* switch cam
		if (bDoViewClass && !bDoneViewClass && FRand()<0.2) {
			report = report $ "[From "$CountInterestingActors()$"] ";
			// To keep a fresh list of actors during online play, we call ViewClass:
			/*
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Actor');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Actor');
			Camera.ViewClass(class'Pawn');
			Camera.ViewClass(class'Pawn');
			*/
			j = FRand()*12;
			for (i=0;i<j;i++) {
				if (Frand()<0.5)
					Camera.ViewClass(class'Pawn');
				else
					Camera.ViewClass(class'Actor');
			}
			bDoneViewClass = True;
		}
	}

	if (Level.TimeSeconds > LastSwitchTime + CameraSwitchSeconds + 1) {
		report = report $ "Time to switch camera. ";
		GetRandomCameraNow(); // If we use the player selected by ViewTeam, ... ?
		// NewCamera();
			// I want to report this later, after some time for the info to come and go:
			// if (bDoneViewClass) {
				report = report $ "[to "$CountInterestingActors()$"] ";
			// }
	}

	if (CameraMode != 3) {
		if (Camera.ViewTarget == None && FollowActor == None && LookActor == None) {
			report = report $ "LOST EVERYTHING! ";
			if (bDoViewClass) {
				Camera.ViewClass(class'Pawn');
			}
			GetRandomCameraNow();
		}
	} else {
		if (Camera.ViewTarget != None && LosingNetOn(Camera.ViewTarget)) {
			LogDebug("Losing: "$NameActor(Camera.ViewTarget));
		}
		if (FollowActor != None && LosingNetOn(FollowActor)) {
			LogDebug("Losing: "$NameActor(FollowActor));
		}
		if (LookActor != None && LosingNetOn(LookActor)) {
			LogDebug("Losing: "$NameActor(LookActor));
		}
	}

	if (report != "") {
		LogInfo(report);
	}

}

event Tick (float Delta) {
	local int i,j;
	// local int diffout;

	#ifdef MEASURE_TICKRATE
	TickCount++;
	if (Level.TimeSeconds >= TickSecond+1.0) {
		FlashMessageToPlayer(Camera,TickCount/(Level.TimeSeconds - TickSecond)$" ticks/second",colWhite,0.9);
		TickCount = 0;
		TickSecond = Level.TimeSeconds;
	}
	#endif

	if (FRand()<0.01)
		ClearFlashedMessages();

	// if (FRand()<0.01) {
		// LogInfo("Tick delta="$Delta);
	// }

	// if (  !Camera.PlayerReplicationInfo.bIsSpectator )
	// if (!Camera.PlayerReplicationInfo.bIsSpectator && !Camera.bIsPlayer) {
		// return;
	// }

	CheckConsole();

	// #ifdef ENABLE_EVENT_RECORD_REPLAY
	// if (bRecordEvents) {
		// RecordEvents();
	// }
	// #endif

	CheckForNewActors();
	if (bSwitchCamera) {
		CheckSwitchCamera();
	}

	#ifdef ENABLE_EVENT_RECORD_REPLAY
	if (bReplayEvents) {
		ReplayEvents();
	}
	#endif

	DeltaCamera(Delta);

	// Maybe it's ok to have both == None (Spec free fly mode)
	/* if (Camera.ViewTarget == None && FollowActor == None) {
		if (FRand()<0.05) {
			LogInfo("LOST ViewTarget and FollowActor!");
			Camera.ConsoleCommand("ViewTeam");
			// bCheckingForInterestingTarget = True; CheckForNewActors();
			GetRandomCameraNow();
		}
	} */

	/*
	// if ( Camera.ViewTarget != None ) {
	// if ( Camera.ViewTarget == None ) {
		// if ( Pawn(Camera.ViewTarget) != None ) {
			// targRot = Pawn(Camera.ViewTarget).ViewRotation;
			// targRot.Yaw = targRot.Yaw*0.999 + FRand();
			// targRot.Pitch = targRot.Pitch*0.999 + FRand();
			// myRot = Camera.ViewRotation;
			// ydelta = fun1(targRot.Yaw,myRot.Yaw,diffout);
			// pdelta = fun1(targRot.Pitch,myRot.Pitch,diffout);
			// if (FRand()<0.01) {
	*/

			/*
			if ( ydelta == -9999 )
			{
				SendErrMsg();
				 // TODO: = True;
			}
			*/
			/*
			if ( Pawn(Camera.ViewTarget).Health > 0 )
			{
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					if ( ydelta + Camera.ViewRotation.Yaw > 65536 )
					{
						Camera.ViewRotation.Yaw = 0;
						return;
					}
					Camera.ViewRotation.Yaw += ydelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						if ( Camera.ViewRotation.Yaw - ydelta < 0 )
						{
							Camera.ViewRotation.Yaw = 65536;
							return;
						}
						Camera.ViewRotation.Yaw -= ydelta;
					}
				}
				if ( ( > 0) && ( < 33650) || ( < -33650) )
				{
					Camera.ViewRotation.Pitch += pdelta;
				} else {
					if ( ( < 0) && ( > -33650) || ( > 33650) )
					{
						Camera.ViewRotation.Pitch -= pdelta;
					}
				}
				if ( Camera.ViewRotation.Roll != 0 )
				{
					Camera.ViewRotation.Roll = 0;
				}
			}
			*/

	// for (i=0;i<Camera.Player.Console.TopLine;i++) {
	for (i=Camera.Player.Console.TopLine;i>=0;i--) {
		Offset = InStr(Camera.Player.Console.MsgText[i],"Now viewing from ");
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"Now viewing from ");
		if (Offset != -1) {
			// RecommendedPlayerName = Mid(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Len("Now viewing from "));
			RecommendedPlayerName = Mid(Camera.Player.Console.MsgText[i],Len("Now viewing from "));
			if (Mid(RecommendedPlayerName,0,1) == " ") // sometimes (always?) there is an extra space
				RecommendedPlayerName = Mid(RecommendedPlayerName,1);
			// LogInfo("OK got >"$RecommendedPlayerName$"<");
			// LogInfo("Got RecommendedPlayerName = >"$RecommendedPlayerName$"<");
			// Force a switch now:
			if (CameraMode != 0 && CameraMode != 5) {
				// We don't do it in mode 0 or 5 since they both *cause* "Now viewing from"
				// LastSwitchTime = Level.TimeSeconds - CameraSwitchSeconds + 2; // immediate switch seems no good - tended to put me in 1st person view
				// LastSwitchTime = Level.TimeSeconds - CameraSwitchSeconds; // turned it off anyway
			}
		}
	}

	/*
	// for (i=0;i<Camera.Player.Console.TopLine;i++) {
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]," inflicted mortal damage upon ");
		if (Offset != -1) {
			if (!StrContains(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"FRAG!")) { // prevent infinite loop detecting its own output!
				LogInfo("["$Level$"@"$Level.TimeSeconds$"] FRAG! "$Camera.Player.Console.MsgText[Camera.Player.Console.TopLine]);
			}
		}
	// }
	*/

	#ifdef PKATB

	Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"mutate AFCOFF");
	if ( (Offset != -1) &&  !bAFCOFFmsg )
	{
		bautoFC = False;
		Camera.ClientMessage("Auto FC feature off");
		bAFCOFFmsg = True;
		bAFCONmsg = False;
	}
	Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"mutate AFCON");
	if ( (Offset != -1) &&  !bAFCONmsg )
	{
		bautoFC = True;
		Camera.ClientMessage("Auto FC feature on");
		bAFCOFFmsg = False;
		bAFCONmsg = True;
	}
		// TODO!
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"dropped the red flag!");
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"returns the red flag!");
		// Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"You killed ");
	if ( bautoFC /* TODO: &&  ! */ )
	{
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"captured the red flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"captured the blue flag!");
		if ( Offset != -1 )
		{
			return;
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"has the red flag!");
		if ( Offset != -1 )
		{
			redFC = Left(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"has the blue flag!");
		if ( Offset != -1 )
		{
			redFC = Left(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],Offset - 1);
		}
		Offset = InStr(Camera.Player.Console.MsgText[Camera.Player.Console.TopLine],"Failed to change view");

		/*
		if ( Offset != -1 )
		{
			redFC = "";
			blueFC = "";
		}
		if (  !bviewingFC )
		{
			if ( Camera.ViewTarget == None )
			{
				if ( redFC != "" )
				{
					ViewRedFC();
				} else {
					if ( blueFC != "" )
					{
						ViewBlueFC();
					}
				}
			} else {
				if ( Pawn(Camera.ViewTarget) == None )
				{
					if ( redFC != "" )
					{
						ViewRedFC();
					} else {
						if ( blueFC != "" )
						{
							ViewBlueFC();
						}
					}
				} else {
					if ( Pawn(Camera.ViewTarget).PlayerReplicationInfo.HasFlag == None )
					{
						if ( redFC == Pawn(Camera.ViewTarget).PlayerReplicationInfo.PlayerName )
						{
							redFC = "";
						} else {
							if ( FindPlayer(redFC) )
							{
								ViewRedFC();
							} else {
								if ( blueFC == Pawn(Camera.ViewTarget).PlayerReplicationInfo.PlayerName )
								{
									blueFC = "";
								} else {
									if ( FindPlayer(blueFC) )
									{
										ViewBlueFC();
									}
								}
							}
						}
					}
				}
			}
			SetTimer(0.31,False);
			bviewingFC = True;
		}
		*/
	}

	#endif

}





// from AutoSpectate - only if they have the flag
/*
function bool FindPlayer(string playerName) {
	local int i;
	local TournamentGameReplicationInfo ptgri;

	ptgri = TournamentGameReplicationInfo(Camera.GameReplicationInfo);
	for (i=0;i<32;i++) {
		if ( ptgri.PRIArray[i] == None ) {
			continue;
		}
		if ( ptgri.PRIArray[i].bIsSpectator ) {
			continue;
		}
		if ( ptgri.PRIArray[i].HasFlag != None ) {
			if ( ptgri.PRIArray[i].PlayerName == playerName ) {
				return True;
			} else {
				return False;
			}
		}
	}
	return False;
}
*/


/*
// Find player by name
// In first-person demo playback, only saw self =(
function Pawn FindPlayerNamed(String str) {
	local Pawn p;
	for (p=Level.PawnList; p!=None; p=p.NextPawn) {
		if (p.IsA('PlayerPawn') || p.IsA('Bot')) {
			LogInfo("nBAutoSpectate.FindPlayerNamed(\""$str$"\"): comparing to \""$p.getHumanName()$"\"");
			if (p.getHumanName() == str) {
				return p;
			}
		}
	}
	return None;
}
*/

function PlayerPawn FindPlayerNamed(string playerName) {
	local int i;
	local TournamentGameReplicationInfo ptgri;

	if (playerName == "")
		return None;

	ptgri = TournamentGameReplicationInfo(Camera.GameReplicationInfo);
	for (i=0;i<32;i++) {
		if ( ptgri.PRIArray[i] == None ) {
			continue;
		}
		if ( ptgri.PRIArray[i].bIsSpectator ) {
			continue;
		}
		// LogInfo("nBAutoSpectate.FindPlayerNamed(\""$playerName$"\"): comparing to \""$ptgri.PRIArray[i].PlayerName$"\"");
		if ( ptgri.PRIArray[i].PlayerName == playerName ) {
			#ifdef RECORD_ALL_PLAYERNAMES
			if (!StrContains(AllPlayerNames, " " $ playerName $ " ")) {
				AllPlayerNames = AllPlayerNames $ " " $ playerName $ " ";
			}
			#endif
			return PlayerPawn(ptgri.PRIArray[i].Owner);
		}
	}
	#ifdef RECORD_ALL_PLAYERNAMES
	if (StrContains(AllPlayerNames, " " $ playerName $ " ")) {
		LogInfo("Was a player but not visible right now: "$playerName);
	}
	#endif
	return None;
}

function ViewRedFC() {
	Camera.ViewPlayer(redFC);
	Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
}

function ViewBlueFC() {
	Camera.ViewPlayer(blueFC);
	Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
}



function Timer () {
	bviewingFC = False;
}

function setpawn (PlayerPawn o) {
	Camera = o;
	AddSelfAsMutator();
	Level.Game.RegisterDamageMutator(Self);
	#ifdef ENABLE_EVENT_RECORD_REPLAY
	LogWarn("nBAutoSpectate cam="$bSwitchCamera$" rec="$bRecordEvents$" replay="$bReplayEvents$" eventCount="$eventCount$" (ne="$CountNonEmptyEvents()$")");
	#endif
}

function int CountNonEmptyEvents() {
	local int i;
	local int count;
	for (i=0;i<eventCount;i++) {
		if (GetTime(i) != 0)
			count++;
	}
	return count;
}

// Adding as mutator only works in certain situations (when playing offline?).
// Best to use another method where possible.

function AddSelfAsMutator() {
	if (Level.Game == None) {
		LogInfo("AddSelfAsMutator() failed: Level.Game == None");
		return;
	}
	if (Level.Game.BaseMutator == None) {
		LogInfo("AddSelfAsMutator() failed: Level.Game.BaseMutator == None");
		return;
	}
	Level.Game.BaseMutator.AddMutator(Self);
}

// TODO: buggy ... how tho?!
function AddMutator(Mutator Other) {
	if (Other != None && Other.Class == Self.Class) {
		LogInfo("Not adding another nBAutoSpectate.");
		if (Other == Self) {
		} else {
			nBAutoSpectate(Other).Destroy();
		}
	} else {
		LogInfo("Adding mutator: "$Other);
		Super.AddMutator(Other);
	}
}

// I have not seen this hit, online or during demos:
function MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, name DamageType) {
	if (bCheckingForInterestingTarget) {
		// TODO: never happens =/
		LogInfo("Damage "$InstigatedBy$" -> "$Victim$" ActualDamage="$ActualDamage);
		// DamageType="$DamageType$" 
		if (FRand()<0.5)
			CreateNewCamera(InstigatedBy,Victim);
		else
			CreateNewCamera(Victim,InstigatedBy);
	}
}

// Catch messages from spectators:
function bool MutatorBroadcastMessage(Actor Sender, Pawn Receiver, out coerce string Msg, optional bool bBeep, out optional name Type) {
	if (Sender == Receiver && Sender.IsA('Spectator')) { // Only process the message once.
		CheckMessage(Mid(Msg,InStr(Msg,":")+1), Sender);
	}
	if (StrContains(Msg,"ow viewing from "))
		Msg="~~ "$StrAfterLast(Msg," ")$" ~~";
	return Super.MutatorBroadcastMessage(Sender,Receiver,Msg,bBeep,Type);
}

// Catch messages from players:
function bool MutatorTeamMessage(Actor Sender, Pawn Receiver, PlayerReplicationInfo PRI, coerce string Msg, name Type, optional bool bBeep) {
	if (Sender == Receiver) { // Only process the message once.
		CheckMessage(Msg, Sender);
	}
	if (StrContains(Msg,"ow viewing from "))
		Msg="~~ "$StrAfterLast(Msg," ")$" ~~";
	return Super.MutatorTeamMessage(Sender,Receiver,PRI,Msg,Type,bBeep);
}

function Mutate(String str, PlayerPawn Sender) {
	CheckMessage("!"$str, Sender);
	Super.Mutate(str,Sender);
}

function CheckMessage(String str, Actor Sender) {
	LogDebug("Got message: >"$str$"< from "$Sender);
	if (Left(str,1) == "!") {
		str = Mid(str,1);
		if (str ~= "FOLLOWFC")
			bStickWithFC = True;
		if (str ~= "NOFOLLOWFC")
			bStickWithFC = False;
		if (str ~= "DOVIEWCLASS")
			bDoViewClass = True;
		if (str ~= "NODOVIEWCLASS")
			bDoViewClass = False;
		if (Left(str,7)~="FOLLOW ")
			RecommendedPlayerName = Mid(str,7);
		if (Left(str,7)~="RESIZE " && Camera.ViewTarget != None)
			// Camera.ViewTarget.DrawScale = 0.3+1.5*FRand();
			Camera.ViewTarget.DrawScale = Camera.ViewTarget.default.DrawScale * Float(Mid(str,7));
		if (Left(str,7)~="ROLL ") {
			// Camera.Rotation.roll = -8192 + 8192*2*FRand();
			Camera.ViewRotation = Pawn(Camera.ViewTarget).ViewRotation;
		}
		if (str ~= "RECORD") { // Could make this a toggle
			bRecordEvents = True;
			LogWarn("Disabled recording.");
		}
		if (str ~= "NORECORD") {
			bRecordEvents = False;
			bAutoRecord = False;
			LogWarn("Enabled recording.");
		}
		if (str ~= "SAVE") {
			SaveData();
		}
	}
}

function SaveData() {
	LogWarn("nBAutoSpectate saving "$eventCount$" events ("$CountNonEmptyEvents()$" non-empty)");
	SaveConfig();
}

simulated function Destroyed() {
	SaveData();
	if (Camera != None) {
		Camera.ViewTarget = None;
		Camera.bBehindView = False;
		Camera.DesiredFOV = Camera.default.DesiredFOV;
	}
}

function Vector FindGoodCameraSpot(Vector from, float radius, float height) {
	local float yaw,elev;
	local Vector to;
	local Vector HitLocation,HitNormal;
	local rotator rotation;
	local int i;
	// for (yaw=FRand()*8192/2;yaw<8192*8;yaw+=8192/2) {
		// for (y=minZ;y<maxZ;y+=16) {
	// }
	for (i=0;i<20;i++) {
		yaw = FRand()*8192*8;
		// y = minZ + FRand()*(maxZ - minZ);
			rotation.roll = 0;
			// rotation.pitch = pitch;
			rotation.pitch = 0;
			rotation.yaw = yaw;
			to = from + radius*Vector(rotation);
			to.z = from.z + height;
			HitActor = Trace(HitLocation,HitNormal,to,from,false);
			// dist = VSize(HitLocation-from);
			if (HitActor == None)
				return to;
			if (i==19)
				return from + (HitLocation-from)*0.9;
		// }
	}
}

function Actor FindClosestInterestingActor(optional Actor from, optional Vector fromV) {
	local Actor A,bestActor;
	local int distance,bestDistance;
	if (from != None)
		fromV = from.Location;
	// foreach VisibleActors(class'Actor', A, 16000000, from.Location) {
	foreach AllActors(class'Actor', A) {
		// if (A != from && isInteresting(A)) {
		if (A == from)
			continue;
		if (
			// isAGoodProjectile(A)
			// || isFC(A) ||
			isInteresting(A)
			// || A.IsA('CTFFlag')
			// || A.IsA('Flag')
			// || A.IsA('Carcass')
		) {
			// distance = VSize(A.Location - from.Location);
			distance = VSize(A.Location - fromV);
			if (bestActor == None || distance < bestDistance) {
				bestActor = A;
				bestDistance = distance;
			}
		}
	}
	return bestActor;
}

defaultproperties {

	#ifdef PKATB
	bautoFC=True
	#endif

	bCameraPanning=True
	bSwitchCamera=False
	CameraSwitchSeconds=6
	bStickWithFC=True
	bDoViewClass=True

	bLogging=True
	bDebugLogging=True

	#ifdef ENABLE_EVENT_RECORD_REPLAY
	bFlashing=True
	bLogConsole=False
	bFlashConsole=True
	bRecordEvents=True
	bReplayEvents=True
	bAutoRecord=True // Turns recording on or off, depending whether previously recorded events were found.
	bAutoSwitch=True // Turns camera switching on or off, depending whether previously recorded events were found.
	bAutoSpeed=False // This can cause some desync on TimeSeconds, but maybe that was 'cos i was AutoSaving.
	bAutoSave=False

	colGreen=(R=0,G=255,B=0,A=16);
	colRed=(R=255,G=0,B=0,A=16);
	colBlue=(R=0,G=0,B=160,A=16);
	colYellow=(R=180,G=180,B=64,A=24);
	colWhite=(R=255,G=255,B=255,A=8);
	colGrey=(R=180,G=180,B=180,A=8);
	colOrange=(R=180,G=90,B=0,A=24);
	#endif

}

#include "../../JLib/findactor.uc.jpp"
#include "../../JLib/jlib.uc.jpp"

