#include <joeylib.c>

int main(int argc,String *argv) {
  
  ArgParser a=ArgParser(argc,argv);
  float focallength=a.floatafter("-focal","focal length (prop to img width)",1.0);
  a.comment("Orientation of plane in degrees:");
  float roll=deg2rad(a.floatafter("-roll","roll",3.0));
  float yaw=deg2rad(a.floatafter("-yaw","yaw",20.0));
  float pitch=deg2rad(a.floatafter("-pitch","pitch",-40.0));
  float depth=a.floatafter("-depth","depth",100.0);
  float scale=a.floatafter("-scale","scale",0.8);
  int imgwidth=a.intafter("-width",640);
  int imgheight=imgwidth*3/4;
  int numlines=a.intafter("-lines","number of lines in paragraph",10);
  float noise=a.floatafter("-noise","noise",0.0*640/imgwidth);
  String inname=a.argor("document image file","in.bmp");
  String outname=a.argor("output filename","out.bmp");
  a.done();

  // RGBmp *inputimg=RGBmp::toRGBmp(Map2d<float>::readfile(inname));
  RGBmp *inputimg=RGBmp::readfile(inname);
  RGBmp outputimg=RGBmp(imgwidth,imgheight,myRGB::white);

  inputimg->writefile("test.bmp");
  
  float size=scale*imgwidth;
  V3d cen=V3d(imgwidth/2,imgheight/2,depth);
  V3d right=V3d(size,0,0);
  V3d down=V3d(0,-size,0);
  right=right.rotated(V3d::i,pitch);
  right=right.rotated(V3d::j,yaw);
  right=right.rotated(V3d::k,roll);
  down=down.rotated(V3d::i,pitch);
  down=down.rotated(V3d::j,yaw);
  down=down.rotated(V3d::k,roll);
  printf("%s %s\n",right.toString(),down.toString());
  TexturedRectangle3d rec=TexturedRectangle3d(cen,right,down,inputimg,size);
  V3d eye=V3d(imgwidth/2,imgheight/2,-focallength*imgwidth);



  // Generate image

    for (int i=0;i<imgwidth;i++) {
      if ( (i % 30) == 0 )
        printf("%i/%i\n",i,imgwidth);
      for (int j=0;j<imgheight;j++) {
        V3d pixel=V3d((float)i,imgheight-1-(float)j,0);
        Line3d l=Line3d(eye,pixel);
        V3d intersect=rec.intersect(l);
        if (!rec.onplane(intersect))
          printf("Error here %f\n",rec.distto(intersect));
        // printf("%s %s %s %s\n",eye.toString(),pixel.toString(),l.toString(),intersect.toString());
        if (rec.inimage(intersect)) {
          // printf("*\n");
          outputimg.setpos(i,j,rec.colAt(intersect));   
        }
      }
    }

   // Do simulation
  
    Plane imageplane=Plane(V3d(0,0,0),V3d(0,0,1));
    List<Line2d> lines;
    for (int i=1;i<=numlines;i++) {
      float thru=(float)(i-1)/(float)(numlines-1);
      Line3d line=Line3d(cen-right/2.0-down/2.0+down*thru,
                      cen+right/2.0-down/2.0+down*thru);
      // Line3d line=Line3d(rec.pos+rec.down*thru,
                      // rec.pos+rec.right+rec.down*thru);
      Line3d la=Line3d(eye,line.a);
      V3d inta=imageplane.intersect(la);
      printf("%s -> %s\n",line.a.toString(),inta.toString());
      Line3d lb=Line3d(eye,line.b);
      V3d intb=imageplane.intersect(lb);
      printf("%s -> %s\n",line.b.toString(),intb.toString());
      Line2d line2d=Line2d(V2d(inta.x,imgheight-inta.y)+V2d::randomcircle()*noise,V2d(intb.x,imgheight-intb.y)+V2d::randomcircle()*noise);
      lines.add(line2d);
      outputimg.thickline(line2d.a,line2d.b,myRGB::darkgreen,4);  
      printf("%s\n",line2d.toString());
    }
    V2d hvp=lines.num(1).intersect(lines.num(2));
    Line2d baseline=Line2d(lines.num(1).a,lines.num(numlines).a);
    V2d vvpdir=(baseline.b-baseline.a).norm();
  
    // From pp.c
  
    List<float> cds;
    for (int i=1;i<=numlines;i++) {
      V2d hit=baseline.intersect(Line2d(hvp,lines.num(i).b));
      printf("%s ~ %s ?\n",lines.num(i).a.toString(),hit.toString());
      cds.add((hit-baseline.a).dot(vvpdir));
    }

    // We now do simultaneous calculation of
    // various correlation methods for comparison

    // Accumulate correlator
    Correlator2d csspacing;
    Correlator2d cslength;
    // Why not do line-spacing with gaps?
    // (seems equivalent so no worry)
    for (int i=1;i<numlines;i++) {
      float a=cds.num(i);
      // if (correlator==LineSpacing) {
        // x = average of two cds, y = dist between
        float b=cds.num(i+1);
        // float pos=(a+b)/2.0;
        float pos=a;
        csspacing.add(V2d(pos,myabs(b-a)),1.0);
        // printf("Correlating using lines =)\n");
      // } else if (correlator==LineWidth) {
        // y = width of line
        // float pos=a;
        cslength.add(V2d(pos,lines.num(i).length),1.0);
      // } else {
        // error("Non existent correlation method");
      // }
    }

    // One of the methods is chosen for final VVP.
    float vpd=csspacing.crossesy();
    printf("VP is %f along baseline\n",vpd);
    V2d vvp=baseline.a+vvpdir*vpd;

    V2d vvpfromdata=baseline.intersect(Line2d(lines.num(1).b,lines.num(numlines).b));

    printf("Found %s ~ Source %s ?\n",vvp.toString(),vvpfromdata.toString());

    drawCorrelator2dInColour(csspacing).writefile("spacings.bmp");
    drawCorrelator2dInColour(cslength).writefile("lengths.bmp");
  


  //// Overlay simulation results

    outputimg.line(hvp,lines.num(1).a,myRGB::red);  
    outputimg.line(hvp,lines.num(numlines).a,myRGB::red);  
    outputimg.line(vvp,lines.num(1).a,myRGB::red);  
    outputimg.line(vvp,lines.num(1).b,myRGB::red);  
    outputimg.line(vvpfromdata,lines.num(1).a,myRGB::red);  
    outputimg.line(vvpfromdata,lines.num(1).b,myRGB::red);  

  outputimg.writefile(outname);

  // Output data to accompany
//   List<String> data;
//   data.add(Sformat("Eye:%s",eye.toString());
//   data.add(Sformat("Eye:%s",eye.toString());
//   data.add(Sformat("Eye:%s",eye.toString());
//   data.add(Sformat("Eye:%s",eye.toString());
//   data.add(Sformat("Eye:%s",eye.toString());
//   data.add(Sformat("Eye:%s",eye.toString());
//   data.add(Sformat("Eye:%s",eye.toString());
  
//   Map2d<bool> *in=Map2d<float>::readfile(ifname)->threshold(0.5);
// //  in->display();
//   Map2d<bool> *n=new Map2d<bool>(in->width,in->height);
// 
//   for (int i=0;i<n->width;i++)
//     for (int j=0;j<=n->height;j++) {
//       if (npixelwithinrad(in,i,j,r))
//         n->pos[i][j]=true;
//       else
//         n->pos[i][j]=false;
//     }
// 
//   n->writefile(ofname);
// //  n->display();
//   printf("expand: written file %s radius %i\n",ofname,r);

}
